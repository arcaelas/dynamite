{"config":{"lang":["en","es","de"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Arcaelas Dynamite","text":"<p>Modern decorator-first ORM for AWS DynamoDB with TypeScript support.</p>"},{"location":"#what-is-dynamite","title":"What is Dynamite?","text":"<p>Arcaelas Dynamite is a powerful, decorator-based Object-Relational Mapping (ORM) library for AWS DynamoDB. It provides a clean, intuitive API that leverages TypeScript decorators to define your data models with type safety and minimal boilerplate.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#decorator-first-design","title":"Decorator-First Design","text":"<p>Define your models using familiar TypeScript decorators:</p> <pre><code>import { Table, PrimaryKey, CreatedAt, UpdatedAt } from '@arcaelas/dynamite';\n\nclass User extends Table {\n  @PrimaryKey()\n  id: string;\n\n  @Default(() =&gt; 'active')\n  status: string;\n\n  @CreatedAt()\n  created_at: Date;\n\n  @UpdatedAt()\n  updated_at: Date;\n}\n</code></pre>"},{"location":"#type-safe-relationships","title":"Type-Safe Relationships","text":"<p>Built-in support for one-to-many and many-to-one relationships:</p> <pre><code>import { HasMany, BelongsTo } from '@arcaelas/dynamite';\n\nclass User extends Table {\n  @HasMany(() =&gt; Post, 'user_id')\n  posts: HasMany&lt;Post&gt;;\n}\n\nclass Post extends Table {\n  @BelongsTo(() =&gt; User, 'user_id')\n  user: BelongsTo&lt;User&gt;;\n}\n</code></pre>"},{"location":"#powerful-query-builder","title":"Powerful Query Builder","text":"<p>Intuitive query interface with full TypeScript support:</p> <pre><code>const active_users = await User.where('status', '=', 'active')\n  .where('created_at', '&gt;', new Date('2024-01-01'))\n  .include('posts')\n  .get();\n</code></pre>"},{"location":"#validation-transformation","title":"Validation &amp; Transformation","text":"<p>Built-in decorators for data validation and mutation:</p> <pre><code>class User extends Table {\n  @Validate(value =&gt; value.length &gt;= 8, 'Password must be at least 8 characters')\n  password: string;\n\n  @Mutate(value =&gt; value.toLowerCase().trim())\n  email: string;\n}\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>npm install @arcaelas/dynamite\n# or\nyarn add @arcaelas/dynamite\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import { Dynamite, Table, PrimaryKey } from '@arcaelas/dynamite';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\n\n// Configure DynamoDB client\nconst client = new DynamoDBClient({ region: 'us-east-1' });\nDynamite.configure({ client });\n\n// Define your model\nclass User extends Table {\n  @PrimaryKey()\n  id: string;\n\n  name: string;\n  email: string;\n}\n\n// Create a new user\nconst user = await User.create({\n  id: '123',\n  name: 'John Doe',\n  email: 'john@example.com'\n});\n\n// Query users\nconst users = await User.where('name', '=', 'John Doe').get();\n\n// Update\nuser.email = 'newemail@example.com';\nawait user.save();\n\n// Delete\nawait user.destroy();\n</code></pre>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>Dynamite is built on three core concepts:</p> <ol> <li>Table - Base class for all models with CRUD operations</li> <li>Decorators - Define schema, validation, and behavior</li> <li>Relationships - Connect models with type-safe associations</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Your Models                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  User extends Table              \u2502   \u2502\n\u2502  \u2502  - @PrimaryKey() id              \u2502   \u2502\n\u2502  \u2502  - @HasMany() posts              \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Dynamite ORM                    \u2502\n\u2502  - Query Builder                         \u2502\n\u2502  - Relationship Resolver                 \u2502\n\u2502  - Decorator Processing                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         AWS SDK v3                       \u2502\n\u2502  - DynamoDBClient                        \u2502\n\u2502  - DynamoDB Document Client              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#why-dynamite","title":"Why Dynamite?","text":"<ul> <li>Type Safety - Full TypeScript support with advanced types</li> <li>Developer Experience - Clean, intuitive API with minimal boilerplate</li> <li>Modern - Built on AWS SDK v3 with ESM support</li> <li>Flexible - Supports complex queries, relationships, and custom logic</li> <li>Lightweight - Minimal dependencies, focused on DynamoDB</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Set up Dynamite in your project</li> <li>Getting Started - Your first Dynamite model</li> <li>Core Concepts - Understanding the fundamentals</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub: github.com/arcaelas/dynamite</li> <li>Issues: Report bugs or request features</li> <li>NPM: @arcaelas/dynamite</li> </ul> <p>Ready to get started? Install Dynamite and create your first model in minutes.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#planned","title":"Planned","text":"<ul> <li>Enhanced transaction support for complex operations</li> <li>Performance optimizations for batch operations</li> <li>Additional query operators and filters</li> <li>Improved error handling and debugging tools</li> </ul>"},{"location":"CHANGELOG/#1013-2025-10-13","title":"[1.0.13] - 2025-10-13","text":""},{"location":"CHANGELOG/#current-release","title":"Current Release","text":"<p>This is the current stable release of @arcaelas/dynamite - a modern, decorator-first ORM for DynamoDB with full TypeScript support.</p>"},{"location":"CHANGELOG/#features","title":"Features","text":""},{"location":"CHANGELOG/#core-functionality","title":"Core Functionality","text":"<ul> <li>Full-featured ORM with decorator-first approach</li> <li>Complete TypeScript support with type safety</li> <li>Auto table creation and management</li> <li>Zero boilerplate configuration</li> </ul>"},{"location":"CHANGELOG/#decorators","title":"Decorators","text":"<ul> <li>Core Decorators: <code>@PrimaryKey()</code>, <code>@Index()</code>, <code>@IndexSort()</code>, <code>@Name()</code></li> <li>Data Decorators: <code>@Default()</code>, <code>@Mutate()</code>, <code>@Validate()</code>, <code>@NotNull()</code></li> <li>Timestamp Decorators: <code>@CreatedAt()</code>, <code>@UpdatedAt()</code></li> <li>Relationship Decorators: <code>@HasMany()</code>, <code>@BelongsTo()</code></li> </ul>"},{"location":"CHANGELOG/#typescript-types","title":"TypeScript Types","text":"<ul> <li><code>CreationOptional&lt;T&gt;</code> - Mark fields as optional during creation</li> <li><code>NonAttribute&lt;T&gt;</code> - Exclude computed properties from database</li> <li><code>HasMany&lt;T&gt;</code> - One-to-many relationships</li> <li><code>BelongsTo&lt;T&gt;</code> - Many-to-one relationships</li> <li><code>InferAttributes&lt;T&gt;</code> - Type inference for model attributes</li> </ul>"},{"location":"CHANGELOG/#query-operations","title":"Query Operations","text":"<ul> <li>Basic CRUD operations (create, read, update, delete)</li> <li>Advanced query operators: <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>in</code>, <code>not-in</code>, <code>contains</code>, <code>begins-with</code></li> <li>Pagination support with <code>limit</code> and <code>skip</code></li> <li>Sorting with <code>order</code> (ASC/DESC)</li> <li>Attribute selection with <code>attributes</code> array</li> <li>Complex filtering with multiple conditions</li> </ul>"},{"location":"CHANGELOG/#relationships","title":"Relationships","text":"<ul> <li>One-to-many relationships via <code>@HasMany()</code></li> <li>Many-to-one relationships via <code>@BelongsTo()</code></li> <li>Nested relationship loading with <code>include</code></li> <li>Filtered relationship queries</li> <li>Recursive relationship support</li> </ul>"},{"location":"CHANGELOG/#data-validation-transformation","title":"Data Validation &amp; Transformation","text":"<ul> <li>Field validation with custom validators</li> <li>Data mutation/transformation before save</li> <li>Multi-step validation chains</li> <li>Not-null constraints</li> <li>Email, age, and custom format validation</li> </ul>"},{"location":"CHANGELOG/#configuration","title":"Configuration","text":"<ul> <li>AWS DynamoDB connection support</li> <li>DynamoDB Local development support</li> <li>Custom endpoint configuration</li> <li>Flexible credential management</li> <li>Environment variable support</li> </ul>"},{"location":"CHANGELOG/#dependencies","title":"Dependencies","text":"<ul> <li><code>@aws-sdk/client-dynamodb</code>: ^3.329.0</li> <li><code>@aws-sdk/lib-dynamodb</code>: ^3.329.0</li> <li><code>pluralize</code>: ^8.0.0</li> <li><code>uuid</code>: ^11.1.0</li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>Comprehensive README with examples</li> <li>TypeScript types documentation</li> <li>API reference guide</li> <li>Development setup instructions</li> <li>Troubleshooting guide</li> <li>Best practices and performance tips</li> </ul>"},{"location":"CHANGELOG/#100-initial-release","title":"[1.0.0] - Initial Release","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Initial release of @arcaelas/dynamite</li> <li>Base Table class implementation</li> <li>Core decorator system</li> <li>DynamoDB client wrapper</li> <li>Metadata management system</li> <li>Basic CRUD operations</li> <li>Query builder functionality</li> <li>Relationship support foundation</li> <li>TypeScript definitions</li> <li>Jest testing setup</li> </ul>"},{"location":"CHANGELOG/#version-history-summary","title":"Version History Summary","text":"<ul> <li>v1.0.13 (Current) - Stable release with full feature set</li> <li>v1.0.0 - Initial public release</li> </ul>"},{"location":"CHANGELOG/#links","title":"Links","text":"<ul> <li>Repository: https://github.com/arcaelas/dynamite</li> <li>Issues: https://github.com/arcaelas/dynamite/issues</li> <li>NPM Package: https://www.npmjs.com/package/@arcaelas/dynamite</li> <li>Author: Arcaelas Insiders</li> </ul>"},{"location":"CHANGELOG/#migration-guides","title":"Migration Guides","text":""},{"location":"CHANGELOG/#upgrading-to-v1013","title":"Upgrading to v1.0.13","text":"<p>No breaking changes from v1.0.0. All features are backward compatible.</p>"},{"location":"CHANGELOG/#contributing","title":"Contributing","text":"<p>See README.md for contribution guidelines.</p> <p>Note: For detailed usage examples and API documentation, please refer to the README.md file.</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>Complete installation and configuration guide for @arcaelas/dynamite</p> <p>This guide covers everything you need to install, configure, and verify @arcaelas/dynamite in your project.</p>"},{"location":"installation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Prerequisites</li> <li>Installation</li> <li>AWS Configuration</li> <li>Basic Configuration</li> <li>Verification</li> <li>Troubleshooting</li> <li>Next Steps</li> </ul>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing @arcaelas/dynamite, ensure your development environment meets these requirements:</p>"},{"location":"installation/#nodejs-version","title":"Node.js Version","text":"<ul> <li>Node.js 16.x or higher (18.x or 20.x recommended)</li> <li>npm 7.x or higher or yarn 1.22.x or higher</li> </ul> <p>Check your versions:</p> <pre><code>node --version  # Should be &gt;= 16.0.0\nnpm --version   # Should be &gt;= 7.0.0\n</code></pre> <p>If you need to upgrade Node.js, we recommend using nvm:</p> <pre><code># Install Node.js 20 LTS\nnvm install 20\nnvm use 20\n</code></pre>"},{"location":"installation/#aws-account-requirements","title":"AWS Account Requirements","text":"<p>You'll need one of the following:</p> <ol> <li>AWS Account with DynamoDB access</li> <li>Valid AWS credentials (Access Key ID and Secret Access Key)</li> <li>IAM permissions for DynamoDB operations</li> <li> <p>AWS region selection (e.g., <code>us-east-1</code>, <code>eu-west-1</code>)</p> </li> <li> <p>DynamoDB Local for development (recommended for testing)</p> </li> <li>Docker installed (easiest method)</li> <li>Or Java Runtime Environment 8.x or higher</li> </ol>"},{"location":"installation/#dynamodb-table-setup","title":"DynamoDB Table Setup","text":"<p>@arcaelas/dynamite can automatically create tables, but you should understand:</p> <ul> <li>Primary Key Structure: Each table needs a partition key (and optionally a sort key)</li> <li>Billing Mode: Choose between On-Demand or Provisioned capacity</li> <li>Table Naming: Tables are automatically named based on your model class names</li> </ul> <p>Note: For production, you may want to create tables manually for better control over capacity and indexes.</p>"},{"location":"installation/#typescript-optional-but-recommended","title":"TypeScript (Optional but Recommended)","text":"<ul> <li>TypeScript 5.x or higher for full type safety</li> <li>Configure <code>tsconfig.json</code> with strict mode enabled</li> </ul> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n</code></pre>"},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#install-via-npm","title":"Install via npm","text":"<pre><code># Install @arcaelas/dynamite\nnpm install @arcaelas/dynamite\n\n# Install peer dependencies\nnpm install @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb\n</code></pre>"},{"location":"installation/#install-via-yarn","title":"Install via yarn","text":"<pre><code># Install @arcaelas/dynamite\nyarn add @arcaelas/dynamite\n\n# Install peer dependencies\nyarn add @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb\n</code></pre>"},{"location":"installation/#install-via-pnpm","title":"Install via pnpm","text":"<pre><code># Install @arcaelas/dynamite\npnpm add @arcaelas/dynamite\n\n# Install peer dependencies\npnpm add @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify the packages are installed correctly:</p> <pre><code>npm list @arcaelas/dynamite @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb\n</code></pre> <p>You should see output similar to:</p> <pre><code>project@1.0.0 /path/to/project\n\u251c\u2500\u2500 @arcaelas/dynamite@x.x.x\n\u251c\u2500\u2500 @aws-sdk/client-dynamodb@x.x.x\n\u2514\u2500\u2500 @aws-sdk/lib-dynamodb@x.x.x\n</code></pre>"},{"location":"installation/#aws-configuration","title":"AWS Configuration","text":""},{"location":"installation/#option-1-dynamodb-local-recommended-for-development","title":"Option 1: DynamoDB Local (Recommended for Development)","text":"<p>DynamoDB Local is perfect for development and testing without AWS costs.</p>"},{"location":"installation/#using-docker","title":"Using Docker","text":"<p>The easiest way to run DynamoDB Local:</p> <pre><code># Pull and run DynamoDB Local\ndocker run -d \\\n  -p 8000:8000 \\\n  --name dynamodb-local \\\n  amazon/dynamodb-local\n</code></pre>"},{"location":"installation/#using-docker-compose","title":"Using Docker Compose","text":"<p>Create a <code>docker-compose.yml</code> file:</p> <pre><code>version: '3.8'\n\nservices:\n  dynamodb-local:\n    image: amazon/dynamodb-local\n    container_name: dynamodb-local\n    ports:\n      - \"8000:8000\"\n    command: [\"-jar\", \"DynamoDBLocal.jar\", \"-sharedDb\", \"-dbPath\", \"/home/dynamodblocal/data/\"]\n    volumes:\n      - dynamodb_data:/home/dynamodblocal/data\n    working_dir: /home/dynamodblocal\n\nvolumes:\n  dynamodb_data:\n    driver: local\n</code></pre> <p>Start the service:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"installation/#using-java-runtime","title":"Using Java Runtime","text":"<p>If you don't use Docker, download and run DynamoDB Local directly:</p> <pre><code># Download DynamoDB Local\nwget https://s3.us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.tar.gz\n\n# Extract\ntar -xvzf dynamodb_local_latest.tar.gz\n\n# Run\njava -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb\n</code></pre>"},{"location":"installation/#verify-dynamodb-local-is-running","title":"Verify DynamoDB Local is Running","text":"<pre><code># Test connection\ncurl http://localhost:8000\n\n# Or list tables (should return empty array initially)\naws dynamodb list-tables --endpoint-url http://localhost:8000 --region us-east-1\n</code></pre>"},{"location":"installation/#option-2-aws-dynamodb-production","title":"Option 2: AWS DynamoDB (Production)","text":"<p>For production deployment, use AWS DynamoDB.</p>"},{"location":"installation/#set-up-aws-credentials","title":"Set Up AWS Credentials","text":"<p>Method 1: AWS CLI Configuration (Recommended)</p> <pre><code># Install AWS CLI if not already installed\n# https://aws.amazon.com/cli/\n\n# Configure credentials\naws configure\n\n# Enter your credentials when prompted:\n# AWS Access Key ID: YOUR_ACCESS_KEY_ID\n# AWS Secret Access Key: YOUR_SECRET_ACCESS_KEY\n# Default region name: us-east-1\n# Default output format: json\n</code></pre> <p>Method 2: Environment Variables</p> <pre><code>export AWS_ACCESS_KEY_ID=\"your-access-key-id\"\nexport AWS_SECRET_ACCESS_KEY=\"your-secret-access-key\"\nexport AWS_REGION=\"us-east-1\"\n</code></pre> <p>Method 3: IAM Roles (For EC2, Lambda, ECS)</p> <p>If running on AWS infrastructure, use IAM roles instead of credentials:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"dynamodb:PutItem\",\n        \"dynamodb:GetItem\",\n        \"dynamodb:UpdateItem\",\n        \"dynamodb:DeleteItem\",\n        \"dynamodb:Query\",\n        \"dynamodb:Scan\",\n        \"dynamodb:BatchGetItem\",\n        \"dynamodb:BatchWriteItem\",\n        \"dynamodb:DescribeTable\",\n        \"dynamodb:CreateTable\"\n      ],\n      \"Resource\": \"arn:aws:dynamodb:*:*:table/*\"\n    }\n  ]\n}\n</code></pre>"},{"location":"installation/#select-your-aws-region","title":"Select Your AWS Region","text":"<p>Choose a region close to your users for lower latency:</p> <ul> <li><code>us-east-1</code> - US East (N. Virginia)</li> <li><code>us-west-2</code> - US West (Oregon)</li> <li><code>eu-west-1</code> - Europe (Ireland)</li> <li><code>ap-southeast-1</code> - Asia Pacific (Singapore)</li> <li>View all regions</li> </ul>"},{"location":"installation/#basic-configuration","title":"Basic Configuration","text":""},{"location":"installation/#create-configuration-file","title":"Create Configuration File","text":"<p>Create a configuration file to initialize Dynamite:</p> <p>config/database.ts (TypeScript)</p> <pre><code>import { Dynamite } from \"@arcaelas/dynamite\";\n\nexport function ConfigureDatabase() {\n  // Development configuration (DynamoDB Local)\n  if (process.env.NODE_ENV === \"development\") {\n    Dynamite.config({\n      region: \"us-east-1\",\n      endpoint: \"http://localhost:8000\",\n      credentials: {\n        accessKeyId: \"test\",\n        secretAccessKey: \"test\"\n      }\n    });\n  }\n  // Production configuration (AWS DynamoDB)\n  else {\n    Dynamite.config({\n      region: process.env.AWS_REGION || \"us-east-1\",\n      credentials: {\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!\n      }\n    });\n  }\n}\n</code></pre> <p>config/database.js (JavaScript)</p> <pre><code>const { Dynamite } = require(\"@arcaelas/dynamite\");\n\nfunction ConfigureDatabase() {\n  // Development configuration (DynamoDB Local)\n  if (process.env.NODE_ENV === \"development\") {\n    Dynamite.config({\n      region: \"us-east-1\",\n      endpoint: \"http://localhost:8000\",\n      credentials: {\n        accessKeyId: \"test\",\n        secretAccessKey: \"test\"\n      }\n    });\n  }\n  // Production configuration (AWS DynamoDB)\n  else {\n    Dynamite.config({\n      region: process.env.AWS_REGION || \"us-east-1\",\n      credentials: {\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY\n      }\n    });\n  }\n}\n\nmodule.exports = { ConfigureDatabase };\n</code></pre>"},{"location":"installation/#environment-variables-setup","title":"Environment Variables Setup","text":"<p>Create a <code>.env</code> file in your project root:</p> <pre><code># Development\nNODE_ENV=development\nDYNAMODB_ENDPOINT=http://localhost:8000\n\n# Production (only set these in production)\n# NODE_ENV=production\n# AWS_REGION=us-east-1\n# AWS_ACCESS_KEY_ID=your-access-key-id\n# AWS_SECRET_ACCESS_KEY=your-secret-access-key\n</code></pre> <p>Install dotenv to load environment variables:</p> <pre><code>npm install dotenv\n</code></pre> <p>Load environment variables in your application:</p> <pre><code>// At the top of your main file (index.ts, app.ts, server.ts)\nimport dotenv from \"dotenv\";\ndotenv.config();\n\nimport { ConfigureDatabase } from \"./config/database\";\nConfigureDatabase();\n</code></pre>"},{"location":"installation/#define-your-first-model","title":"Define Your First Model","text":"<p>Create a simple User model to test the installation:</p> <p>models/user.ts (TypeScript)</p> <pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  CreationOptional,\n  NotNull\n} from \"@arcaelas/dynamite\";\n\nexport class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare name: string;\n\n  @NotNull()\n  declare email: string;\n\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n}\n</code></pre> <p>models/user.js (JavaScript)</p> <pre><code>const {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  NotNull\n} = require(\"@arcaelas/dynamite\");\n\nclass User extends Table {\n  id;\n  name;\n  email;\n  role;\n  active;\n  createdAt;\n  updatedAt;\n}\n\n// Apply decorators\nPrimaryKey()(User.prototype, \"id\");\nDefault(() =&gt; crypto.randomUUID())(User.prototype, \"id\");\nNotNull()(User.prototype, \"name\");\nNotNull()(User.prototype, \"email\");\nDefault(() =&gt; \"customer\")(User.prototype, \"role\");\nDefault(() =&gt; true)(User.prototype, \"active\");\nCreatedAt()(User.prototype, \"createdAt\");\nUpdatedAt()(User.prototype, \"updatedAt\");\n\nmodule.exports = { User };\n</code></pre>"},{"location":"installation/#complete-application-setup","title":"Complete Application Setup","text":"<p>index.ts (TypeScript)</p> <pre><code>import dotenv from \"dotenv\";\ndotenv.config();\n\nimport { ConfigureDatabase } from \"./config/database\";\nimport { User } from \"./models/user\";\n\n// Initialize database connection\nConfigureDatabase();\n\nasync function main() {\n  try {\n    // Create a new user\n    const user = await User.create({\n      name: \"John Doe\",\n      email: \"john@example.com\"\n    });\n\n    console.log(\"User created:\", user);\n    console.log(\"ID:\", user.id);\n    console.log(\"Name:\", user.name);\n    console.log(\"Email:\", user.email);\n    console.log(\"Role:\", user.role);\n    console.log(\"Active:\", user.active);\n    console.log(\"Created At:\", user.createdAt);\n\n    // Query all users\n    const allUsers = await User.where({});\n    console.log(\"Total users:\", allUsers.length);\n\n  } catch (error) {\n    console.error(\"Error:\", error);\n    process.exit(1);\n  }\n}\n\nmain();\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":""},{"location":"installation/#step-1-test-database-connection","title":"Step 1: Test Database Connection","text":"<p>Create a simple test file:</p> <p>test-connection.ts</p> <pre><code>import dotenv from \"dotenv\";\ndotenv.config();\n\nimport { Dynamite } from \"@arcaelas/dynamite\";\n\nasync function TestConnection() {\n  try {\n    Dynamite.config({\n      region: \"us-east-1\",\n      endpoint: process.env.DYNAMODB_ENDPOINT || \"http://localhost:8000\",\n      credentials: {\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID || \"test\",\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || \"test\"\n      }\n    });\n\n    console.log(\"\u2713 Dynamite configured successfully\");\n    console.log(\"\u2713 Connection test passed\");\n\n  } catch (error) {\n    console.error(\"\u2717 Connection failed:\", error);\n    process.exit(1);\n  }\n}\n\nTestConnection();\n</code></pre> <p>Run the test:</p> <pre><code>npm run build  # If using TypeScript\nnode dist/test-connection.js\n\n# Or with ts-node\nnpx ts-node test-connection.ts\n</code></pre> <p>Expected output:</p> <pre><code>\u2713 Dynamite configured successfully\n\u2713 Connection test passed\n</code></pre>"},{"location":"installation/#step-2-test-model-operations","title":"Step 2: Test Model Operations","text":"<p>Create a comprehensive test:</p> <p>test-model.ts</p> <pre><code>import dotenv from \"dotenv\";\ndotenv.config();\n\nimport { ConfigureDatabase } from \"./config/database\";\nimport { User } from \"./models/user\";\n\nConfigureDatabase();\n\nasync function TestModelOperations() {\n  console.log(\"Starting model operations test...\\n\");\n\n  try {\n    // Test 1: Create\n    console.log(\"Test 1: Creating user...\");\n    const user = await User.create({\n      name: \"Test User\",\n      email: \"test@example.com\"\n    });\n    console.log(\"\u2713 User created:\", user.id);\n\n    // Test 2: Read\n    console.log(\"\\nTest 2: Reading user...\");\n    const foundUser = await User.first({ id: user.id });\n    console.log(\"\u2713 User found:\", foundUser?.name);\n\n    // Test 3: Update\n    console.log(\"\\nTest 3: Updating user...\");\n    await User.update(user.id, { name: \"Updated Name\" });\n    const updatedUser = await User.first({ id: user.id });\n    console.log(\"\u2713 User updated:\", updatedUser?.name);\n\n    // Test 4: Query\n    console.log(\"\\nTest 4: Querying users...\");\n    const users = await User.where({ active: true });\n    console.log(\"\u2713 Found\", users.length, \"active users\");\n\n    // Test 5: Delete\n    console.log(\"\\nTest 5: Deleting user...\");\n    await User.delete(user.id);\n    const deletedUser = await User.first({ id: user.id });\n    console.log(\"\u2713 User deleted:\", deletedUser === undefined);\n\n    console.log(\"\\n\u2713 All tests passed!\");\n\n  } catch (error) {\n    console.error(\"\\n\u2717 Test failed:\", error);\n    process.exit(1);\n  }\n}\n\nTestModelOperations();\n</code></pre> <p>Run the test:</p> <pre><code>npx ts-node test-model.ts\n</code></pre> <p>Expected output:</p> <pre><code>Starting model operations test...\n\nTest 1: Creating user...\n\u2713 User created: abc-123-def-456\n\nTest 2: Reading user...\n\u2713 User found: Test User\n\nTest 3: Updating user...\n\u2713 User updated: Updated Name\n\nTest 4: Querying users...\n\u2713 Found 1 active users\n\nTest 5: Deleting user...\n\u2713 User deleted: true\n\n\u2713 All tests passed!\n</code></pre>"},{"location":"installation/#step-3-verify-table-creation","title":"Step 3: Verify Table Creation","text":"<p>Check that DynamoDB tables were created:</p> <pre><code># For DynamoDB Local\naws dynamodb list-tables \\\n  --endpoint-url http://localhost:8000 \\\n  --region us-east-1\n\n# For AWS DynamoDB\naws dynamodb list-tables --region us-east-1\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"TableNames\": [\n    \"User\"\n  ]\n}\n</code></pre> <p>Describe the table structure:</p> <pre><code># For DynamoDB Local\naws dynamodb describe-table \\\n  --table-name User \\\n  --endpoint-url http://localhost:8000 \\\n  --region us-east-1\n\n# For AWS DynamoDB\naws dynamodb describe-table \\\n  --table-name User \\\n  --region us-east-1\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-installation-issues","title":"Common Installation Issues","text":""},{"location":"installation/#issue-module-not-found","title":"Issue: Module Not Found","text":"<p>Error: <pre><code>Error: Cannot find module '@arcaelas/dynamite'\n</code></pre></p> <p>Solution: <pre><code># Verify installation\nnpm list @arcaelas/dynamite\n\n# Reinstall if necessary\nnpm install @arcaelas/dynamite --save\n\n# Clear cache and reinstall\nrm -rf node_modules package-lock.json\nnpm install\n</code></pre></p>"},{"location":"installation/#issue-peer-dependencies-missing","title":"Issue: Peer Dependencies Missing","text":"<p>Error: <pre><code>npm WARN @arcaelas/dynamite requires a peer of @aws-sdk/client-dynamodb\n</code></pre></p> <p>Solution: <pre><code># Install all peer dependencies\nnpm install @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb\n</code></pre></p>"},{"location":"installation/#issue-typescript-decorator-errors","title":"Issue: TypeScript Decorator Errors","text":"<p>Error: <pre><code>error TS1238: Unable to resolve signature of class decorator\n</code></pre></p> <p>Solution:</p> <p>Update your <code>tsconfig.json</code>:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n</code></pre>"},{"location":"installation/#common-configuration-issues","title":"Common Configuration Issues","text":""},{"location":"installation/#issue-cannot-connect-to-dynamodb-local","title":"Issue: Cannot Connect to DynamoDB Local","text":"<p>Error: <pre><code>NetworkingError: connect ECONNREFUSED 127.0.0.1:8000\n</code></pre></p> <p>Solution:</p> <pre><code># Check if DynamoDB Local is running\ndocker ps | grep dynamodb-local\n\n# If not running, start it\ndocker run -d -p 8000:8000 amazon/dynamodb-local\n\n# Test connection\ncurl http://localhost:8000\n</code></pre>"},{"location":"installation/#issue-aws-credentials-invalid","title":"Issue: AWS Credentials Invalid","text":"<p>Error: <pre><code>UnrecognizedClientException: The security token included in the request is invalid\n</code></pre></p> <p>Solution:</p> <pre><code># Verify credentials\naws sts get-caller-identity\n\n# Reconfigure AWS CLI\naws configure\n\n# Or check environment variables\necho $AWS_ACCESS_KEY_ID\necho $AWS_SECRET_ACCESS_KEY\n</code></pre>"},{"location":"installation/#issue-missing-table-permissions","title":"Issue: Missing Table Permissions","text":"<p>Error: <pre><code>AccessDeniedException: User is not authorized to perform: dynamodb:CreateTable\n</code></pre></p> <p>Solution:</p> <p>Ensure your IAM user/role has the necessary permissions:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"dynamodb:CreateTable\",\n        \"dynamodb:DescribeTable\",\n        \"dynamodb:PutItem\",\n        \"dynamodb:GetItem\",\n        \"dynamodb:Query\",\n        \"dynamodb:Scan\",\n        \"dynamodb:UpdateItem\",\n        \"dynamodb:DeleteItem\"\n      ],\n      \"Resource\": \"arn:aws:dynamodb:*:*:table/*\"\n    }\n  ]\n}\n</code></pre>"},{"location":"installation/#runtime-issues","title":"Runtime Issues","text":""},{"location":"installation/#issue-metadata-not-found","title":"Issue: Metadata Not Found","text":"<p>Error: <pre><code>Error: Metadata no encontrada para la tabla User\n</code></pre></p> <p>Solution:</p> <p>Ensure decorators are executed before using the model:</p> <pre><code>// \u2713 Correct: Import model before using\nimport { User } from \"./models/user\";\nconst user = await User.create({ name: \"John\" });\n\n// \u2717 Wrong: Using model before decorators execute\nconst user = await User.create({ name: \"John\" });\nimport { User } from \"./models/user\";\n</code></pre>"},{"location":"installation/#issue-primary-key-missing","title":"Issue: Primary Key Missing","text":"<p>Error: <pre><code>Error: PartitionKey faltante en la tabla User\n</code></pre></p> <p>Solution:</p> <p>Every model must have a primary key:</p> <pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()  // Add this decorator\n  declare id: string;\n}\n</code></pre>"},{"location":"installation/#performance-issues","title":"Performance Issues","text":""},{"location":"installation/#issue-slow-queries","title":"Issue: Slow Queries","text":"<p>Check your query patterns:</p> <pre><code>// \u2717 Bad: Scanning entire table\nconst users = (await User.where({})).filter(u =&gt; u.age &gt; 18);\n\n// \u2713 Good: Using query filters\nconst users = await User.where(\"age\", \"&gt;\", 18);\n</code></pre>"},{"location":"installation/#issue-high-memory-usage","title":"Issue: High Memory Usage","text":"<p>Use attribute projection to limit data:</p> <pre><code>// \u2713 Only fetch needed fields\nconst users = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\"]\n});\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've successfully installed and configured @arcaelas/dynamite.</p>"},{"location":"installation/#recommended-next-steps","title":"Recommended Next Steps","text":"<ol> <li>Learn the Basics: Read the Getting Started Guide</li> <li>Explore Features: Check out Advanced Features</li> <li>Understand Relationships: Learn about Relationships</li> <li>Master Queries: Study Query Operations</li> <li>TypeScript Types: Review TypeScript Types</li> </ol>"},{"location":"installation/#example-projects","title":"Example Projects","text":"<p>Create a sample project to practice:</p> <pre><code>mkdir my-dynamite-app\ncd my-dynamite-app\nnpm init -y\nnpm install @arcaelas/dynamite @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb\n</code></pre>"},{"location":"installation/#additional-resources","title":"Additional Resources","text":"<ul> <li>API Reference</li> <li>DynamoDB Best Practices</li> <li>AWS SDK v3 Documentation</li> <li>GitHub Repository</li> </ul>"},{"location":"installation/#community-and-support","title":"Community and Support","text":"<ul> <li>Issues: Report bugs on GitHub</li> <li>Discussions: Join community discussions</li> <li>Updates: Follow releases</li> </ul> <p>Need Help?</p> <p>If you encounter any issues not covered in this guide, please: 1. Check the Troubleshooting section above 2. Review the main README 3. Open an issue on GitHub</p> <p>Made with \u2764\ufe0f by Miguel Alejandro - Arcaelas Insiders</p>"},{"location":"advanced/migration/","title":"Migration Guide","text":"<p>This guide helps you migrate to Dynamite from other ORMs or upgrade between versions.</p>"},{"location":"advanced/migration/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Migrating from Other ORMs</li> <li>Version Upgrade Guide</li> <li>Schema Migration</li> <li>Data Migration</li> <li>Testing Migrations</li> <li>Production Deployment</li> </ul>"},{"location":"advanced/migration/#migrating-from-other-orms","title":"Migrating from Other ORMs","text":""},{"location":"advanced/migration/#from-sequelize-sql","title":"From Sequelize (SQL)","text":"<p>Sequelize is designed for relational databases. Here's how to adapt to DynamoDB's NoSQL paradigm.</p> <p>Sequelize Model:</p> <pre><code>// Sequelize (PostgreSQL/MySQL)\nconst User = sequelize.define('User', {\n  id: {\n    type: DataTypes.INTEGER,\n    primaryKey: true,\n    autoIncrement: true\n  },\n  email: {\n    type: DataTypes.STRING,\n    unique: true,\n    allowNull: false\n  },\n  name: DataTypes.STRING,\n  created_at: DataTypes.DATE\n});\n\nconst Order = sequelize.define('Order', {\n  id: {\n    type: DataTypes.INTEGER,\n    primaryKey: true,\n    autoIncrement: true\n  },\n  user_id: {\n    type: DataTypes.INTEGER,\n    references: {\n      model: User,\n      key: 'id'\n    }\n  },\n  total: DataTypes.DECIMAL,\n  status: DataTypes.STRING\n});\n\n// Query\nconst users = await User.findAll({\n  where: {\n    email: { [Op.like]: '%@example.com' }\n  },\n  include: [Order]\n});\n</code></pre> <p>Dynamite Equivalent:</p> <pre><code>// Dynamite (DynamoDB)\n@Entity()\nclass User {\n  @PartitionKey()\n  id!: string; // Use UUID instead of auto-increment\n\n  @Attribute()\n  @Index('EmailIndex', { type: 'PARTITION' })\n  email!: string;\n\n  @Attribute()\n  name!: string;\n\n  @Attribute()\n  created_at!: number; // Unix timestamp\n\n  @HasMany(() =&gt; Order, 'user_id')\n  orders!: Order[];\n}\n\n@Entity()\nclass Order {\n  @PartitionKey()\n  user_id!: string; // Partition by user for efficient queries\n\n  @SortKey()\n  id!: string; // Order ID as sort key\n\n  @Attribute()\n  total!: number;\n\n  @Attribute()\n  status!: string;\n\n  @BelongsTo(() =&gt; User, 'user_id')\n  user!: User;\n}\n\n// Query - different approach for NoSQL\nconst users = await User.find({\n  where: { email: 'user@example.com' }, // Exact match with GSI\n  index: 'EmailIndex',\n  include: ['orders']\n});\n\n// For \"LIKE\" queries, fetch and filter in memory\nconst all_users = await User.scan();\nconst filtered = all_users.filter(u =&gt; u.email.endsWith('@example.com'));\n</code></pre> <p>Key Differences:</p> Concept Sequelize (SQL) Dynamite (DynamoDB) Primary Key Auto-increment integer UUID or composite key Queries Complex WHERE clauses Key conditions + filters Joins Native JOIN support Manual relationship loading Transactions ACID transactions Limited transactions (25 items) Schema Rigid schema Flexible schema <p>Migration Strategy:</p> <pre><code>// 1. Export data from SQL\nimport { Sequelize } from 'sequelize';\n\nasync function ExportFromSQL(): Promise&lt;void&gt; {\n  const sequelize = new Sequelize('postgresql://...');\n  const users = await sequelize.models.User.findAll();\n\n  const export_data = users.map(user =&gt; ({\n    id: `user-${user.id}`, // Transform ID format\n    email: user.email,\n    name: user.name,\n    created_at: user.created_at.getTime()\n  }));\n\n  // Save to file\n  await fs.writeFile(\n    'users_export.json',\n    JSON.stringify(export_data, null, 2)\n  );\n}\n\n// 2. Import to DynamoDB\nasync function ImportToDynamoDB(): Promise&lt;void&gt; {\n  const data = JSON.parse(\n    await fs.readFile('users_export.json', 'utf-8')\n  );\n\n  // Import in batches\n  for (let i = 0; i &lt; data.length; i += 25) {\n    const batch = data.slice(i, i + 25);\n\n    await User.batchWrite(\n      batch.map(item =&gt; ({\n        action: 'put',\n        item\n      }))\n    );\n\n    console.log(`Imported ${Math.min(i + 25, data.length)}/${data.length}`);\n  }\n}\n</code></pre>"},{"location":"advanced/migration/#from-typeorm","title":"From TypeORM","text":"<p>TypeORM supports multiple databases including DynamoDB (basic support).</p> <p>TypeORM Entity:</p> <pre><code>// TypeORM\n@Entity()\nclass User {\n  @PrimaryGeneratedColumn()\n  id!: number;\n\n  @Column({ unique: true })\n  email!: string;\n\n  @Column()\n  name!: string;\n\n  @OneToMany(() =&gt; Order, order =&gt; order.user)\n  orders!: Order[];\n\n  @CreateDateColumn()\n  created_at!: Date;\n\n  @UpdateDateColumn()\n  updated_at!: Date;\n}\n\n@Entity()\nclass Order {\n  @PrimaryGeneratedColumn()\n  id!: number;\n\n  @ManyToOne(() =&gt; User, user =&gt; user.orders)\n  user!: User;\n\n  @Column('decimal')\n  total!: number;\n}\n\n// Query\nconst users = await userRepository.find({\n  where: { name: Like('%John%') },\n  relations: ['orders']\n});\n</code></pre> <p>Dynamite Equivalent:</p> <pre><code>// Dynamite\n@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  @Index('EmailIndex', { type: 'PARTITION' })\n  email!: string;\n\n  @Attribute()\n  name!: string;\n\n  @HasMany(() =&gt; Order, 'user_id')\n  orders!: Order[];\n\n  @Attribute()\n  created_at!: number;\n\n  @Attribute()\n  updated_at!: number;\n}\n\n@Entity()\nclass Order {\n  @PartitionKey()\n  user_id!: string;\n\n  @SortKey()\n  id!: string;\n\n  @Attribute()\n  total!: number;\n\n  @BelongsTo(() =&gt; User, 'user_id')\n  user!: User;\n}\n\n// Query\nconst users = await User.scan({\n  filter: { name: { contains: 'John' } }\n});\n\n// Load relationships\nfor (const user of users) {\n  user.orders = await Order.find({\n    where: { user_id: user.id }\n  });\n}\n</code></pre> <p>Migration Steps:</p> <pre><code>// 1. Create mapping function\nfunction MapTypeORMToDynamite(typeorm_user: any): any {\n  return {\n    id: `user-${typeorm_user.id}`,\n    email: typeorm_user.email,\n    name: typeorm_user.name,\n    created_at: typeorm_user.created_at.getTime(),\n    updated_at: typeorm_user.updated_at.getTime()\n  };\n}\n\n// 2. Migrate with streaming\nasync function MigrateFromTypeORM(): Promise&lt;void&gt; {\n  const typeorm_repo = connection.getRepository(TypeORMUser);\n\n  let page = 0;\n  const page_size = 100;\n\n  while (true) {\n    const users = await typeorm_repo.find({\n      skip: page * page_size,\n      take: page_size\n    });\n\n    if (users.length === 0) break;\n\n    const dynamite_users = users.map(MapTypeORMToDynamite);\n\n    await User.batchWrite(\n      dynamite_users.map(user =&gt; ({\n        action: 'put',\n        item: user\n      }))\n    );\n\n    page++;\n    console.log(`Migrated page ${page}`);\n  }\n}\n</code></pre>"},{"location":"advanced/migration/#from-mongoose-mongodb","title":"From Mongoose (MongoDB)","text":"<p>MongoDB and DynamoDB are both NoSQL, but have different query patterns.</p> <p>Mongoose Schema:</p> <pre><code>// Mongoose (MongoDB)\nconst UserSchema = new mongoose.Schema({\n  email: { type: String, unique: true, required: true },\n  name: String,\n  profile: {\n    bio: String,\n    avatar_url: String\n  },\n  tags: [String],\n  created_at: { type: Date, default: Date.now }\n});\n\nconst User = mongoose.model('User', UserSchema);\n\n// Query\nconst users = await User.find({\n  tags: { $in: ['premium', 'verified'] }\n}).sort({ created_at: -1 });\n</code></pre> <p>Dynamite Equivalent:</p> <pre><code>// Dynamite\n@Entity()\nclass User {\n  @PartitionKey()\n  id!: string; // MongoDB _id \u2192 DynamoDB id\n\n  @Attribute()\n  @Index('EmailIndex', { type: 'PARTITION' })\n  email!: string;\n\n  @Attribute()\n  name!: string;\n\n  @Attribute()\n  profile!: {\n    bio: string;\n    avatar_url: string;\n  };\n\n  @Attribute()\n  tags!: string[];\n\n  @Attribute()\n  created_at!: number;\n}\n\n// Query - use sparse index for tag queries\n@Entity()\nclass User {\n  // ... other fields\n\n  @Attribute()\n  @Index('TagIndex', { type: 'PARTITION' })\n  tag_premium?: string; // Set to 'true' if has premium tag\n\n  @Attribute()\n  @Index('TagIndex', { type: 'SORT' })\n  created_at!: number;\n}\n\nconst users = await User.find({\n  where: {\n    tag_premium: 'true'\n  },\n  index: 'TagIndex',\n  sort: 'desc'\n});\n</code></pre> <p>Migration Script:</p> <pre><code>// Migrate from MongoDB to DynamoDB\nasync function MigrateFromMongoDB(): Promise&lt;void&gt; {\n  const mongo_users = await mongoose.models.User.find().lean();\n\n  const dynamite_users = mongo_users.map(user =&gt; ({\n    id: user._id.toString(),\n    email: user.email,\n    name: user.name,\n    profile: user.profile,\n    tags: user.tags,\n    created_at: user.created_at.getTime(),\n    // Create sparse index attributes\n    tag_premium: user.tags.includes('premium') ? 'true' : undefined,\n    tag_verified: user.tags.includes('verified') ? 'true' : undefined\n  }));\n\n  // Batch write\n  for (let i = 0; i &lt; dynamite_users.length; i += 25) {\n    await User.batchWrite(\n      dynamite_users.slice(i, i + 25).map(user =&gt; ({\n        action: 'put',\n        item: user\n      }))\n    );\n  }\n}\n</code></pre>"},{"location":"advanced/migration/#version-upgrade-guide","title":"Version Upgrade Guide","text":""},{"location":"advanced/migration/#upgrading-to-v20","title":"Upgrading to v2.0","text":"<p>Breaking Changes:</p> <ol> <li>Decorator Syntax Changes</li> </ol> <pre><code>// v1.x\n@Entity({ table_name: 'Users' })\nclass User {\n  @PrimaryKey()\n  id!: string;\n\n  @Column()\n  name!: string;\n}\n\n// v2.x\n@Entity()\nclass User {\n  @PartitionKey() // Renamed from @PrimaryKey\n  id!: string;\n\n  @Attribute() // Renamed from @Column\n  name!: string;\n}\n</code></pre> <ol> <li>Configuration Changes</li> </ol> <pre><code>// v1.x\nDynamite.init({\n  region: 'us-east-1',\n  table_prefix: 'prod_'\n});\n\n// v2.x\nDynamite.Configure({\n  client: new DynamoDBClient({ region: 'us-east-1' }),\n  table_prefix: 'prod_'\n});\n</code></pre> <ol> <li>Query Syntax Changes</li> </ol> <pre><code>// v1.x\nconst users = await User.find({\n  status: 'active'\n});\n\n// v2.x\nconst users = await User.find({\n  where: { status: 'active' }\n});\n</code></pre> <p>Migration Steps:</p> <pre><code># 1. Install new version\nnpm install dynamite@2.0.0\n\n# 2. Run migration script\nnpx dynamite migrate --from=1.x --to=2.x\n\n# 3. Update code with codemod\nnpx dynamite-codemod v1-to-v2 ./src\n</code></pre>"},{"location":"advanced/migration/#upgrading-to-v30","title":"Upgrading to v3.0","text":"<p>Breaking Changes:</p> <ol> <li>Async Configuration</li> </ol> <pre><code>// v2.x\nDynamite.Configure({ client });\n\n// v3.x\nawait Dynamite.Configure({ client });\n</code></pre> <ol> <li>Relationship Loading</li> </ol> <pre><code>// v2.x\nconst user = await User.findOne({\n  where: { id: 'user-123' },\n  include: { orders: true }\n});\n\n// v3.x\nconst user = await User.findOne({\n  where: { id: 'user-123' },\n  include: ['orders']\n});\n</code></pre> <p>Automated Migration:</p> <pre><code>// migration_v2_to_v3.ts\nimport { readdirSync, readFileSync, writeFileSync } from 'fs';\nimport { join } from 'path';\n\nfunction MigrateFile(file_path: string): void {\n  let content = readFileSync(file_path, 'utf-8');\n\n  // Replace sync Configure with async\n  content = content.replace(\n    /Dynamite\\.Configure\\(/g,\n    'await Dynamite.Configure('\n  );\n\n  // Replace include object with array\n  content = content.replace(\n    /include:\\s*{\\s*(\\w+):\\s*true\\s*}/g,\n    \"include: ['$1']\"\n  );\n\n  writeFileSync(file_path, content);\n  console.log(`Migrated: ${file_path}`);\n}\n\n// Run on all TypeScript files\nfunction MigrateDirectory(dir: string): void {\n  for (const file of readdirSync(dir)) {\n    const file_path = join(dir, file);\n\n    if (file.endsWith('.ts')) {\n      MigrateFile(file_path);\n    }\n  }\n}\n\nMigrateDirectory('./src');\n</code></pre>"},{"location":"advanced/migration/#schema-migration","title":"Schema Migration","text":""},{"location":"advanced/migration/#adding-new-attributes","title":"Adding New Attributes","text":"<p>Adding attributes to existing items requires careful planning.</p> <pre><code>// Old schema\n@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  name!: string;\n}\n\n// New schema\n@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  name!: string;\n\n  @Attribute()\n  email?: string; // New optional attribute\n\n  @Attribute()\n  created_at!: number; // New required attribute\n}\n\n// Migration script\nasync function AddAttributes(): Promise&lt;void&gt; {\n  let cursor: any;\n\n  do {\n    const page = await User.scan({ limit: 100, cursor });\n\n    for (const user of page.items) {\n      await User.update(\n        { id: user.id },\n        {\n          email: user.email || `${user.id}@example.com`,\n          created_at: user.created_at || Date.now()\n        }\n      );\n    }\n\n    cursor = page.cursor;\n  } while (cursor);\n}\n</code></pre>"},{"location":"advanced/migration/#creating-new-indexes","title":"Creating New Indexes","text":"<p>Global Secondary Indexes can be added without downtime.</p> <pre><code>// Add GSI to entity\n@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  @Index('EmailIndex', { type: 'PARTITION' }) // New GSI\n  email!: string;\n\n  @Attribute()\n  name!: string;\n}\n\n// Create index using AWS SDK\nimport { UpdateTableCommand } from '@aws-sdk/client-dynamodb';\n\nasync function CreateIndex(): Promise&lt;void&gt; {\n  const client = new DynamoDBClient({ region: 'us-east-1' });\n\n  await client.send(new UpdateTableCommand({\n    TableName: 'Users',\n    AttributeDefinitions: [\n      { AttributeName: 'email', AttributeType: 'S' }\n    ],\n    GlobalSecondaryIndexUpdates: [{\n      Create: {\n        IndexName: 'EmailIndex',\n        KeySchema: [\n          { AttributeName: 'email', KeyType: 'HASH' }\n        ],\n        Projection: { ProjectionType: 'ALL' },\n        ProvisionedThroughput: {\n          ReadCapacityUnits: 5,\n          WriteCapacityUnits: 5\n        }\n      }\n    }]\n  }));\n\n  console.log('Index creation started');\n\n  // Wait for index to be active\n  let status = 'CREATING';\n  while (status === 'CREATING') {\n    await new Promise(resolve =&gt; setTimeout(resolve, 5000));\n\n    const table = await User.describeTable();\n    const index = table.GlobalSecondaryIndexes?.find(\n      i =&gt; i.IndexName === 'EmailIndex'\n    );\n\n    status = index?.IndexStatus || 'CREATING';\n    console.log(`Index status: ${status}`);\n  }\n\n  console.log('Index created successfully');\n}\n</code></pre>"},{"location":"advanced/migration/#renaming-attributes","title":"Renaming Attributes","text":"<p>DynamoDB doesn't support renaming attributes. Create new attribute and copy data.</p> <pre><code>// Migration: name \u2192 full_name\nasync function RenameAttribute(): Promise&lt;void&gt; {\n  let cursor: any;\n  let processed = 0;\n\n  do {\n    const page = await User.scan({ limit: 100, cursor });\n\n    const updates = page.items.map(user =&gt; ({\n      action: 'put' as const,\n      item: {\n        ...user,\n        full_name: user.name, // Copy to new attribute\n        name: undefined // Remove old attribute\n      }\n    }));\n\n    await User.batchWrite(updates);\n\n    processed += page.items.length;\n    cursor = page.cursor;\n\n    console.log(`Processed ${processed} users`);\n  } while (cursor);\n}\n\n// Update entity definition\n@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  full_name!: string; // Renamed from 'name'\n}\n</code></pre>"},{"location":"advanced/migration/#changing-key-schema","title":"Changing Key Schema","text":"<p>Changing partition or sort keys requires creating a new table.</p> <pre><code>// Old schema\n@Entity({ table_name: 'Orders_v1' })\nclass OrderV1 {\n  @PartitionKey()\n  order_id!: string;\n\n  @Attribute()\n  customer_id!: string;\n}\n\n// New schema - optimized for customer queries\n@Entity({ table_name: 'Orders_v2' })\nclass OrderV2 {\n  @PartitionKey()\n  customer_id!: string; // Changed to partition key\n\n  @SortKey()\n  order_id!: string; // Changed to sort key\n}\n\n// Migration script\nasync function MigrateKeySchema(): Promise&lt;void&gt; {\n  // 1. Create new table\n  await OrderV2.createTable();\n\n  // 2. Copy data\n  let cursor: any;\n\n  do {\n    const page = await OrderV1.scan({ limit: 100, cursor });\n\n    await OrderV2.batchWrite(\n      page.items.map(order =&gt; ({\n        action: 'put',\n        item: {\n          customer_id: order.customer_id,\n          order_id: order.order_id,\n          // ... copy other attributes\n        }\n      }))\n    );\n\n    cursor = page.cursor;\n  } while (cursor);\n\n  // 3. Switch application to use new table\n  // 4. Delete old table after verification\n  await OrderV1.deleteTable();\n}\n</code></pre>"},{"location":"advanced/migration/#data-migration","title":"Data Migration","text":""},{"location":"advanced/migration/#export-to-s3","title":"Export to S3","text":"<p>For large datasets, use S3 export.</p> <pre><code>import { ExportTableToPointInTimeCommand } from '@aws-sdk/client-dynamodb';\n\nasync function ExportToS3(): Promise&lt;void&gt; {\n  const client = new DynamoDBClient({ region: 'us-east-1' });\n\n  const export_arn = await client.send(\n    new ExportTableToPointInTimeCommand({\n      TableArn: 'arn:aws:dynamodb:us-east-1:123456789:table/Users',\n      S3Bucket: 'my-exports-bucket',\n      S3Prefix: 'dynamodb-exports/',\n      ExportFormat: 'DYNAMODB_JSON'\n    })\n  );\n\n  console.log('Export started:', export_arn.ExportDescription?.ExportArn);\n}\n</code></pre>"},{"location":"advanced/migration/#transform-data-during-migration","title":"Transform Data During Migration","text":"<p>Apply transformations while migrating.</p> <pre><code>interface TransformFunction&lt;TInput, TOutput&gt; {\n  (input: TInput): TOutput;\n}\n\nasync function MigrateWithTransform&lt;TInput, TOutput&gt;(\n  source_model: typeof Entity,\n  target_model: typeof Entity,\n  transform: TransformFunction&lt;TInput, TOutput&gt;\n): Promise&lt;void&gt; {\n  let cursor: any;\n  let migrated = 0;\n\n  do {\n    const page = await source_model.scan({ limit: 100, cursor });\n\n    const transformed = page.items.map(transform);\n\n    await target_model.batchWrite(\n      transformed.map(item =&gt; ({\n        action: 'put',\n        item\n      }))\n    );\n\n    migrated += transformed.length;\n    cursor = page.cursor;\n\n    console.log(`Migrated ${migrated} items`);\n  } while (cursor);\n}\n\n// Usage\nawait MigrateWithTransform(\n  OldUser,\n  NewUser,\n  (old_user) =&gt; ({\n    id: old_user.id,\n    email: old_user.email.toLowerCase(), // Transform: normalize email\n    name: old_user.first_name + ' ' + old_user.last_name, // Transform: combine names\n    created_at: new Date(old_user.created_at).getTime() // Transform: date to timestamp\n  })\n);\n</code></pre>"},{"location":"advanced/migration/#parallel-migration","title":"Parallel Migration","text":"<p>Speed up migration with parallel processing.</p> <pre><code>async function ParallelMigration(partition_count = 10): Promise&lt;void&gt; {\n  const workers = Array.from({ length: partition_count }, async (_, segment) =&gt; {\n    let cursor: any;\n    let processed = 0;\n\n    do {\n      const page = await User.scan({\n        limit: 100,\n        cursor,\n        segment,\n        total_segments: partition_count\n      });\n\n      // Process items\n      for (const user of page.items) {\n        await ProcessUser(user);\n        processed++;\n      }\n\n      cursor = page.cursor;\n\n      console.log(`Worker ${segment}: processed ${processed}`);\n    } while (cursor);\n  });\n\n  await Promise.all(workers);\n}\n</code></pre>"},{"location":"advanced/migration/#testing-migrations","title":"Testing Migrations","text":""},{"location":"advanced/migration/#test-framework","title":"Test Framework","text":"<p>Create a test framework for migrations.</p> <pre><code>import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\n\nclass MigrationTester {\n  private readonly test_client: DynamoDBClient;\n\n  constructor() {\n    this.test_client = new DynamoDBClient({\n      region: 'local',\n      endpoint: 'http://localhost:8000',\n      credentials: {\n        accessKeyId: 'dummy',\n        secretAccessKey: 'dummy'\n      }\n    });\n  }\n\n  async Setup(): Promise&lt;void&gt; {\n    // Create test tables\n    await User.createTable();\n\n    // Seed test data\n    await this.SeedData();\n  }\n\n  private async SeedData(): Promise&lt;void&gt; {\n    const test_users = Array.from({ length: 100 }, (_, i) =&gt; ({\n      id: `user-${i}`,\n      name: `User ${i}`,\n      email: `user${i}@example.com`\n    }));\n\n    for (let i = 0; i &lt; test_users.length; i += 25) {\n      await User.batchWrite(\n        test_users.slice(i, i + 25).map(user =&gt; ({\n          action: 'put',\n          item: user\n        }))\n      );\n    }\n  }\n\n  async RunMigration(\n    migration_fn: () =&gt; Promise&lt;void&gt;\n  ): Promise&lt;{ success: boolean; duration_ms: number }&gt; {\n    const start = Date.now();\n\n    try {\n      await migration_fn();\n      return { success: true, duration_ms: Date.now() - start };\n    } catch (error) {\n      console.error('Migration failed:', error);\n      return { success: false, duration_ms: Date.now() - start };\n    }\n  }\n\n  async Verify(\n    assertion: () =&gt; Promise&lt;boolean&gt;\n  ): Promise&lt;boolean&gt; {\n    return assertion();\n  }\n\n  async Teardown(): Promise&lt;void&gt; {\n    await User.deleteTable();\n  }\n}\n\n// Usage\nconst tester = new MigrationTester();\n\nawait tester.Setup();\n\nconst result = await tester.RunMigration(async () =&gt; {\n  // Run your migration\n  await AddEmailAttribute();\n});\n\nconst verified = await tester.Verify(async () =&gt; {\n  const users = await User.scan();\n  return users.every(u =&gt; u.email !== undefined);\n});\n\nconsole.log('Migration:', result.success ? 'PASS' : 'FAIL');\nconsole.log('Verification:', verified ? 'PASS' : 'FAIL');\n\nawait tester.Teardown();\n</code></pre>"},{"location":"advanced/migration/#production-deployment","title":"Production Deployment","text":""},{"location":"advanced/migration/#pre-deployment-checklist","title":"Pre-Deployment Checklist","text":"<pre><code>- [ ] Test migration on production-like data\n- [ ] Verify index creation won't impact performance\n- [ ] Prepare rollback plan\n- [ ] Set up monitoring alerts\n- [ ] Schedule during low-traffic window\n- [ ] Communicate with team\n- [ ] Backup critical data\n- [ ] Test in staging environment\n</code></pre>"},{"location":"advanced/migration/#blue-green-deployment","title":"Blue-Green Deployment","text":"<p>Deploy without downtime using blue-green strategy.</p> <pre><code>// 1. Deploy new version (green) alongside old (blue)\n// 2. Route small percentage to green\n// 3. Monitor metrics\n// 4. Gradually increase traffic to green\n// 5. Decommission blue when stable\n\nclass BlueGreenDeployment {\n  private green_percentage = 0;\n\n  async RouteRequest(user_id: string): Promise&lt;'blue' | 'green'&gt; {\n    const hash = this.HashUserId(user_id);\n    return hash &lt; this.green_percentage ? 'green' : 'blue';\n  }\n\n  private HashUserId(user_id: string): number {\n    let hash = 0;\n    for (let i = 0; i &lt; user_id.length; i++) {\n      hash = (hash &lt;&lt; 5) - hash + user_id.charCodeAt(i);\n    }\n    return Math.abs(hash % 100);\n  }\n\n  IncreaseGreenTraffic(percentage: number): void {\n    this.green_percentage = Math.min(100, percentage);\n    console.log(`Green traffic: ${this.green_percentage}%`);\n  }\n}\n</code></pre>"},{"location":"advanced/migration/#rollback-strategy","title":"Rollback Strategy","text":"<p>Always have a rollback plan.</p> <pre><code>class MigrationRollback {\n  private backup_table_name = 'Users_backup';\n\n  async CreateBackup(): Promise&lt;void&gt; {\n    console.log('Creating backup...');\n\n    let cursor: any;\n\n    do {\n      const page = await User.scan({ limit: 100, cursor });\n\n      // Write to backup table\n      await this.WriteToBackup(page.items);\n\n      cursor = page.cursor;\n    } while (cursor);\n\n    console.log('Backup complete');\n  }\n\n  private async WriteToBackup(items: any[]): Promise&lt;void&gt; {\n    // Implementation depends on your backup strategy\n    // Could be: S3, separate DynamoDB table, etc.\n  }\n\n  async Rollback(): Promise&lt;void&gt; {\n    console.log('Rolling back...');\n\n    // Restore from backup\n    // Delete new table\n    // Rename backup to original\n  }\n}\n\n// Usage\nconst rollback = new MigrationRollback();\n\nawait rollback.CreateBackup();\n\ntry {\n  await RunMigration();\n} catch (error) {\n  console.error('Migration failed, rolling back...');\n  await rollback.Rollback();\n}\n</code></pre> <p>For more information: - Performance Guide - Troubleshooting Guide - AWS DynamoDB Documentation</p>"},{"location":"advanced/performance/","title":"Performance Optimization Guide","text":"<p>This guide covers strategies and best practices for optimizing performance when using Dynamite with DynamoDB.</p>"},{"location":"advanced/performance/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Query Optimization</li> <li>Batch Operations</li> <li>Connection Management</li> <li>Attribute Projection</li> <li>Pagination Strategies</li> <li>Caching Patterns</li> <li>Monitoring and Profiling</li> <li>Benchmarking</li> </ul>"},{"location":"advanced/performance/#query-optimization","title":"Query Optimization","text":""},{"location":"advanced/performance/#avoiding-table-scans","title":"Avoiding Table Scans","text":"<p>Table scans are the most expensive operations in DynamoDB. Always use key conditions when possible.</p> <p>Bad - Full table scan:</p> <pre><code>// This scans the entire table\nconst active_users = await User.find({\n  where: { status: 'active' }\n});\n</code></pre> <p>Good - Use partition key:</p> <pre><code>// Use partition key for efficient queries\nconst active_users = await User.find({\n  where: {\n    account_id: '123',\n    status: 'active'\n  }\n});\n</code></pre> <p>Best - Use GSI with proper keys:</p> <pre><code>@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  @Index('StatusIndex', { type: 'PARTITION' })\n  status!: string;\n\n  @Attribute()\n  @Index('StatusIndex', { type: 'SORT' })\n  created_at!: number;\n}\n\n// Now this uses the index efficiently\nconst active_users = await User.find({\n  where: { status: 'active' },\n  index: 'StatusIndex'\n});\n</code></pre>"},{"location":"advanced/performance/#using-composite-keys-efficiently","title":"Using Composite Keys Efficiently","text":"<p>Design your keys to support your most common query patterns.</p> <pre><code>@Entity()\nclass Order {\n  @PartitionKey()\n  customer_id!: string;\n\n  @SortKey()\n  order_date!: string; // Format: YYYY-MM-DD#ORDER_ID\n\n  @Attribute()\n  status!: string;\n\n  @Attribute()\n  total!: number;\n}\n\n// Query orders for a customer in a date range\nconst recent_orders = await Order.find({\n  where: {\n    customer_id: 'CUST-123',\n    order_date: { between: ['2024-01-01', '2024-12-31'] }\n  }\n});\n\n// Query orders for a specific month\nconst monthly_orders = await Order.find({\n  where: {\n    customer_id: 'CUST-123',\n    order_date: { beginsWith: '2024-03' }\n  }\n});\n</code></pre>"},{"location":"advanced/performance/#filter-expressions-vs-key-conditions","title":"Filter Expressions vs Key Conditions","text":"<p>Filter expressions are applied after items are read, so they still consume read capacity.</p> <pre><code>// This reads ALL orders for customer, then filters\nconst expensive_orders = await Order.find({\n  where: {\n    customer_id: 'CUST-123',\n    total: { gt: 1000 }\n  }\n});\n\n// Better: Use sparse index for price ranges\n@Entity()\nclass Order {\n  @PartitionKey()\n  customer_id!: string;\n\n  @SortKey()\n  order_date!: string;\n\n  @Attribute()\n  @Index('HighValueOrders', { type: 'PARTITION' })\n  customer_high_value?: string; // Set to customer_id if total &gt; 1000\n\n  @Attribute()\n  @Index('HighValueOrders', { type: 'SORT' })\n  total!: number;\n}\n\n// Now this uses the sparse index efficiently\nconst expensive_orders = await Order.find({\n  where: {\n    customer_high_value: 'CUST-123',\n    total: { gt: 1000 }\n  },\n  index: 'HighValueOrders'\n});\n</code></pre>"},{"location":"advanced/performance/#query-vs-scan-decision-matrix","title":"Query vs Scan Decision Matrix","text":"Use Case Operation Why Get by primary key <code>findOne()</code> Most efficient, 1 RCU Get by partition key <code>query()</code> Efficient, uses key condition Get by GSI <code>query()</code> with index Efficient if GSI covers query Filter on non-key Consider GSI Avoid if possible Ad-hoc queries <code>scan()</code> Last resort, expensive Analytics Export to S3 Don't scan production"},{"location":"advanced/performance/#batch-operations","title":"Batch Operations","text":""},{"location":"advanced/performance/#batchget-reading-multiple-items","title":"BatchGet - Reading Multiple Items","text":"<p>Read up to 100 items in a single request, consuming fewer RCUs.</p> <pre><code>// Single requests - inefficient\nconst users = await Promise.all([\n  User.findOne({ id: 'user-1' }),\n  User.findOne({ id: 'user-2' }),\n  User.findOne({ id: 'user-3' })\n]);\n\n// Batch request - efficient\nconst user_ids = ['user-1', 'user-2', 'user-3'];\nconst users = await User.batchGet(\n  user_ids.map(id =&gt; ({ id }))\n);\n\n// With type safety\ninterface UserKey {\n  id: string;\n}\n\nconst keys: UserKey[] = [\n  { id: 'user-1' },\n  { id: 'user-2' },\n  { id: 'user-3' }\n];\n\nconst users = await User.batchGet(keys);\n</code></pre>"},{"location":"advanced/performance/#batchwrite-writing-multiple-items","title":"BatchWrite - Writing Multiple Items","text":"<p>Write up to 25 items in a single request.</p> <pre><code>// Create multiple items efficiently\nconst new_users = [\n  { id: 'user-1', name: 'Alice', email: 'alice@example.com' },\n  { id: 'user-2', name: 'Bob', email: 'bob@example.com' },\n  { id: 'user-3', name: 'Charlie', email: 'charlie@example.com' }\n];\n\nawait User.batchWrite(\n  new_users.map(data =&gt; ({\n    action: 'put',\n    item: data\n  }))\n);\n\n// Mix put and delete operations\nawait User.batchWrite([\n  { action: 'put', item: { id: 'user-1', name: 'Alice' } },\n  { action: 'delete', key: { id: 'user-2' } },\n  { action: 'put', item: { id: 'user-3', name: 'Charlie' } }\n]);\n</code></pre>"},{"location":"advanced/performance/#handling-unprocessed-items","title":"Handling Unprocessed Items","text":"<p>Batch operations may return unprocessed items due to throttling.</p> <pre><code>async function BatchWriteWithRetry&lt;T&gt;(\n  model: typeof Entity,\n  items: Array&lt;{ action: 'put' | 'delete'; item?: T; key?: any }&gt;,\n  max_retries = 3\n): Promise&lt;void&gt; {\n  let unprocessed = items;\n  let retry_count = 0;\n\n  while (unprocessed.length &gt; 0 &amp;&amp; retry_count &lt; max_retries) {\n    const response = await model.batchWrite(unprocessed);\n\n    if (!response.unprocessed || response.unprocessed.length === 0) {\n      break;\n    }\n\n    unprocessed = response.unprocessed;\n    retry_count++;\n\n    // Exponential backoff\n    await new Promise(resolve =&gt;\n      setTimeout(resolve, Math.pow(2, retry_count) * 100)\n    );\n  }\n\n  if (unprocessed.length &gt; 0) {\n    throw new Error(`Failed to process ${unprocessed.length} items`);\n  }\n}\n</code></pre>"},{"location":"advanced/performance/#chunking-large-batches","title":"Chunking Large Batches","text":"<p>Split large datasets into appropriate batch sizes.</p> <pre><code>function* ChunkArray&lt;T&gt;(array: T[], chunk_size: number): Generator&lt;T[]&gt; {\n  for (let i = 0; i &lt; array.length; i += chunk_size) {\n    yield array.slice(i, i + chunk_size);\n  }\n}\n\nasync function BatchGetAll&lt;T&gt;(\n  model: typeof Entity,\n  keys: any[]\n): Promise&lt;T[]&gt; {\n  const results: T[] = [];\n\n  for (const chunk of ChunkArray(keys, 100)) {\n    const batch_results = await model.batchGet(chunk);\n    results.push(...batch_results);\n  }\n\n  return results;\n}\n\n// Usage\nconst all_user_ids = Array.from({ length: 500 }, (_, i) =&gt; ({\n  id: `user-${i}`\n}));\n\nconst all_users = await BatchGetAll(User, all_user_ids);\n</code></pre>"},{"location":"advanced/performance/#connection-management","title":"Connection Management","text":""},{"location":"advanced/performance/#client-reuse","title":"Client Reuse","text":"<p>Always reuse DynamoDB client instances to avoid connection overhead.</p> <pre><code>// Bad - Creates new client per request\nclass UserService {\n  async GetUser(id: string): Promise&lt;User | null&gt; {\n    const client = new DynamoDBClient({ region: 'us-east-1' });\n    // ... operations\n    return user;\n  }\n}\n\n// Good - Reuses client\nclass UserService {\n  private readonly client: DynamoDBClient;\n\n  constructor() {\n    this.client = new DynamoDBClient({\n      region: 'us-east-1',\n      maxAttempts: 3\n    });\n  }\n\n  async GetUser(id: string): Promise&lt;User | null&gt; {\n    // ... operations using this.client\n    return user;\n  }\n}\n</code></pre>"},{"location":"advanced/performance/#connection-pooling","title":"Connection Pooling","text":"<p>Configure connection pooling for high-throughput applications.</p> <pre><code>import { NodeHttpHandler } from '@aws-sdk/node-http-handler';\nimport { Agent } from 'https';\n\nconst https_agent = new Agent({\n  keepAlive: true,\n  maxSockets: 50,\n  keepAliveMsecs: 1000\n});\n\nconst client = new DynamoDBClient({\n  region: 'us-east-1',\n  requestHandler: new NodeHttpHandler({\n    httpsAgent: https_agent,\n    connectionTimeout: 5000,\n    requestTimeout: 10000\n  })\n});\n\nDynamite.Configure({ client });\n</code></pre>"},{"location":"advanced/performance/#timeout-configuration","title":"Timeout Configuration","text":"<p>Set appropriate timeouts based on your use case.</p> <pre><code>// Fast queries - short timeout\nconst client_fast = new DynamoDBClient({\n  region: 'us-east-1',\n  requestHandler: new NodeHttpHandler({\n    connectionTimeout: 1000,\n    requestTimeout: 3000\n  })\n});\n\n// Batch operations - longer timeout\nconst client_batch = new DynamoDBClient({\n  region: 'us-east-1',\n  requestHandler: new NodeHttpHandler({\n    connectionTimeout: 5000,\n    requestTimeout: 30000\n  })\n});\n</code></pre>"},{"location":"advanced/performance/#attribute-projection","title":"Attribute Projection","text":""},{"location":"advanced/performance/#reducing-bandwidth","title":"Reducing Bandwidth","text":"<p>Only retrieve the attributes you need to reduce response size and costs.</p> <pre><code>// Retrieves all attributes\nconst user = await User.findOne({\n  where: { id: 'user-123' }\n});\n\n// Only retrieves specific attributes\nconst user = await User.findOne({\n  where: { id: 'user-123' },\n  select: ['id', 'name', 'email']\n});\n\n// Calculate bandwidth savings\n// Full item: ~2KB (all attributes)\n// Projected item: ~200 bytes (3 attributes)\n// Savings: 90% bandwidth reduction\n</code></pre>"},{"location":"advanced/performance/#nested-attribute-projection","title":"Nested Attribute Projection","text":"<p>Use dot notation for nested attributes.</p> <pre><code>@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  profile!: {\n    name: string;\n    email: string;\n    address: {\n      street: string;\n      city: string;\n      country: string;\n    };\n  };\n\n  @Attribute()\n  metadata!: Record&lt;string, any&gt;;\n}\n\n// Only get specific nested attributes\nconst user = await User.findOne({\n  where: { id: 'user-123' },\n  select: ['id', 'profile.name', 'profile.address.city']\n});\n\n// Result: { id: 'user-123', profile: { name: '...', address: { city: '...' } } }\n</code></pre>"},{"location":"advanced/performance/#index-projections","title":"Index Projections","text":"<p>Configure GSI projections to optimize query performance.</p> <pre><code>@Entity()\nclass Product {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  @Index('CategoryIndex', {\n    type: 'PARTITION',\n    projection: ['id', 'name', 'price'] // Only project needed attributes\n  })\n  category!: string;\n\n  @Attribute()\n  name!: string;\n\n  @Attribute()\n  price!: number;\n\n  @Attribute()\n  description!: string; // Not projected to index\n\n  @Attribute()\n  specifications!: Record&lt;string, any&gt;; // Not projected\n}\n\n// Query uses index projection - efficient\nconst products = await Product.find({\n  where: { category: 'electronics' },\n  index: 'CategoryIndex',\n  select: ['id', 'name', 'price']\n});\n\n// Query requires base table fetch - inefficient\nconst products = await Product.find({\n  where: { category: 'electronics' },\n  index: 'CategoryIndex',\n  select: ['description'] // Not in projection\n});\n</code></pre>"},{"location":"advanced/performance/#pagination-strategies","title":"Pagination Strategies","text":""},{"location":"advanced/performance/#cursor-based-pagination","title":"Cursor-Based Pagination","text":"<p>Use LastEvaluatedKey for efficient pagination.</p> <pre><code>interface PaginationResult&lt;T&gt; {\n  items: T[];\n  next_cursor?: string;\n  has_more: boolean;\n}\n\nasync function PaginatedQuery&lt;T&gt;(\n  model: typeof Entity,\n  where: any,\n  cursor?: string,\n  limit = 20\n): Promise&lt;PaginationResult&lt;T&gt;&gt; {\n  const result = await model.find({\n    where,\n    limit,\n    cursor: cursor ? JSON.parse(Buffer.from(cursor, 'base64').toString()) : undefined\n  });\n\n  const next_cursor = result.cursor\n    ? Buffer.from(JSON.stringify(result.cursor)).toString('base64')\n    : undefined;\n\n  return {\n    items: result.items,\n    next_cursor,\n    has_more: !!result.cursor\n  };\n}\n\n// Usage\nlet cursor: string | undefined;\nlet all_items: User[] = [];\n\ndo {\n  const page = await PaginatedQuery&lt;User&gt;(\n    User,\n    { status: 'active' },\n    cursor,\n    100\n  );\n\n  all_items.push(...page.items);\n  cursor = page.next_cursor;\n} while (cursor);\n</code></pre>"},{"location":"advanced/performance/#parallel-pagination","title":"Parallel Pagination","text":"<p>Paginate multiple queries in parallel for faster processing.</p> <pre><code>async function ParallelPagination&lt;T&gt;(\n  queries: Array&lt;{ model: typeof Entity; where: any }&gt;,\n  page_size = 50\n): Promise&lt;T[]&gt; {\n  const results = await Promise.all(\n    queries.map(async ({ model, where }) =&gt; {\n      const items: T[] = [];\n      let cursor: any;\n\n      do {\n        const page = await model.find({\n          where,\n          limit: page_size,\n          cursor\n        });\n\n        items.push(...page.items);\n        cursor = page.cursor;\n      } while (cursor);\n\n      return items;\n    })\n  );\n\n  return results.flat();\n}\n\n// Query multiple partitions simultaneously\nconst all_orders = await ParallelPagination([\n  { model: Order, where: { customer_id: 'CUST-1' } },\n  { model: Order, where: { customer_id: 'CUST-2' } },\n  { model: Order, where: { customer_id: 'CUST-3' } }\n]);\n</code></pre>"},{"location":"advanced/performance/#infinite-scroll-implementation","title":"Infinite Scroll Implementation","text":"<p>Implement infinite scroll with proper state management.</p> <pre><code>class InfiniteScroll&lt;T&gt; {\n  private items: T[] = [];\n  private cursor?: any;\n  private is_loading = false;\n  private has_more = true;\n\n  constructor(\n    private readonly model: typeof Entity,\n    private readonly where: any,\n    private readonly page_size = 20\n  ) {}\n\n  async LoadMore(): Promise&lt;T[]&gt; {\n    if (this.is_loading || !this.has_more) {\n      return [];\n    }\n\n    this.is_loading = true;\n\n    try {\n      const result = await this.model.find({\n        where: this.where,\n        limit: this.page_size,\n        cursor: this.cursor\n      });\n\n      this.items.push(...result.items);\n      this.cursor = result.cursor;\n      this.has_more = !!result.cursor;\n\n      return result.items;\n    } finally {\n      this.is_loading = false;\n    }\n  }\n\n  GetItems(): T[] {\n    return this.items;\n  }\n\n  HasMore(): boolean {\n    return this.has_more;\n  }\n\n  Reset(): void {\n    this.items = [];\n    this.cursor = undefined;\n    this.has_more = true;\n  }\n}\n\n// Usage\nconst scroll = new InfiniteScroll(User, { status: 'active' }, 50);\n\n// Load first page\nawait scroll.LoadMore();\n\n// User scrolls down\nawait scroll.LoadMore();\n\n// Check if more data available\nif (scroll.HasMore()) {\n  await scroll.LoadMore();\n}\n</code></pre>"},{"location":"advanced/performance/#caching-patterns","title":"Caching Patterns","text":""},{"location":"advanced/performance/#in-memory-caching","title":"In-Memory Caching","text":"<p>Implement simple in-memory cache for frequently accessed data.</p> <pre><code>class CachedRepository&lt;T&gt; {\n  private cache = new Map&lt;string, { data: T; expires_at: number }&gt;();\n\n  constructor(\n    private readonly model: typeof Entity,\n    private readonly ttl_ms = 60000 // 1 minute\n  ) {}\n\n  async FindOne(key: any): Promise&lt;T | null&gt; {\n    const cache_key = JSON.stringify(key);\n    const cached = this.cache.get(cache_key);\n\n    if (cached &amp;&amp; cached.expires_at &gt; Date.now()) {\n      return cached.data;\n    }\n\n    const item = await this.model.findOne({ where: key });\n\n    if (item) {\n      this.cache.set(cache_key, {\n        data: item,\n        expires_at: Date.now() + this.ttl_ms\n      });\n    }\n\n    return item;\n  }\n\n  InvalidateCache(key: any): void {\n    const cache_key = JSON.stringify(key);\n    this.cache.delete(cache_key);\n  }\n\n  ClearCache(): void {\n    this.cache.clear();\n  }\n}\n\n// Usage\nconst user_cache = new CachedRepository(User, 300000); // 5 minutes\n\nconst user = await user_cache.FindOne({ id: 'user-123' });\n</code></pre>"},{"location":"advanced/performance/#redis-caching","title":"Redis Caching","text":"<p>Use Redis for distributed caching across multiple instances.</p> <pre><code>import { createClient } from 'redis';\n\nclass RedisCache&lt;T&gt; {\n  private client = createClient({ url: 'redis://localhost:6379' });\n\n  constructor(\n    private readonly model: typeof Entity,\n    private readonly ttl_seconds = 300\n  ) {\n    this.client.connect();\n  }\n\n  async FindOne(key: any): Promise&lt;T | null&gt; {\n    const cache_key = `${this.model.name}:${JSON.stringify(key)}`;\n    const cached = await this.client.get(cache_key);\n\n    if (cached) {\n      return JSON.parse(cached);\n    }\n\n    const item = await this.model.findOne({ where: key });\n\n    if (item) {\n      await this.client.setEx(\n        cache_key,\n        this.ttl_seconds,\n        JSON.stringify(item)\n      );\n    }\n\n    return item;\n  }\n\n  async Invalidate(key: any): Promise&lt;void&gt; {\n    const cache_key = `${this.model.name}:${JSON.stringify(key)}`;\n    await this.client.del(cache_key);\n  }\n}\n</code></pre>"},{"location":"advanced/performance/#write-through-caching","title":"Write-Through Caching","text":"<p>Update cache on write operations.</p> <pre><code>class WriteThroughCache&lt;T&gt; {\n  private cache = new Map&lt;string, T&gt;();\n\n  constructor(private readonly model: typeof Entity) {}\n\n  async FindOne(key: any): Promise&lt;T | null&gt; {\n    const cache_key = JSON.stringify(key);\n    const cached = this.cache.get(cache_key);\n\n    if (cached) {\n      return cached;\n    }\n\n    const item = await this.model.findOne({ where: key });\n\n    if (item) {\n      this.cache.set(cache_key, item);\n    }\n\n    return item;\n  }\n\n  async Create(data: Partial&lt;T&gt;): Promise&lt;T&gt; {\n    const item = await this.model.create(data);\n    const cache_key = JSON.stringify({ id: (item as any).id });\n    this.cache.set(cache_key, item);\n    return item;\n  }\n\n  async Update(key: any, data: Partial&lt;T&gt;): Promise&lt;T&gt; {\n    const item = await this.model.update(key, data);\n    const cache_key = JSON.stringify(key);\n    this.cache.set(cache_key, item);\n    return item;\n  }\n\n  async Delete(key: any): Promise&lt;void&gt; {\n    await this.model.delete(key);\n    const cache_key = JSON.stringify(key);\n    this.cache.delete(cache_key);\n  }\n}\n</code></pre>"},{"location":"advanced/performance/#monitoring-and-profiling","title":"Monitoring and Profiling","text":""},{"location":"advanced/performance/#cloudwatch-metrics","title":"CloudWatch Metrics","text":"<p>Monitor DynamoDB performance using CloudWatch.</p> <pre><code>import { CloudWatchClient, PutMetricDataCommand } from '@aws-sdk/client-cloudwatch';\n\nclass PerformanceMonitor {\n  private readonly cloudwatch = new CloudWatchClient({ region: 'us-east-1' });\n\n  async TrackQuery(operation: string, duration_ms: number): Promise&lt;void&gt; {\n    await this.cloudwatch.send(new PutMetricDataCommand({\n      Namespace: 'DynamoDB/Queries',\n      MetricData: [{\n        MetricName: 'QueryDuration',\n        Value: duration_ms,\n        Unit: 'Milliseconds',\n        Dimensions: [\n          { Name: 'Operation', Value: operation }\n        ]\n      }]\n    }));\n  }\n\n  async WithMonitoring&lt;T&gt;(\n    operation: string,\n    fn: () =&gt; Promise&lt;T&gt;\n  ): Promise&lt;T&gt; {\n    const start = Date.now();\n\n    try {\n      const result = await fn();\n      await this.TrackQuery(operation, Date.now() - start);\n      return result;\n    } catch (error) {\n      await this.TrackQuery(`${operation}_error`, Date.now() - start);\n      throw error;\n    }\n  }\n}\n\n// Usage\nconst monitor = new PerformanceMonitor();\n\nconst user = await monitor.WithMonitoring(\n  'User.findOne',\n  () =&gt; User.findOne({ where: { id: 'user-123' } })\n);\n</code></pre>"},{"location":"advanced/performance/#custom-profiling","title":"Custom Profiling","text":"<p>Profile query performance in development.</p> <pre><code>class QueryProfiler {\n  private metrics: Array&lt;{\n    operation: string;\n    duration_ms: number;\n    timestamp: number;\n  }&gt; = [];\n\n  async Profile&lt;T&gt;(operation: string, fn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {\n    const start = performance.now();\n    const result = await fn();\n    const duration_ms = performance.now() - start;\n\n    this.metrics.push({\n      operation,\n      duration_ms,\n      timestamp: Date.now()\n    });\n\n    console.log(`[${operation}] ${duration_ms.toFixed(2)}ms`);\n\n    return result;\n  }\n\n  GetMetrics() {\n    return {\n      total: this.metrics.length,\n      avg_duration: this.metrics.reduce((sum, m) =&gt; sum + m.duration_ms, 0) / this.metrics.length,\n      slowest: this.metrics.sort((a, b) =&gt; b.duration_ms - a.duration_ms)[0],\n      by_operation: this.GroupByOperation()\n    };\n  }\n\n  private GroupByOperation() {\n    const groups = new Map&lt;string, number[]&gt;();\n\n    for (const metric of this.metrics) {\n      if (!groups.has(metric.operation)) {\n        groups.set(metric.operation, []);\n      }\n      groups.get(metric.operation)!.push(metric.duration_ms);\n    }\n\n    return Object.fromEntries(\n      Array.from(groups.entries()).map(([op, durations]) =&gt; [\n        op,\n        {\n          count: durations.length,\n          avg: durations.reduce((a, b) =&gt; a + b) / durations.length,\n          min: Math.min(...durations),\n          max: Math.max(...durations)\n        }\n      ])\n    );\n  }\n}\n\n// Usage\nconst profiler = new QueryProfiler();\n\nawait profiler.Profile('GetUser', () =&gt;\n  User.findOne({ where: { id: 'user-123' } })\n);\n\nconsole.log(profiler.GetMetrics());\n</code></pre>"},{"location":"advanced/performance/#benchmarking","title":"Benchmarking","text":""},{"location":"advanced/performance/#simple-benchmark","title":"Simple Benchmark","text":"<p>Compare different query strategies.</p> <pre><code>async function Benchmark(\n  name: string,\n  fn: () =&gt; Promise&lt;void&gt;,\n  iterations = 100\n): Promise&lt;void&gt; {\n  const durations: number[] = [];\n\n  for (let i = 0; i &lt; iterations; i++) {\n    const start = performance.now();\n    await fn();\n    durations.push(performance.now() - start);\n  }\n\n  const avg = durations.reduce((a, b) =&gt; a + b) / durations.length;\n  const min = Math.min(...durations);\n  const max = Math.max(...durations);\n\n  console.log(`\\n${name}:`);\n  console.log(`  Iterations: ${iterations}`);\n  console.log(`  Average: ${avg.toFixed(2)}ms`);\n  console.log(`  Min: ${min.toFixed(2)}ms`);\n  console.log(`  Max: ${max.toFixed(2)}ms`);\n}\n\n// Compare single vs batch operations\nawait Benchmark('Single Gets', async () =&gt; {\n  await Promise.all([\n    User.findOne({ where: { id: 'user-1' } }),\n    User.findOne({ where: { id: 'user-2' } }),\n    User.findOne({ where: { id: 'user-3' } })\n  ]);\n}, 100);\n\nawait Benchmark('Batch Get', async () =&gt; {\n  await User.batchGet([\n    { id: 'user-1' },\n    { id: 'user-2' },\n    { id: 'user-3' }\n  ]);\n}, 100);\n</code></pre>"},{"location":"advanced/performance/#load-testing","title":"Load Testing","text":"<p>Test performance under load.</p> <pre><code>async function LoadTest(\n  name: string,\n  fn: () =&gt; Promise&lt;void&gt;,\n  concurrent_requests = 100,\n  duration_seconds = 10\n): Promise&lt;void&gt; {\n  const start_time = Date.now();\n  const end_time = start_time + duration_seconds * 1000;\n  let completed = 0;\n  let errors = 0;\n\n  const workers = Array.from({ length: concurrent_requests }, async () =&gt; {\n    while (Date.now() &lt; end_time) {\n      try {\n        await fn();\n        completed++;\n      } catch (error) {\n        errors++;\n      }\n    }\n  });\n\n  await Promise.all(workers);\n\n  const duration = (Date.now() - start_time) / 1000;\n  const rps = completed / duration;\n\n  console.log(`\\n${name}:`);\n  console.log(`  Duration: ${duration.toFixed(2)}s`);\n  console.log(`  Completed: ${completed}`);\n  console.log(`  Errors: ${errors}`);\n  console.log(`  RPS: ${rps.toFixed(2)}`);\n}\n\n// Test read throughput\nawait LoadTest('Read Load Test', async () =&gt; {\n  await User.findOne({ where: { id: 'user-123' } });\n}, 50, 10);\n</code></pre> <p>For more information, see: - AWS DynamoDB Best Practices - Troubleshooting Guide - Migration Guide</p>"},{"location":"advanced/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you diagnose and resolve common issues when using Dynamite with DynamoDB.</p>"},{"location":"advanced/troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Connection Errors</li> <li>Query Errors</li> <li>Validation Errors</li> <li>Relationship Errors</li> <li>Performance Issues</li> <li>Type Errors</li> <li>Debugging Tips</li> <li>Common Error Messages</li> </ul>"},{"location":"advanced/troubleshooting/#connection-errors","title":"Connection Errors","text":""},{"location":"advanced/troubleshooting/#invalid-credentials","title":"Invalid Credentials","text":"<p>Error: <pre><code>UnrecognizedClientException: The security token included in the request is invalid\n</code></pre></p> <p>Causes: - Invalid AWS credentials - Expired credentials - Wrong IAM permissions</p> <p>Solutions:</p> <pre><code>// Check credentials are properly configured\nimport { fromEnv } from '@aws-sdk/credential-providers';\n\nconst client = new DynamoDBClient({\n  region: 'us-east-1',\n  credentials: fromEnv()\n});\n\n// Verify environment variables\nconsole.log('AWS_ACCESS_KEY_ID:', process.env.AWS_ACCESS_KEY_ID ? 'Set' : 'Not set');\nconsole.log('AWS_SECRET_ACCESS_KEY:', process.env.AWS_SECRET_ACCESS_KEY ? 'Set' : 'Not set');\n\n// Test connection\ntry {\n  await client.send(new ListTablesCommand({}));\n  console.log('Connection successful');\n} catch (error) {\n  console.error('Connection failed:', error.message);\n}\n</code></pre> <p>IAM Policy Required:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"dynamodb:GetItem\",\n        \"dynamodb:PutItem\",\n        \"dynamodb:UpdateItem\",\n        \"dynamodb:DeleteItem\",\n        \"dynamodb:Query\",\n        \"dynamodb:Scan\",\n        \"dynamodb:BatchGetItem\",\n        \"dynamodb:BatchWriteItem\"\n      ],\n      \"Resource\": \"arn:aws:dynamodb:*:*:table/*\"\n    }\n  ]\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#wrong-region","title":"Wrong Region","text":"<p>Error: <pre><code>ResourceNotFoundException: Requested resource not found\n</code></pre></p> <p>Causes: - Table exists in different region - Incorrect region configuration</p> <p>Solutions:</p> <pre><code>// List all regions where table exists\nimport { DynamoDBClient, ListTablesCommand } from '@aws-sdk/client-dynamodb';\n\nconst regions = [\n  'us-east-1',\n  'us-west-2',\n  'eu-west-1',\n  'ap-southeast-1'\n];\n\nfor (const region of regions) {\n  try {\n    const client = new DynamoDBClient({ region });\n    const { TableNames } = await client.send(new ListTablesCommand({}));\n\n    if (TableNames?.includes('Users')) {\n      console.log(`Table found in region: ${region}`);\n    }\n  } catch (error) {\n    console.log(`Region ${region}: ${error.message}`);\n  }\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#connection-timeout","title":"Connection Timeout","text":"<p>Error: <pre><code>TimeoutError: Connection timeout after 5000ms\n</code></pre></p> <p>Causes: - Network issues - VPC configuration problems - DynamoDB endpoint not accessible</p> <p>Solutions:</p> <pre><code>// Increase timeout for slow connections\nimport { NodeHttpHandler } from '@aws-sdk/node-http-handler';\n\nconst client = new DynamoDBClient({\n  region: 'us-east-1',\n  requestHandler: new NodeHttpHandler({\n    connectionTimeout: 10000, // 10 seconds\n    requestTimeout: 30000 // 30 seconds\n  })\n});\n\n// Use VPC endpoint if within VPC\nconst client_vpc = new DynamoDBClient({\n  region: 'us-east-1',\n  endpoint: 'https://vpce-abc123.dynamodb.us-east-1.vpce.amazonaws.com'\n});\n\n// Test with retries\nconst client_with_retries = new DynamoDBClient({\n  region: 'us-east-1',\n  maxAttempts: 5,\n  retryMode: 'adaptive'\n});\n</code></pre>"},{"location":"advanced/troubleshooting/#local-dynamodb-connection","title":"Local DynamoDB Connection","text":"<p>Error: <pre><code>NetworkingError: connect ECONNREFUSED 127.0.0.1:8000\n</code></pre></p> <p>Causes: - DynamoDB Local not running - Wrong port configuration</p> <p>Solutions:</p> <pre><code># Start DynamoDB Local\ndocker run -p 8000:8000 amazon/dynamodb-local\n\n# Or using Java\njava -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb\n</code></pre> <pre><code>// Configure client for local DynamoDB\nconst local_client = new DynamoDBClient({\n  region: 'local',\n  endpoint: 'http://localhost:8000',\n  credentials: {\n    accessKeyId: 'dummy',\n    secretAccessKey: 'dummy'\n  }\n});\n\nDynamite.Configure({ client: local_client });\n\n// Verify connection\ntry {\n  await local_client.send(new ListTablesCommand({}));\n  console.log('Local DynamoDB connected');\n} catch (error) {\n  console.error('Cannot connect to local DynamoDB:', error.message);\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#query-errors","title":"Query Errors","text":""},{"location":"advanced/troubleshooting/#invalid-query-operator","title":"Invalid Query Operator","text":"<p>Error: <pre><code>ValidationException: Query key condition not supported\n</code></pre></p> <p>Causes: - Using wrong operator for key condition - Filter on partition key with unsupported operator</p> <p>Solutions:</p> <pre><code>// Wrong - 'contains' not supported for partition key\nconst users = await User.find({\n  where: {\n    email: { contains: '@example.com' } // Error!\n  }\n});\n\n// Correct - Use 'eq' or direct value for partition key\nconst user = await User.findOne({\n  where: {\n    email: 'user@example.com'\n  }\n});\n\n// Wrong - Multiple conditions on partition key\nconst users = await User.find({\n  where: {\n    id: { gt: 'user-100', lt: 'user-200' } // Error!\n  }\n});\n\n// Correct - Range conditions only for sort key\nconst orders = await Order.find({\n  where: {\n    customer_id: 'CUST-123', // Partition key - exact match\n    order_date: { between: ['2024-01-01', '2024-12-31'] } // Sort key - range\n  }\n});\n</code></pre> <p>Supported Operators by Key Type:</p> Key Type Supported Operators Partition Key <code>=</code> (exact match only) Sort Key <code>=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>between</code>, <code>beginsWith</code> Non-Key Attributes All operators (via filter expression)"},{"location":"advanced/troubleshooting/#missing-index","title":"Missing Index","text":"<p>Error: <pre><code>ValidationException: Query condition missed key schema element\n</code></pre></p> <p>Causes: - Querying on non-key attribute without index - Wrong index name specified</p> <p>Solutions:</p> <pre><code>// Wrong - Querying non-key attribute\nconst users = await User.find({\n  where: {\n    status: 'active' // No index on status\n  }\n});\n\n// Correct - Add GSI\n@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  @Index('StatusIndex', { type: 'PARTITION' })\n  status!: string;\n}\n\n// Now query with index\nconst users = await User.find({\n  where: { status: 'active' },\n  index: 'StatusIndex'\n});\n\n// Check available indexes\nconst table_info = await User.describeTable();\nconsole.log('Available indexes:', table_info.GlobalSecondaryIndexes?.map(i =&gt; i.IndexName));\n</code></pre>"},{"location":"advanced/troubleshooting/#empty-result-set","title":"Empty Result Set","text":"<p>Error: No error, but results are empty when data exists.</p> <p>Causes: - Wrong key values - Case sensitivity issues - Data type mismatch</p> <p>Solutions:</p> <pre><code>// Debug query\nconst result = await User.find({\n  where: { status: 'Active' } // Check case\n});\n\nconsole.log('Query returned:', result.items.length, 'items');\n\n// Check actual data\nconst all_users = await User.scan();\nconsole.log('Statuses in DB:', [...new Set(all_users.map(u =&gt; u.status))]);\n\n// Use scan to verify data exists\nconst scan_result = await User.scan({\n  filter: { status: 'active' }\n});\n\nif (scan_result.length &gt; 0) {\n  console.log('Data exists, query might be wrong');\n  console.log('Sample item:', scan_result[0]);\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#inconsistent-reads","title":"Inconsistent Reads","text":"<p>Error: Data just written is not returned by query.</p> <p>Causes: - Eventually consistent reads (default) - Reading from GSI (always eventually consistent)</p> <p>Solutions:</p> <pre><code>// Force strongly consistent read\nconst user = await User.findOne({\n  where: { id: 'user-123' },\n  consistent: true\n});\n\n// Wait for GSI to update\nawait User.create({ id: 'user-123', status: 'active' });\n\n// GSI might not be updated immediately\nawait new Promise(resolve =&gt; setTimeout(resolve, 1000));\n\nconst users = await User.find({\n  where: { status: 'active' },\n  index: 'StatusIndex'\n});\n</code></pre>"},{"location":"advanced/troubleshooting/#validation-errors","title":"Validation Errors","text":""},{"location":"advanced/troubleshooting/#decorator-validation-failed","title":"Decorator Validation Failed","text":"<p>Error: <pre><code>ValidationError: Attribute 'email' does not match pattern\n</code></pre></p> <p>Causes: - Input doesn't match decorator validation rules - Missing required attributes</p> <p>Solutions:</p> <pre><code>@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute({\n    validate: {\n      pattern: /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}$/i,\n      message: 'Invalid email format'\n    }\n  })\n  email!: string;\n\n  @Attribute({\n    validate: {\n      min: 18,\n      max: 100,\n      message: 'Age must be between 18 and 100'\n    }\n  })\n  age!: number;\n}\n\n// Validate before saving\ntry {\n  const user = await User.create({\n    id: 'user-123',\n    email: 'invalid-email', // Will fail\n    age: 15 // Will fail\n  });\n} catch (error) {\n  console.error('Validation errors:', error.message);\n}\n\n// Manual validation\nfunction ValidateEmail(email: string): boolean {\n  return /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}$/i.test(email);\n}\n\nif (!ValidateEmail('test@example.com')) {\n  throw new Error('Invalid email');\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#type-mismatch","title":"Type Mismatch","text":"<p>Error: <pre><code>TypeError: Cannot convert 'name' to string\n</code></pre></p> <p>Causes: - Wrong data type for attribute - Missing type conversion</p> <p>Solutions:</p> <pre><code>@Entity()\nclass Product {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  price!: number; // Expects number\n\n  @Attribute()\n  tags!: string[]; // Expects string array\n\n  @Attribute()\n  metadata!: Record&lt;string, any&gt;; // Expects object\n}\n\n// Wrong types\nawait Product.create({\n  id: 'prod-123',\n  price: '29.99', // Wrong: string instead of number\n  tags: 'electronics,gadgets', // Wrong: string instead of array\n  metadata: '[{\"key\": \"value\"}]' // Wrong: JSON string instead of object\n});\n\n// Correct types\nawait Product.create({\n  id: 'prod-123',\n  price: 29.99,\n  tags: ['electronics', 'gadgets'],\n  metadata: { key: 'value' }\n});\n\n// With type conversion\nawait Product.create({\n  id: 'prod-123',\n  price: parseFloat('29.99'),\n  tags: 'electronics,gadgets'.split(','),\n  metadata: JSON.parse('[{\"key\": \"value\"}]')\n});\n</code></pre>"},{"location":"advanced/troubleshooting/#required-attribute-missing","title":"Required Attribute Missing","text":"<p>Error: <pre><code>ValidationError: Missing required attribute 'name'\n</code></pre></p> <p>Causes: - Required attribute not provided - Undefined or null value for required field</p> <p>Solutions:</p> <pre><code>@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute({ required: true })\n  name!: string;\n\n  @Attribute({ required: false })\n  nickname?: string;\n}\n\n// Wrong - missing required attribute\nawait User.create({\n  id: 'user-123'\n  // Missing 'name'\n});\n\n// Correct - all required attributes provided\nawait User.create({\n  id: 'user-123',\n  name: 'John Doe'\n});\n\n// Provide defaults for required fields\ninterface CreateUserInput {\n  id: string;\n  name?: string;\n}\n\nasync function CreateUserWithDefaults(input: CreateUserInput): Promise&lt;User&gt; {\n  return User.create({\n    id: input.id,\n    name: input.name ?? 'Anonymous'\n  });\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#relationship-errors","title":"Relationship Errors","text":""},{"location":"advanced/troubleshooting/#circular-dependency","title":"Circular Dependency","text":"<p>Error: <pre><code>ReferenceError: Cannot access 'Order' before initialization\n</code></pre></p> <p>Causes: - Circular imports between entity files - Bidirectional relationships</p> <p>Solutions:</p> <pre><code>// Wrong - circular dependency\n// user.entity.ts\nimport { Order } from './order.entity';\n\n@Entity()\nclass User {\n  @HasMany(() =&gt; Order, 'user_id')\n  orders!: Order[];\n}\n\n// order.entity.ts\nimport { User } from './user.entity';\n\n@Entity()\nclass Order {\n  @BelongsTo(() =&gt; User, 'user_id')\n  user!: User;\n}\n\n// Correct - use function for lazy evaluation\n// user.entity.ts\n@Entity()\nexport class User {\n  @HasMany(() =&gt; require('./order.entity').Order, 'user_id')\n  orders!: any[];\n}\n\n// order.entity.ts\n@Entity()\nexport class Order {\n  @BelongsTo(() =&gt; require('./user.entity').User, 'user_id')\n  user!: any;\n}\n\n// Best - separate relationship definitions\n// relationships.ts\nimport { User } from './user.entity';\nimport { Order } from './order.entity';\n\nUser.hasMany(Order, 'user_id');\nOrder.belongsTo(User, 'user_id');\n</code></pre>"},{"location":"advanced/troubleshooting/#missing-foreign-key","title":"Missing Foreign Key","text":"<p>Error: <pre><code>ValidationError: Foreign key 'user_id' is required\n</code></pre></p> <p>Causes: - Foreign key not set when creating related entity - Null foreign key value</p> <p>Solutions:</p> <pre><code>@Entity()\nclass Order {\n  @PartitionKey()\n  id!: string;\n\n  @ForeignKey(() =&gt; User)\n  @Attribute({ required: true })\n  user_id!: string;\n\n  @BelongsTo(() =&gt; User, 'user_id')\n  user!: User;\n}\n\n// Wrong - missing foreign key\nawait Order.create({\n  id: 'order-123',\n  total: 100\n  // Missing user_id\n});\n\n// Correct - include foreign key\nawait Order.create({\n  id: 'order-123',\n  user_id: 'user-456',\n  total: 100\n});\n\n// Validate foreign key exists\nasync function CreateOrderForUser(user_id: string, order_data: any): Promise&lt;Order&gt; {\n  const user = await User.findOne({ where: { id: user_id } });\n\n  if (!user) {\n    throw new Error(`User ${user_id} not found`);\n  }\n\n  return Order.create({\n    ...order_data,\n    user_id\n  });\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#eager-loading-fails","title":"Eager Loading Fails","text":"<p>Error: <pre><code>Error: Cannot load relationship 'user' - relation not defined\n</code></pre></p> <p>Causes: - Relationship not properly configured - Wrong foreign key specified</p> <p>Solutions:</p> <pre><code>// Check relationship configuration\n@Entity()\nclass Order {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  user_id!: string;\n\n  // Make sure relationship is properly configured\n  @BelongsTo(() =&gt; User, 'user_id') // Second param must match attribute name\n  user!: User;\n}\n\n// Test relationship loading\nconst order = await Order.findOne({\n  where: { id: 'order-123' },\n  include: ['user']\n});\n\nif (!order.user) {\n  console.error('User not loaded, checking configuration...');\n\n  // Manually load to debug\n  const user = await User.findOne({ where: { id: order.user_id } });\n  console.log('User exists:', !!user);\n}\n\n// Alternative: Load relationships manually\nconst order = await Order.findOne({ where: { id: 'order-123' } });\norder.user = await User.findOne({ where: { id: order.user_id } });\n</code></pre>"},{"location":"advanced/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"advanced/troubleshooting/#slow-queries","title":"Slow Queries","text":"<p>Symptoms: - Queries taking &gt; 1 second - High latency in production</p> <p>Diagnosis:</p> <pre><code>// Measure query performance\nasync function MeasureQuery&lt;T&gt;(\n  name: string,\n  fn: () =&gt; Promise&lt;T&gt;\n): Promise&lt;T&gt; {\n  const start = performance.now();\n  const result = await fn();\n  const duration = performance.now() - start;\n\n  console.log(`${name}: ${duration.toFixed(2)}ms`);\n\n  if (duration &gt; 1000) {\n    console.warn('Slow query detected!');\n  }\n\n  return result;\n}\n\n// Test queries\nawait MeasureQuery('Find users', () =&gt;\n  User.find({ where: { status: 'active' } })\n);\n\n// Enable DynamoDB client logging\nimport { Logger } from '@aws-sdk/types';\n\nconst logger: Logger = {\n  debug: (...args) =&gt; console.log('[DEBUG]', ...args),\n  info: (...args) =&gt; console.log('[INFO]', ...args),\n  warn: (...args) =&gt; console.warn('[WARN]', ...args),\n  error: (...args) =&gt; console.error('[ERROR]', ...args)\n};\n\nconst client = new DynamoDBClient({\n  region: 'us-east-1',\n  logger\n});\n</code></pre> <p>Solutions:</p> <pre><code>// Add indexes for common queries\n@Entity()\nclass User {\n  @Attribute()\n  @Index('StatusIndex', { type: 'PARTITION' })\n  status!: string;\n\n  @Attribute()\n  @Index('StatusIndex', { type: 'SORT' })\n  created_at!: number;\n}\n\n// Use projection to reduce response size\nconst users = await User.find({\n  where: { status: 'active' },\n  select: ['id', 'name', 'email']\n});\n\n// Use pagination for large result sets\nconst users = await User.find({\n  where: { status: 'active' },\n  limit: 100\n});\n\n// Use batch operations\nconst users = await User.batchGet(\n  user_ids.map(id =&gt; ({ id }))\n);\n</code></pre>"},{"location":"advanced/troubleshooting/#memory-issues","title":"Memory Issues","text":"<p>Error: <pre><code>JavaScript heap out of memory\n</code></pre></p> <p>Causes: - Loading too many items at once - Memory leaks in pagination - Large attribute values</p> <p>Solutions:</p> <pre><code>// Wrong - loads entire table into memory\nconst all_users = await User.scan();\n\n// Correct - stream results\nasync function ProcessAllUsers(\n  callback: (user: User) =&gt; Promise&lt;void&gt;\n): Promise&lt;void&gt; {\n  let cursor: any;\n\n  do {\n    const page = await User.scan({\n      limit: 100,\n      cursor\n    });\n\n    for (const user of page.items) {\n      await callback(user);\n    }\n\n    cursor = page.cursor;\n\n    // Force garbage collection between pages\n    if (global.gc) {\n      global.gc();\n    }\n  } while (cursor);\n}\n\n// Usage\nawait ProcessAllUsers(async (user) =&gt; {\n  console.log('Processing:', user.id);\n  // Process one user at a time\n});\n\n// Monitor memory usage\nfunction LogMemoryUsage(): void {\n  const used = process.memoryUsage();\n  console.log('Memory usage:', {\n    rss: `${Math.round(used.rss / 1024 / 1024)}MB`,\n    heapTotal: `${Math.round(used.heapTotal / 1024 / 1024)}MB`,\n    heapUsed: `${Math.round(used.heapUsed / 1024 / 1024)}MB`\n  });\n}\n\nsetInterval(LogMemoryUsage, 10000);\n</code></pre>"},{"location":"advanced/troubleshooting/#high-costs","title":"High Costs","text":"<p>Symptoms: - DynamoDB bill higher than expected - Many read/write capacity units consumed</p> <p>Diagnosis:</p> <pre><code>// Track consumed capacity\nclass CapacityTracker {\n  private total_rcu = 0;\n  private total_wcu = 0;\n\n  async TrackQuery&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {\n    const result = await fn();\n\n    // Get consumed capacity from response metadata\n    if ((result as any).ConsumedCapacity) {\n      const capacity = (result as any).ConsumedCapacity;\n      this.total_rcu += capacity.ReadCapacityUnits || 0;\n      this.total_wcu += capacity.WriteCapacityUnits || 0;\n    }\n\n    return result;\n  }\n\n  GetReport() {\n    return {\n      total_rcu: this.total_rcu,\n      total_wcu: this.total_wcu,\n      estimated_cost: this.total_rcu * 0.00025 + this.total_wcu * 0.00125\n    };\n  }\n}\n\n// Use strongly consistent reads only when necessary\nconst user = await User.findOne({\n  where: { id: 'user-123' },\n  consistent: false // Eventually consistent - uses 0.5x RCUs\n});\n</code></pre>"},{"location":"advanced/troubleshooting/#type-errors","title":"Type Errors","text":""},{"location":"advanced/troubleshooting/#typescript-compilation-errors","title":"TypeScript Compilation Errors","text":"<p>Error: <pre><code>TS2322: Type 'string' is not assignable to type 'number'\n</code></pre></p> <p>Solutions:</p> <pre><code>// Use proper types\n@Entity()\nclass User {\n  @PartitionKey()\n  id!: string;\n\n  @Attribute()\n  age!: number;\n}\n\n// Wrong\nconst user = await User.create({\n  id: 'user-123',\n  age: '25' // Type error\n});\n\n// Correct\nconst user = await User.create({\n  id: 'user-123',\n  age: 25\n});\n\n// Use type assertions carefully\nconst user_data: any = { id: 'user-123', age: '25' };\n\nconst user = await User.create({\n  id: user_data.id,\n  age: parseInt(user_data.age)\n});\n\n// Define interfaces for input data\ninterface CreateUserInput {\n  id: string;\n  name: string;\n  age: number;\n}\n\nasync function CreateUser(input: CreateUserInput): Promise&lt;User&gt; {\n  return User.create(input);\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#generic-type-issues","title":"Generic Type Issues","text":"<p>Error: <pre><code>TS2345: Argument of type 'unknown' is not assignable to parameter\n</code></pre></p> <p>Solutions:</p> <pre><code>// Use explicit generic types\nasync function FindByIds&lt;T extends Entity&gt;(\n  model: typeof Entity,\n  ids: string[]\n): Promise&lt;T[]&gt; {\n  return model.batchGet(ids.map(id =&gt; ({ id }))) as Promise&lt;T[]&gt;;\n}\n\n// Usage with type safety\nconst users = await FindByIds&lt;User&gt;(User, ['user-1', 'user-2']);\n\n// Define type guards\nfunction IsUser(obj: any): obj is User {\n  return obj &amp;&amp; typeof obj.id === 'string' &amp;&amp; typeof obj.name === 'string';\n}\n\nconst data: unknown = await User.findOne({ where: { id: 'user-123' } });\n\nif (IsUser(data)) {\n  console.log(data.name); // Type-safe\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#debugging-tips","title":"Debugging Tips","text":""},{"location":"advanced/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>// Set log level\nprocess.env.DEBUG = 'dynamite:*';\n\n// Custom logger\nclass CustomLogger {\n  static Log(level: string, message: string, data?: any): void {\n    console.log(`[${new Date().toISOString()}] [${level}] ${message}`, data || '');\n  }\n}\n\n// Log all queries\nconst original_find = User.find;\nUser.find = async function(...args: any[]) {\n  CustomLogger.Log('INFO', 'Query started', args);\n  const result = await original_find.apply(this, args);\n  CustomLogger.Log('INFO', 'Query completed', { count: result.items.length });\n  return result;\n};\n</code></pre>"},{"location":"advanced/troubleshooting/#inspect-dynamodb-requests","title":"Inspect DynamoDB Requests","text":"<pre><code>// Log raw DynamoDB requests\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\n\nclass LoggingClient extends DynamoDBClient {\n  async send(command: any): Promise&lt;any&gt; {\n    console.log('DynamoDB Request:', {\n      command: command.constructor.name,\n      input: command.input\n    });\n\n    const result = await super.send(command);\n\n    console.log('DynamoDB Response:', {\n      statusCode: result.$metadata?.httpStatusCode,\n      requestId: result.$metadata?.requestId\n    });\n\n    return result;\n  }\n}\n\nconst client = new LoggingClient({ region: 'us-east-1' });\nDynamite.Configure({ client });\n</code></pre>"},{"location":"advanced/troubleshooting/#use-dynamodb-console","title":"Use DynamoDB Console","text":"<p>Access AWS Console to inspect data directly:</p> <ol> <li>Go to DynamoDB Console</li> <li>Select your table</li> <li>Click \"Explore table items\"</li> <li>Run queries to verify data structure</li> <li>Check indexes and capacity settings</li> </ol>"},{"location":"advanced/troubleshooting/#local-testing","title":"Local Testing","text":"<pre><code>// Use DynamoDB Local for testing\nconst is_test = process.env.NODE_ENV === 'test';\n\nconst client = new DynamoDBClient(\n  is_test\n    ? {\n        region: 'local',\n        endpoint: 'http://localhost:8000',\n        credentials: {\n          accessKeyId: 'dummy',\n          secretAccessKey: 'dummy'\n        }\n      }\n    : {\n        region: 'us-east-1'\n      }\n);\n\nDynamite.Configure({ client });\n\n// Create tables automatically in tests\nif (is_test) {\n  await User.createTable();\n  await Order.createTable();\n}\n</code></pre>"},{"location":"advanced/troubleshooting/#common-error-messages","title":"Common Error Messages","text":""},{"location":"advanced/troubleshooting/#resourcenotfoundexception","title":"ResourceNotFoundException","text":"<pre><code>ResourceNotFoundException: Requested resource not found\n</code></pre> <p>Meaning: Table or index doesn't exist.</p> <p>Solutions: - Verify table name is correct - Check table exists in the specified region - Ensure table is fully created (not in CREATING status) - For indexes, verify GSI name</p>"},{"location":"advanced/troubleshooting/#conditionalcheckfailedexception","title":"ConditionalCheckFailedException","text":"<pre><code>ConditionalCheckFailedException: The conditional request failed\n</code></pre> <p>Meaning: Condition expression evaluated to false.</p> <p>Solutions: - Check your condition expressions - Verify attribute values are correct - Use consistent reads for conditions</p>"},{"location":"advanced/troubleshooting/#provisionedthroughputexceededexception","title":"ProvisionedThroughputExceededException","text":"<pre><code>ProvisionedThroughputExceededException: Rate exceeded\n</code></pre> <p>Meaning: Too many requests for provisioned capacity.</p> <p>Solutions: - Enable auto-scaling - Increase provisioned capacity - Implement exponential backoff - Use on-demand billing mode</p>"},{"location":"advanced/troubleshooting/#validationexception","title":"ValidationException","text":"<pre><code>ValidationException: One or more parameter values were invalid\n</code></pre> <p>Meaning: Invalid request parameters.</p> <p>Solutions: - Check attribute names are correct - Verify key schema matches - Ensure operators are supported - Review data types</p> <p>For more help: - Performance Guide - Migration Guide - AWS Support</p>"},{"location":"api/client/","title":"Client API Reference","text":""},{"location":"api/client/#overview","title":"Overview","text":"<p>The Dynamite client is the central configuration manager for DynamoDB connections. It handles client initialization, table synchronization, and connection lifecycle management. The <code>Dynamite</code> class provides a clean API for configuring AWS SDK DynamoDB clients and automatically creating tables with their Global Secondary Indexes (GSI).</p>"},{"location":"api/client/#class-dynamite","title":"Class: Dynamite","text":"<p>The main client class that manages DynamoDB connections and table operations.</p>"},{"location":"api/client/#constructor","title":"Constructor","text":"<pre><code>constructor(config: DynamiteConfig)\n</code></pre> <p>Creates a new Dynamite client instance with the provided configuration.</p> <p>Parameters: - <code>config</code> (DynamiteConfig): Configuration object containing DynamoDB client settings and table definitions</p> <p>Example: <pre><code>import { Dynamite } from \"@arcaelas/dynamite\";\nimport { User, Order, Product } from \"./models\";\n\nconst client = new Dynamite({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  },\n  tables: [User, Order, Product]\n});\n</code></pre></p>"},{"location":"api/client/#configuration","title":"Configuration","text":""},{"location":"api/client/#dynamiteconfig-interface","title":"DynamiteConfig Interface","text":"<pre><code>interface DynamiteConfig extends DynamoDBClientConfig {\n  tables: Array&lt;new (...args: any[]) =&gt; any&gt;;\n}\n</code></pre> <p>The configuration interface extends AWS SDK's <code>DynamoDBClientConfig</code> and adds table definitions.</p> <p>Properties:</p> Property Type Required Description <code>tables</code> <code>Array&lt;Class&gt;</code> Yes Array of Table class constructors to register <code>region</code> <code>string</code> Yes AWS region (e.g., \"us-east-1\") <code>endpoint</code> <code>string</code> No Custom endpoint URL (for DynamoDB Local) <code>credentials</code> <code>AwsCredentials</code> No AWS credentials object <code>maxAttempts</code> <code>number</code> No Maximum retry attempts <code>requestTimeout</code> <code>number</code> No Request timeout in milliseconds"},{"location":"api/client/#aws-credentials","title":"AWS Credentials","text":"<pre><code>interface AwsCredentials {\n  accessKeyId: string;\n  secretAccessKey: string;\n  sessionToken?: string;\n}\n</code></pre>"},{"location":"api/client/#instance-methods","title":"Instance Methods","text":""},{"location":"api/client/#connect","title":"connect()","text":"<pre><code>connect(): void\n</code></pre> <p>Connects the client and sets it as the global DynamoDB client for Table operations. This method must be called before performing any Table operations.</p> <p>Example: <pre><code>const client = new Dynamite({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  },\n  tables: [User, Order]\n});\n\nclient.connect();\n\n// Now Table operations are available\nconst user = await User.create({ name: \"John\" });\n</code></pre></p> <p>Notes: - Idempotent operation - calling multiple times has no effect - Sets the internal client as the global client for all Table instances - Must be called before any Table.create(), Table.where(), etc.</p>"},{"location":"api/client/#sync","title":"sync()","text":"<pre><code>async sync(): Promise&lt;void&gt;\n</code></pre> <p>Synchronizes all declared tables with DynamoDB. This method creates tables if they don't exist, including their Global Secondary Indexes (GSI) for <code>@HasMany</code> relationships.</p> <p>Returns: - <code>Promise&lt;void&gt;</code>: Resolves when all tables are synchronized</p> <p>Example: <pre><code>await client.sync();\n\n// All tables defined in config.tables are now created in DynamoDB\n// with their primary keys, sort keys, and GSI indexes\n</code></pre></p> <p>Behavior: - Creates tables with <code>PAY_PER_REQUEST</code> billing mode - Automatically detects and creates GSI for <code>@HasMany</code> relationships - Idempotent - safe to call multiple times - Ignores <code>ResourceInUseException</code> (table already exists) - Throws errors for other failures</p> <p>Table Creation Details: - Partition Key: Detected from <code>@PrimaryKey()</code> or <code>@Index()</code> decorator - Sort Key: Detected from <code>@IndexSort()</code> decorator (optional) - GSI: Automatically created for each <code>@HasMany</code> relationship with naming pattern <code>GSI{N}_{foreignKey}</code> - Billing Mode: <code>PAY_PER_REQUEST</code> (on-demand) - Attribute Definitions: Automatically inferred (all keys default to String type)</p>"},{"location":"api/client/#getclient","title":"getClient()","text":"<pre><code>getClient(): DynamoDBClient\n</code></pre> <p>Returns the underlying AWS SDK DynamoDB client instance.</p> <p>Returns: - <code>DynamoDBClient</code>: The AWS SDK DynamoDB client</p> <p>Example: <pre><code>const awsClient = client.getClient();\n\n// Use for direct AWS SDK operations\nimport { DescribeTableCommand } from \"@aws-sdk/client-dynamodb\";\nconst result = await awsClient.send(\n  new DescribeTableCommand({ TableName: \"users\" })\n);\n</code></pre></p> <p>Use Cases: - Direct access to AWS SDK operations - Custom commands not supported by Dynamite - Advanced DynamoDB features - Testing and debugging</p>"},{"location":"api/client/#isready","title":"isReady()","text":"<pre><code>isReady(): boolean\n</code></pre> <p>Checks if the client is connected and all tables are synchronized.</p> <p>Returns: - <code>boolean</code>: <code>true</code> if both <code>connect()</code> and <code>sync()</code> have completed successfully</p> <p>Example: <pre><code>console.log(client.isReady()); // false\n\nclient.connect();\nawait client.sync();\n\nconsole.log(client.isReady()); // true\n</code></pre></p>"},{"location":"api/client/#disconnect","title":"disconnect()","text":"<pre><code>disconnect(): void\n</code></pre> <p>Disconnects and cleans up the DynamoDB client. Destroys the underlying AWS SDK client and resets internal state.</p> <p>Example: <pre><code>client.disconnect();\n\n// Client is no longer usable\n// Table operations will throw errors\n</code></pre></p> <p>Behavior: - Calls <code>client.destroy()</code> on the underlying AWS SDK client - Resets <code>connected</code> and <code>synced</code> flags - Clears the global client reference if it matches this instance - Safe to call multiple times - Logs warnings if destruction fails</p>"},{"location":"api/client/#configuration-examples","title":"Configuration Examples","text":""},{"location":"api/client/#local-development-dynamodb-local","title":"Local Development (DynamoDB Local)","text":"<pre><code>import { Dynamite } from \"@arcaelas/dynamite\";\nimport { User, Order, Product } from \"./models\";\n\nconst client = new Dynamite({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  },\n  tables: [User, Order, Product]\n});\n\nclient.connect();\nawait client.sync();\n</code></pre> <p>Docker Setup: <pre><code>docker run -d -p 8000:8000 amazon/dynamodb-local\n</code></pre></p> <p>Docker Compose: <pre><code>version: '3.8'\nservices:\n  dynamodb-local:\n    image: amazon/dynamodb-local\n    ports:\n      - \"8000:8000\"\n    command: [\"-jar\", \"DynamoDBLocal.jar\", \"-sharedDb\"]\n</code></pre></p>"},{"location":"api/client/#aws-production-configuration","title":"AWS Production Configuration","text":"<pre><code>const client = new Dynamite({\n  region: process.env.AWS_REGION || \"us-east-1\",\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!\n  },\n  tables: [User, Order, Product],\n  maxAttempts: 3,\n  requestTimeout: 3000\n});\n\nclient.connect();\nawait client.sync();\n</code></pre>"},{"location":"api/client/#environment-variables","title":"Environment Variables","text":"<pre><code># .env file\nAWS_REGION=us-east-1\nAWS_ACCESS_KEY_ID=your-access-key-id\nAWS_SECRET_ACCESS_KEY=your-secret-access-key\n\n# For local development\nDYNAMODB_ENDPOINT=http://localhost:8000\n</code></pre> <pre><code>import { Dynamite } from \"@arcaelas/dynamite\";\nimport * as dotenv from \"dotenv\";\n\ndotenv.config();\n\nconst config: any = {\n  region: process.env.AWS_REGION!,\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!\n  },\n  tables: [User, Order, Product]\n};\n\n// Add endpoint only for local development\nif (process.env.DYNAMODB_ENDPOINT) {\n  config.endpoint = process.env.DYNAMODB_ENDPOINT;\n}\n\nconst client = new Dynamite(config);\nclient.connect();\nawait client.sync();\n</code></pre>"},{"location":"api/client/#multiple-client-instances","title":"Multiple Client Instances","text":"<p>You can create multiple Dynamite clients for different configurations or regions.</p> <pre><code>import { Dynamite } from \"@arcaelas/dynamite\";\nimport { User, Order } from \"./models\";\nimport { Log, Metric } from \"./monitoring\";\n\n// Production database client\nconst production_client = new Dynamite({\n  region: \"us-east-1\",\n  credentials: {\n    accessKeyId: process.env.PROD_AWS_KEY!,\n    secretAccessKey: process.env.PROD_AWS_SECRET!\n  },\n  tables: [User, Order]\n});\n\n// Analytics database client (different region)\nconst analytics_client = new Dynamite({\n  region: \"us-west-2\",\n  credentials: {\n    accessKeyId: process.env.ANALYTICS_AWS_KEY!,\n    secretAccessKey: process.env.ANALYTICS_AWS_SECRET!\n  },\n  tables: [Log, Metric]\n});\n\n// Connect production client (becomes global)\nproduction_client.connect();\nawait production_client.sync();\n\n// User and Order operations use production_client\nconst user = await User.create({ name: \"John\" });\n\n// Switch to analytics client\nanalytics_client.connect();\nawait analytics_client.sync();\n\n// Log and Metric operations now use analytics_client\nconst log = await Log.create({ message: \"User created\" });\n</code></pre> <p>Important Notes: - Only one client can be the \"global\" client at a time - Calling <code>connect()</code> on a new client replaces the global client - Table operations always use the current global client - Consider using explicit client passing for multi-client scenarios</p>"},{"location":"api/client/#custom-configuration-options","title":"Custom Configuration Options","text":"<pre><code>const client = new Dynamite({\n  region: \"us-east-1\",\n  endpoint: \"https://dynamodb.us-east-1.amazonaws.com\",\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!\n  },\n  tables: [User, Order, Product],\n\n  // Advanced AWS SDK options\n  maxAttempts: 5,\n  requestTimeout: 5000,\n\n  // Custom retry strategy\n  retryMode: \"adaptive\",\n\n  // Enable logging\n  logger: console\n});\n</code></pre>"},{"location":"api/client/#utility-functions","title":"Utility Functions","text":""},{"location":"api/client/#setglobalclient","title":"setGlobalClient()","text":"<pre><code>export const setGlobalClient = (client: DynamoDBClient): void\n</code></pre> <p>Sets the global DynamoDB client for Table operations. Typically called internally by <code>Dynamite.connect()</code>.</p> <p>Parameters: - <code>client</code> (DynamoDBClient): AWS SDK DynamoDB client instance</p> <p>Example: <pre><code>import { DynamoDBClient } from \"@aws-sdk/client-dynamodb\";\nimport { setGlobalClient } from \"@arcaelas/dynamite\";\n\nconst custom_client = new DynamoDBClient({\n  region: \"us-east-1\"\n});\n\nsetGlobalClient(custom_client);\n</code></pre></p>"},{"location":"api/client/#getglobalclient","title":"getGlobalClient()","text":"<pre><code>export const getGlobalClient = (): DynamoDBClient\n</code></pre> <p>Gets the current global DynamoDB client. Throws an error if no client is set.</p> <p>Returns: - <code>DynamoDBClient</code>: The global DynamoDB client</p> <p>Throws: - <code>Error</code>: If no global client has been set</p> <p>Example: <pre><code>import { getGlobalClient } from \"@arcaelas/dynamite\";\n\ntry {\n  const client = getGlobalClient();\n  console.log(\"Client is configured\");\n} catch (error) {\n  console.error(\"No client configured\");\n}\n</code></pre></p>"},{"location":"api/client/#hasglobalclient","title":"hasGlobalClient()","text":"<pre><code>export const hasGlobalClient = (): boolean\n</code></pre> <p>Checks if a global DynamoDB client is available.</p> <p>Returns: - <code>boolean</code>: <code>true</code> if a global client exists</p> <p>Example: <pre><code>import { hasGlobalClient } from \"@arcaelas/dynamite\";\n\nif (hasGlobalClient()) {\n  console.log(\"Client is available\");\n} else {\n  console.log(\"No client configured\");\n}\n</code></pre></p>"},{"location":"api/client/#requireclient","title":"requireClient()","text":"<pre><code>export const requireClient = (): DynamoDBClient\n</code></pre> <p>Requires a global client to be available. Throws an error with a localized message if not set.</p> <p>Returns: - <code>DynamoDBClient</code>: The global DynamoDB client</p> <p>Throws: - <code>Error</code>: If no global client is configured (Spanish error message)</p> <p>Example: <pre><code>import { requireClient } from \"@arcaelas/dynamite\";\n\ntry {\n  const client = requireClient();\n  // Use client for operations\n} catch (error) {\n  console.error(error.message); // \"DynamoDB client no configurado. Use Dynamite.connect() primero.\"\n}\n</code></pre></p>"},{"location":"api/client/#error-handling","title":"Error Handling","text":""},{"location":"api/client/#common-errors","title":"Common Errors","text":""},{"location":"api/client/#resourceinuseexception","title":"ResourceInUseException","text":"<p>Thrown when attempting to create a table that already exists.</p> <pre><code>try {\n  await client.sync();\n} catch (error) {\n  if (error.name === \"ResourceInUseException\") {\n    console.log(\"Table already exists\");\n  }\n}\n</code></pre> <p>Note: Dynamite automatically handles this error during <code>sync()</code>.</p>"},{"location":"api/client/#validationexception","title":"ValidationException","text":"<p>Thrown when table schema or attributes are invalid.</p> <pre><code>try {\n  await client.sync();\n} catch (error) {\n  if (error.name === \"ValidationException\") {\n    console.error(\"Invalid table schema:\", error.message);\n  }\n}\n</code></pre> <p>Common Causes: - Missing <code>@PrimaryKey()</code> or <code>@Index()</code> decorator - Reserved keyword used as attribute name - Invalid attribute type - PK and SK with same attribute name</p>"},{"location":"api/client/#unrecognizedclientexception","title":"UnrecognizedClientException","text":"<p>Thrown when credentials are invalid or DynamoDB endpoint is unreachable.</p> <pre><code>try {\n  client.connect();\n  await client.sync();\n} catch (error) {\n  if (error.name === \"UnrecognizedClientException\") {\n    console.error(\"Invalid credentials or endpoint\");\n  }\n}\n</code></pre> <p>Solutions: - Verify AWS credentials - Check DynamoDB Local is running (for local development) - Verify endpoint URL is correct - Check network connectivity</p>"},{"location":"api/client/#metadata-not-found","title":"Metadata Not Found","text":"<p>Thrown when attempting to sync a table without proper decorators.</p> <pre><code>try {\n  await client.sync();\n} catch (error) {\n  if (error.message.includes(\"not registered in wrapper\")) {\n    console.error(\"Table class missing decorators\");\n  }\n}\n</code></pre> <p>Solution: Ensure all table classes use <code>@PrimaryKey()</code> or <code>@Index()</code> decorator.</p>"},{"location":"api/client/#no-global-client","title":"No Global Client","text":"<p>Thrown when attempting Table operations without connecting first.</p> <pre><code>try {\n  const user = await User.create({ name: \"John\" });\n} catch (error) {\n  if (error.message.includes(\"DynamoDB client no configurado\")) {\n    console.error(\"Call client.connect() first\");\n  }\n}\n</code></pre>"},{"location":"api/client/#error-handling-best-practices","title":"Error Handling Best Practices","text":"<pre><code>import { Dynamite } from \"@arcaelas/dynamite\";\nimport { User, Order } from \"./models\";\n\nasync function initialize_database() {\n  const client = new Dynamite({\n    region: process.env.AWS_REGION || \"us-east-1\",\n    endpoint: process.env.DYNAMODB_ENDPOINT,\n    credentials: {\n      accessKeyId: process.env.AWS_ACCESS_KEY_ID || \"test\",\n      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || \"test\"\n    },\n    tables: [User, Order]\n  });\n\n  try {\n    // Connect client\n    client.connect();\n    console.log(\"Client connected\");\n\n    // Sync tables\n    await client.sync();\n    console.log(\"Tables synchronized\");\n\n    // Verify ready state\n    if (client.isReady()) {\n      console.log(\"Database ready for operations\");\n    }\n\n    return client;\n  } catch (error: any) {\n    // Handle specific errors\n    if (error.name === \"UnrecognizedClientException\") {\n      console.error(\"Authentication failed. Check credentials.\");\n    } else if (error.name === \"ValidationException\") {\n      console.error(\"Invalid table schema:\", error.message);\n    } else if (error.message?.includes(\"not registered in wrapper\")) {\n      console.error(\"Table class missing decorators\");\n    } else {\n      console.error(\"Database initialization failed:\", error);\n    }\n\n    // Cleanup on failure\n    client.disconnect();\n    throw error;\n  }\n}\n\n// Usage\ntry {\n  const client = await initialize_database();\n\n  // Perform operations\n  const user = await User.create({ name: \"John\" });\n\n  // Cleanup on shutdown\n  process.on(\"SIGINT\", () =&gt; {\n    client.disconnect();\n    process.exit(0);\n  });\n} catch (error) {\n  console.error(\"Application failed to start\");\n  process.exit(1);\n}\n</code></pre>"},{"location":"api/client/#complete-usage-example","title":"Complete Usage Example","text":""},{"location":"api/client/#basic-application-setup","title":"Basic Application Setup","text":"<pre><code>import { Dynamite } from \"@arcaelas/dynamite\";\nimport {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  HasMany,\n  CreationOptional,\n  NonAttribute\n} from \"@arcaelas/dynamite\";\n\n// Define models\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare email: string;\n\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;Order[]&gt;;\n}\n\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare user_id: string;\n  declare total: number;\n\n  @Default(() =&gt; \"pending\")\n  declare status: CreationOptional&lt;string&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n}\n\n// Initialize client\nasync function setup_database() {\n  const client = new Dynamite({\n    region: \"us-east-1\",\n    endpoint: \"http://localhost:8000\",\n    credentials: {\n      accessKeyId: \"test\",\n      secretAccessKey: \"test\"\n    },\n    tables: [User, Order]\n  });\n\n  // Connect and sync\n  client.connect();\n  await client.sync();\n\n  console.log(\"Database ready:\", client.isReady());\n  return client;\n}\n\n// Application entry point\nasync function main() {\n  const client = await setup_database();\n\n  try {\n    // Create user\n    const user = await User.create({\n      name: \"John Doe\",\n      email: \"john@example.com\"\n    });\n\n    console.log(\"User created:\", user.id);\n\n    // Create orders\n    const order1 = await Order.create({\n      user_id: user.id,\n      total: 99.99\n    });\n\n    const order2 = await Order.create({\n      user_id: user.id,\n      total: 149.99\n    });\n\n    // Query with relationships\n    const users_with_orders = await User.where({ id: user.id }, {\n      include: {\n        orders: {\n          where: { status: \"pending\" }\n        }\n      }\n    });\n\n    console.log(\"User orders:\", users_with_orders[0].orders.length);\n  } finally {\n    // Cleanup on exit\n    client.disconnect();\n  }\n}\n\nmain().catch(console.error);\n</code></pre>"},{"location":"api/client/#expressjs-integration","title":"Express.js Integration","text":"<pre><code>import express from \"express\";\nimport { Dynamite } from \"@arcaelas/dynamite\";\nimport { User } from \"./models\";\n\nconst app = express();\napp.use(express.json());\n\n// Initialize database\nlet client: Dynamite;\n\nasync function initialize() {\n  client = new Dynamite({\n    region: process.env.AWS_REGION || \"us-east-1\",\n    endpoint: process.env.DYNAMODB_ENDPOINT,\n    credentials: {\n      accessKeyId: process.env.AWS_ACCESS_KEY_ID || \"test\",\n      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || \"test\"\n    },\n    tables: [User]\n  });\n\n  client.connect();\n  await client.sync();\n  console.log(\"Database initialized\");\n}\n\n// API routes\napp.get(\"/users\", async (req, res) =&gt; {\n  try {\n    const users = await User.where({});\n    res.json(users);\n  } catch (error) {\n    res.status(500).json({ error: \"Failed to fetch users\" });\n  }\n});\n\napp.post(\"/users\", async (req, res) =&gt; {\n  try {\n    const user = await User.create(req.body);\n    res.status(201).json(user);\n  } catch (error) {\n    res.status(500).json({ error: \"Failed to create user\" });\n  }\n});\n\n// Start server\ninitialize()\n  .then(() =&gt; {\n    app.listen(3000, () =&gt; {\n      console.log(\"Server running on port 3000\");\n    });\n  })\n  .catch((error) =&gt; {\n    console.error(\"Failed to start:\", error);\n    process.exit(1);\n  });\n\n// Graceful shutdown\nprocess.on(\"SIGINT\", () =&gt; {\n  console.log(\"Shutting down...\");\n  client.disconnect();\n  process.exit(0);\n});\n</code></pre>"},{"location":"api/client/#best-practices","title":"Best Practices","text":""},{"location":"api/client/#1-single-client-instance","title":"1. Single Client Instance","text":"<p>Create one client instance per application and reuse it.</p> <pre><code>// Good\nconst client = new Dynamite({ /* config */ });\nclient.connect();\nawait client.sync();\n\n// Bad - creates multiple clients unnecessarily\nfunction get_client() {\n  return new Dynamite({ /* config */ });\n}\n</code></pre>"},{"location":"api/client/#2-call-sync-once","title":"2. Call sync() Once","text":"<p>Call <code>sync()</code> only during application initialization, not before every operation.</p> <pre><code>// Good - sync once at startup\nawait client.sync();\nconst user = await User.create({ name: \"John\" });\nconst order = await Order.create({ user_id: user.id });\n\n// Bad - syncing repeatedly\nawait client.sync();\nconst user = await User.create({ name: \"John\" });\nawait client.sync();\nconst order = await Order.create({ user_id: user.id });\n</code></pre>"},{"location":"api/client/#3-graceful-shutdown","title":"3. Graceful Shutdown","text":"<p>Always disconnect the client on application shutdown.</p> <pre><code>process.on(\"SIGINT\", () =&gt; {\n  console.log(\"Shutting down gracefully\");\n  client.disconnect();\n  process.exit(0);\n});\n\nprocess.on(\"SIGTERM\", () =&gt; {\n  console.log(\"Shutting down gracefully\");\n  client.disconnect();\n  process.exit(0);\n});\n</code></pre>"},{"location":"api/client/#4-environment-based-configuration","title":"4. Environment-Based Configuration","text":"<p>Use environment variables for configuration to separate dev/staging/production.</p> <pre><code>const client = new Dynamite({\n  region: process.env.AWS_REGION || \"us-east-1\",\n  endpoint: process.env.NODE_ENV === \"development\"\n    ? \"http://localhost:8000\"\n    : undefined,\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!\n  },\n  tables: [User, Order, Product]\n});\n</code></pre>"},{"location":"api/client/#5-error-handling","title":"5. Error Handling","text":"<p>Always handle errors during initialization and provide meaningful feedback.</p> <pre><code>try {\n  client.connect();\n  await client.sync();\n} catch (error: any) {\n  if (error.name === \"UnrecognizedClientException\") {\n    console.error(\"Check DynamoDB Local is running: docker run -p 8000:8000 amazon/dynamodb-local\");\n  } else {\n    console.error(\"Database initialization failed:\", error.message);\n  }\n  process.exit(1);\n}\n</code></pre>"},{"location":"api/client/#6-testing-setup","title":"6. Testing Setup","text":"<p>Use separate clients for testing with isolated configuration.</p> <pre><code>// test/setup.ts\nimport { Dynamite } from \"@arcaelas/dynamite\";\nimport { User, Order } from \"../models\";\n\nexport async function setup_test_database() {\n  const client = new Dynamite({\n    region: \"us-east-1\",\n    endpoint: \"http://localhost:8000\",\n    credentials: {\n      accessKeyId: \"test\",\n      secretAccessKey: \"test\"\n    },\n    tables: [User, Order]\n  });\n\n  client.connect();\n  await client.sync();\n  return client;\n}\n\nexport async function teardown_test_database(client: Dynamite) {\n  client.disconnect();\n}\n</code></pre>"},{"location":"api/client/#see-also","title":"See Also","text":"<ul> <li>Table API Reference - Complete Table class documentation</li> <li>Decorators Reference - All available decorators</li> <li>AWS SDK DynamoDB Client - Underlying AWS SDK documentation</li> <li>DynamoDB Local - Local development setup</li> </ul>"},{"location":"api/table/","title":"Table API Reference","text":""},{"location":"api/table/#descripcion-general","title":"Descripci\u00f3n General","text":"<p>La clase <code>Table</code> es la clase base para todos los modelos en Dynamite ORM. Proporciona una API completa y tipada para realizar operaciones CRUD, consultas avanzadas, gesti\u00f3n de relaciones y manipulaci\u00f3n de datos en DynamoDB.</p> <p>Caracter\u00edsticas Principales: - Tipado estricto con TypeScript - Operaciones CRUD completas - Sistema de consultas flexible con m\u00faltiples operadores - Soporte para relaciones HasMany y BelongsTo - Gesti\u00f3n autom\u00e1tica de timestamps (createdAt/updatedAt) - Validaciones y mutaciones integradas - Paginaci\u00f3n y ordenamiento - Selecci\u00f3n de atributos espec\u00edficos - Inclusi\u00f3n de relaciones anidadas</p>"},{"location":"api/table/#importacion","title":"Importaci\u00f3n","text":"<pre><code>import { Table } from '@arcaelas/dynamite';\n</code></pre>"},{"location":"api/table/#definicion-de-modelo","title":"Definici\u00f3n de Modelo","text":"<pre><code>import { Table, Name, PrimaryKey, NotNull, Default, CreatedAt, UpdatedAt } from '@arcaelas/dynamite';\n\n@Name(\"users\")\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare email: string;\n\n  @NotNull()\n  declare name: string;\n\n  @Default(() =&gt; 25)\n  declare age: number;\n\n  @CreatedAt()\n  declare createdAt: string;\n\n  @UpdatedAt()\n  declare updatedAt: string;\n}\n</code></pre>"},{"location":"api/table/#constructor","title":"Constructor","text":""},{"location":"api/table/#constructordata-inferattributest","title":"<code>constructor(data: InferAttributes&lt;T&gt;)</code>","text":"<p>Crea una nueva instancia del modelo con los datos proporcionados.</p> <p>Par\u00e1metros: - <code>data</code> - Objeto con los atributos del modelo (excluye relaciones y m\u00e9todos)</p> <p>Caracter\u00edsticas: - Aplica valores por defecto definidos con <code>@Default()</code> - Inicializa propiedades declaradas en el modelo - No persiste autom\u00e1ticamente en la base de datos (usar <code>save()</code> para persistir)</p> <p>Ejemplo:</p> <pre><code>const user = new User({\n  id: \"user-123\",\n  email: \"john@example.com\",\n  name: \"John Doe\",\n  age: 30\n});\n\n// Para persistir en la base de datos\nawait user.save();\n</code></pre>"},{"location":"api/table/#metodos-de-instancia","title":"M\u00e9todos de Instancia","text":""},{"location":"api/table/#save-promisethis","title":"<code>save(): Promise&lt;this&gt;</code>","text":"<p>Guarda o actualiza el registro actual en la base de datos.</p> <p>Comportamiento: - Si el registro no tiene <code>id</code> (o es <code>null</code>/<code>undefined</code>), crea un nuevo registro - Si el registro tiene <code>id</code>, actualiza el registro existente - Actualiza autom\u00e1ticamente el campo <code>updatedAt</code> si est\u00e1 definido - Establece <code>createdAt</code> solo en registros nuevos</p> <p>Retorna: La instancia actual actualizada</p> <p>Ejemplo:</p> <pre><code>// Crear nuevo registro\nconst user = new User({\n  email: \"jane@example.com\",\n  name: \"Jane Smith\"\n});\nawait user.save(); // createdAt y updatedAt se establecen autom\u00e1ticamente\n\n// Actualizar registro existente\nuser.name = \"Jane Doe\";\nawait user.save(); // Solo updatedAt se actualiza\n</code></pre>"},{"location":"api/table/#updatepatch-partialinferattributest-promisethis","title":"<code>update(patch: Partial&lt;InferAttributes&lt;T&gt;&gt;): Promise&lt;this&gt;</code>","text":"<p>Actualiza parcialmente el registro con los campos proporcionados.</p> <p>Par\u00e1metros: - <code>patch</code> - Objeto con los campos a actualizar</p> <p>Retorna: La instancia actual actualizada</p> <p>Ejemplo:</p> <pre><code>const user = await User.first({ id: \"user-123\" });\nawait user.update({\n  name: \"John Updated\",\n  age: 31\n});\n\nconsole.log(user.name); // \"John Updated\"\nconsole.log(user.age);  // 31\n</code></pre>"},{"location":"api/table/#destroy-promisenull","title":"<code>destroy(): Promise&lt;null&gt;</code>","text":"<p>Elimina el registro actual de la base de datos.</p> <p>Requisitos: - La instancia debe tener un <code>id</code> v\u00e1lido</p> <p>Retorna: <code>null</code></p> <p>Errores: - Lanza error si la instancia no tiene <code>id</code></p> <p>Ejemplo:</p> <pre><code>const user = await User.first({ id: \"user-123\" });\nawait user.destroy(); // Elimina el registro de la base de datos\n</code></pre>"},{"location":"api/table/#tojson-recordstring-any","title":"<code>toJSON(): Record&lt;string, any&gt;</code>","text":"<p>Serializa la instancia a un objeto JSON plano.</p> <p>Caracter\u00edsticas: - Incluye todas las columnas definidas con decoradores - Excluye relaciones (HasMany, BelongsTo) - Activa getters virtuales definidos en el modelo - Incluye propiedades enumerables ad-hoc</p> <p>Retorna: Objeto plano con los datos del modelo</p> <p>Ejemplo:</p> <pre><code>const user = await User.first({ id: \"user-123\" });\nconst json = user.toJSON();\n\nconsole.log(json);\n// {\n//   id: \"user-123\",\n//   email: \"john@example.com\",\n//   name: \"John Doe\",\n//   age: 30,\n//   createdAt: \"2025-01-15T10:30:00.000Z\",\n//   updatedAt: \"2025-01-15T10:30:00.000Z\"\n// }\n</code></pre>"},{"location":"api/table/#metodos-estaticos","title":"M\u00e9todos Est\u00e1ticos","text":""},{"location":"api/table/#createmdata-inferattributesm-promisem","title":"<code>create&lt;M&gt;(data: InferAttributes&lt;M&gt;): Promise&lt;M&gt;</code>","text":"<p>Crea y persiste un nuevo registro en la base de datos.</p> <p>Par\u00e1metros: - <code>data</code> - Objeto con los atributos del nuevo registro</p> <p>Caracter\u00edsticas: - Crea una nueva instancia - Establece autom\u00e1ticamente <code>createdAt</code> y <code>updatedAt</code> - Aplica valores por defecto, validaciones y mutaciones - Persiste inmediatamente en DynamoDB</p> <p>Retorna: Nueva instancia del modelo persistida</p> <p>Ejemplo:</p> <pre><code>const user = await User.create({\n  id: \"user-456\",\n  email: \"alice@example.com\",\n  name: \"Alice Wonder\",\n  age: 28\n});\n\nconsole.log(user.id); // \"user-456\"\nconsole.log(user.createdAt); // \"2025-01-15T10:30:00.000Z\"\n</code></pre> <p>Con validaciones y mutaciones:</p> <pre><code>@Name(\"users\")\nclass User extends Table&lt;User&gt; {\n  @Mutate(v =&gt; v.toLowerCase().trim())\n  @Validate(v =&gt; /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v) ? true : \"Email inv\u00e1lido\")\n  declare email: string;\n}\n\n// El email se convertir\u00e1 a min\u00fasculas y validar\u00e1 el formato\nconst user = await User.create({\n  id: \"user-789\",\n  email: \"  BOB@EXAMPLE.COM  \", // Se convierte a \"bob@example.com\"\n  name: \"Bob\"\n});\n</code></pre>"},{"location":"api/table/#updatemupdates-partialinferattributesm-filters-partialinferattributesm-promisenumber","title":"<code>update&lt;M&gt;(updates: Partial&lt;InferAttributes&lt;M&gt;&gt;, filters: Partial&lt;InferAttributes&lt;M&gt;&gt;): Promise&lt;number&gt;</code>","text":"<p>Actualiza m\u00faltiples registros que coincidan con los filtros.</p> <p>Par\u00e1metros: - <code>updates</code> - Objeto con los campos a actualizar (campos <code>undefined</code> se ignoran) - <code>filters</code> - Objeto con los criterios de selecci\u00f3n</p> <p>Caracter\u00edsticas: - Actualiza todos los registros que coincidan con los filtros - Actualiza autom\u00e1ticamente el campo <code>updatedAt</code> - Los campos con valor <code>undefined</code> se ignoran - Operaci\u00f3n at\u00f3mica por cada registro</p> <p>Retorna: N\u00famero de registros actualizados</p> <p>Ejemplo:</p> <pre><code>// Actualizar m\u00faltiples usuarios\nconst count = await User.update(\n  { active: false, role: \"suspended\" },\n  { status: \"banned\" }\n);\n\nconsole.log(`${count} usuarios suspendidos`);\n\n// Actualizar un usuario espec\u00edfico\nawait User.update(\n  { balance: 100.0 },\n  { id: \"user-123\" }\n);\n</code></pre> <p>Actualizaci\u00f3n condicional:</p> <pre><code>// Desactivar usuarios inactivos\nconst inactiveCount = await User.update(\n  { active: false },\n  { lastLoginDate: \"2024-01-01\" } // Filtro personalizado\n);\n</code></pre>"},{"location":"api/table/#deletemfilters-partialinferattributesm-promisenumber","title":"<code>delete&lt;M&gt;(filters: Partial&lt;InferAttributes&lt;M&gt;&gt;): Promise&lt;number&gt;</code>","text":"<p>Elimina registros que coincidan con los filtros.</p> <p>Par\u00e1metros: - <code>filters</code> - Objeto con los criterios de selecci\u00f3n</p> <p>Caracter\u00edsticas: - Elimina todos los registros que coincidan con los filtros - Operaci\u00f3n permanente (no hay soft delete por defecto) - Retorna el n\u00famero de registros eliminados</p> <p>Retorna: N\u00famero de registros eliminados</p> <p>Ejemplo:</p> <pre><code>// Eliminar un usuario espec\u00edfico\nconst count = await User.delete({ id: \"user-123\" });\nconsole.log(`${count} usuario(s) eliminado(s)`);\n\n// Eliminar m\u00faltiples usuarios\nawait User.delete({ status: \"inactive\", verified: false });\n\n// Eliminar todos los registros (usar con precauci\u00f3n)\nawait User.delete({});\n</code></pre>"},{"location":"api/table/#metodo-where-consultas-avanzadas","title":"M\u00e9todo where() - Consultas Avanzadas","text":"<p>El m\u00e9todo <code>where()</code> es el m\u00e9todo m\u00e1s vers\u00e1til para consultar datos, con m\u00faltiples sobrecargas y opciones avanzadas.</p>"},{"location":"api/table/#sobrecarga-1-wherefield-value-promisem","title":"Sobrecarga 1: <code>where(field, value): Promise&lt;M[]&gt;</code>","text":"<p>Busca registros donde un campo es igual a un valor (o m\u00faltiples valores).</p> <p>Par\u00e1metros: - <code>field</code> - Nombre del campo - <code>value</code> - Valor o array de valores (array se convierte en operador <code>IN</code>)</p> <p>Ejemplo:</p> <pre><code>// Igualdad simple\nconst admins = await User.where(\"role\", \"admin\");\n\n// IN impl\u00edcito con array\nconst users = await User.where(\"role\", [\"admin\", \"employee\"]);\n// Equivalente a: role IN (\"admin\", \"employee\")\n</code></pre>"},{"location":"api/table/#sobrecarga-2-wherefield-operator-value-promisem","title":"Sobrecarga 2: <code>where(field, operator, value): Promise&lt;M[]&gt;</code>","text":"<p>Busca registros usando un operador espec\u00edfico.</p> <p>Par\u00e1metros: - <code>field</code> - Nombre del campo - <code>operator</code> - Operador de comparaci\u00f3n (ver tabla de operadores) - <code>value</code> - Valor o array de valores (seg\u00fan el operador)</p> <p>Operadores Soportados:</p> Operador Descripci\u00f3n Ejemplo <code>\"=\"</code> Igual a <code>where(\"age\", \"=\", 25)</code> <code>\"!=\"</code> Diferente de <code>where(\"status\", \"!=\", \"banned\")</code> <code>\"&lt;\"</code> Menor que <code>where(\"age\", \"&lt;\", 30)</code> <code>\"&lt;=\"</code> Menor o igual que <code>where(\"price\", \"&lt;=\", 100)</code> <code>\"&gt;\"</code> Mayor que <code>where(\"balance\", \"&gt;\", 1000)</code> <code>\"&gt;=\"</code> Mayor o igual que <code>where(\"rating\", \"&gt;=\", 4)</code> <code>\"in\"</code> Incluido en array <code>where(\"status\", \"in\", [\"active\", \"pending\"])</code> <code>\"not-in\"</code> No incluido en array <code>where(\"role\", \"not-in\", [\"banned\"])</code> <code>\"contains\"</code> Contiene substring <code>where(\"name\", \"contains\", \"John\")</code> <code>\"begins-with\"</code> Comienza con <code>where(\"email\", \"begins-with\", \"admin@\")</code> <p>Ejemplos:</p> <pre><code>// Comparaci\u00f3n num\u00e9rica\nconst youngUsers = await User.where(\"age\", \"&lt;\", 30);\nconst richUsers = await User.where(\"balance\", \"&gt;\", 1000);\n\n// Comparaci\u00f3n de strings\nconst notBanned = await User.where(\"status\", \"!=\", \"banned\");\n\n// Operadores de array\nconst staff = await User.where(\"role\", \"in\", [\"admin\", \"employee\"]);\nconst customers = await User.where(\"role\", \"not-in\", [\"admin\", \"employee\"]);\n\n// Operadores de texto\nconst johns = await User.where(\"name\", \"contains\", \"John\");\nconst admins = await User.where(\"email\", \"begins-with\", \"admin@\");\n</code></pre>"},{"location":"api/table/#sobrecarga-3-wherefilters-promisem","title":"Sobrecarga 3: <code>where(filters): Promise&lt;M[]&gt;</code>","text":"<p>Busca registros que coincidan con m\u00faltiples campos (operador AND impl\u00edcito).</p> <p>Par\u00e1metros: - <code>filters</code> - Objeto con pares campo-valor</p> <p>Ejemplo:</p> <pre><code>// M\u00faltiples condiciones (AND)\nconst activeAdmins = await User.where({\n  role: \"admin\",\n  active: true,\n  verified: true\n});\n\n// Equivalente a: WHERE role = \"admin\" AND active = true AND verified = true\n</code></pre>"},{"location":"api/table/#sobrecarga-4-wherefilters-options-promisem","title":"Sobrecarga 4: <code>where(filters, options): Promise&lt;M[]&gt;</code>","text":"<p>Busca registros con opciones avanzadas de paginaci\u00f3n, ordenamiento, selecci\u00f3n de atributos e inclusi\u00f3n de relaciones.</p> <p>Par\u00e1metros: - <code>filters</code> - Objeto con pares campo-valor - <code>options</code> - Objeto con opciones avanzadas</p> <p>Opciones Disponibles:</p> <pre><code>interface WhereQueryOptions&lt;T&gt; {\n  order?: \"ASC\" | \"DESC\";        // Ordenamiento\n  skip?: number;                  // N\u00famero de registros a saltar (offset)\n  limit?: number;                 // N\u00famero m\u00e1ximo de registros a retornar\n  attributes?: string[];          // Campos espec\u00edficos a seleccionar\n  include?: {                     // Relaciones a incluir\n    [relation: string]: IncludeRelationOptions | true;\n  };\n}\n\ninterface IncludeRelationOptions {\n  where?: Record&lt;string, any&gt;;   // Filtros para la relaci\u00f3n\n  attributes?: string[];          // Campos espec\u00edficos de la relaci\u00f3n\n  order?: \"ASC\" | \"DESC\";        // Ordenamiento de la relaci\u00f3n\n  skip?: number;                  // Offset de la relaci\u00f3n\n  limit?: number;                 // L\u00edmite de la relaci\u00f3n\n  include?: Record&lt;string, IncludeRelationOptions | true&gt;; // Relaciones anidadas\n}\n</code></pre> <p>Ejemplos Completos:</p> <pre><code>// Paginaci\u00f3n y ordenamiento\nconst users = await User.where({}, {\n  limit: 10,\n  skip: 20,        // P\u00e1gina 3 (20 registros saltados)\n  order: \"DESC\"\n});\n\n// Selecci\u00f3n de atributos espec\u00edficos\nconst usernames = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\"]\n});\n\n// Solo retorna los campos solicitados\nconsole.log(usernames[0].id);    // \"user-123\"\nconsole.log(usernames[0].name);  // \"John Doe\"\nconsole.log(usernames[0].age);   // undefined (no solicitado)\n\n// Inclusi\u00f3n de relaciones simples\nconst usersWithOrders = await User.where({}, {\n  include: {\n    orders: true  // Incluir todas las \u00f3rdenes\n  }\n});\n\nconsole.log(usersWithOrders[0].orders); // Array de \u00f3rdenes\n\n// Inclusi\u00f3n de relaciones con filtros\nconst usersWithCompletedOrders = await User.where({}, {\n  include: {\n    orders: {\n      where: { status: \"completed\" },\n      limit: 5,\n      order: \"DESC\"\n    }\n  }\n});\n\n// Relaciones anidadas\nconst ordersWithDetails = await Order.where({}, {\n  include: {\n    user: true,              // Incluir usuario\n    items: {                 // Incluir items de orden\n      include: {\n        product: {           // Incluir producto de cada item\n          include: {\n            category: true   // Incluir categor\u00eda de cada producto\n          }\n        }\n      }\n    }\n  }\n});\n\n// Combinaci\u00f3n completa\nconst result = await User.where(\n  { active: true },\n  {\n    attributes: [\"id\", \"name\", \"email\"],\n    limit: 20,\n    skip: 0,\n    order: \"ASC\",\n    include: {\n      orders: {\n        where: { status: \"delivered\" },\n        attributes: [\"id\", \"total\", \"status\"],\n        limit: 10,\n        include: {\n          items: {\n            include: {\n              product: true\n            }\n          }\n        }\n      },\n      reviews: {\n        where: { rating: 5 },\n        limit: 5\n      }\n    }\n  }\n);\n</code></pre>"},{"location":"api/table/#firstmargs-promisem-undefined","title":"<code>first&lt;M&gt;(...args): Promise&lt;M | undefined&gt;</code>","text":"<p>Obtiene el primer registro que coincida con los criterios.</p> <p>Sobrecargas: - <code>first(field, value): Promise&lt;M | undefined&gt;</code> - <code>first(field, operator, value): Promise&lt;M | undefined&gt;</code> - <code>first(filters): Promise&lt;M | undefined&gt;</code></p> <p>Caracter\u00edsticas: - Internamente llama a <code>where()</code> con los mismos argumentos - Retorna solo el primer resultado - Retorna <code>undefined</code> si no se encuentra ning\u00fan registro</p> <p>Ejemplo:</p> <pre><code>// Buscar por campo \u00fanico\nconst user = await User.first(\"id\", \"user-123\");\nif (user) {\n  console.log(user.name);\n}\n\n// Buscar con operador\nconst admin = await User.first(\"role\", \"=\", \"admin\");\n\n// Buscar con m\u00faltiples condiciones\nconst activeAdmin = await User.first({\n  role: \"admin\",\n  active: true\n});\n\n// Verificaci\u00f3n de existencia\nconst exists = (await User.first({ email: \"test@example.com\" })) !== undefined;\n</code></pre>"},{"location":"api/table/#lastmargs-promisem-undefined","title":"<code>last&lt;M&gt;(...args): Promise&lt;M | undefined&gt;</code>","text":"<p>Obtiene el \u00faltimo registro que coincida con los criterios.</p> <p>Sobrecargas: - <code>last(field, value): Promise&lt;M | undefined&gt;</code> - <code>last(field, operator, value): Promise&lt;M | undefined&gt;</code> - <code>last(filters): Promise&lt;M | undefined&gt;</code></p> <p>Caracter\u00edsticas: - Similar a <code>first()</code> pero retorna el \u00faltimo resultado - \u00datil para obtener el registro m\u00e1s reciente - Internamente usa ordenamiento descendente</p> <p>Ejemplo:</p> <pre><code>// Obtener el \u00faltimo usuario creado\nconst latestUser = await User.last({});\n\n// Obtener la \u00faltima orden de un usuario\nconst lastOrder = await Order.last({ user_id: \"user-123\" });\n\n// Con operador\nconst lastHighRating = await Review.last(\"rating\", \"&gt;=\", 4);\n\nif (lastOrder) {\n  console.log(`\u00daltima orden: ${lastOrder.id}`);\n  console.log(`Total: $${lastOrder.total}`);\n}\n</code></pre>"},{"location":"api/table/#ejemplos-de-uso-avanzado","title":"Ejemplos de Uso Avanzado","text":""},{"location":"api/table/#consultas-complejas-con-multiples-condiciones","title":"Consultas Complejas con M\u00faltiples Condiciones","text":"<pre><code>// Buscar usuarios activos con balance alto\nconst premiumUsers = await User.where(\"balance\", \"&gt;\", 1000);\nconst activePremium = premiumUsers.filter(u =&gt; u.active === true);\n\n// Alternativa: usar where anidado\nconst activeUsers = await User.where({ active: true });\nconst activePremiumAlt = activeUsers.filter(u =&gt; (u.balance as number) &gt; 1000);\n</code></pre>"},{"location":"api/table/#paginacion-eficiente","title":"Paginaci\u00f3n Eficiente","text":"<pre><code>async function getPaginatedUsers(page: number, pageSize: number) {\n  const skip = (page - 1) * pageSize;\n\n  const users = await User.where({}, {\n    limit: pageSize,\n    skip: skip,\n    order: \"ASC\"\n  });\n\n  return {\n    page,\n    pageSize,\n    data: users,\n    hasMore: users.length === pageSize\n  };\n}\n\n// Uso\nconst page1 = await getPaginatedUsers(1, 10);\nconst page2 = await getPaginatedUsers(2, 10);\n</code></pre>"},{"location":"api/table/#busqueda-de-texto","title":"B\u00fasqueda de Texto","text":"<pre><code>// Buscar por nombre que contenga un texto\nconst johns = await User.where(\"name\", \"contains\", \"John\");\n\n// Buscar por email que comience con un prefijo\nconst adminEmails = await User.where(\"email\", \"begins-with\", \"admin@\");\n\n// Combinar con otros filtros\nconst activeJohns = johns.filter(u =&gt; u.active === true);\n</code></pre>"},{"location":"api/table/#trabajar-con-relaciones","title":"Trabajar con Relaciones","text":"<pre><code>// HasMany: Un usuario tiene muchas \u00f3rdenes\n@Name(\"users\")\nclass User extends Table&lt;User&gt; {\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: HasMany&lt;Order&gt;;\n}\n\n@Name(\"orders\")\nclass Order extends Table&lt;Order&gt; {\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: BelongsTo&lt;User&gt;;\n}\n\n// Obtener usuario con sus \u00f3rdenes\nconst user = await User.first({ id: \"user-123\" });\nconst userWithOrders = await User.where(\n  { id: \"user-123\" },\n  { include: { orders: true } }\n);\n\nconsole.log(userWithOrders[0].orders); // Array de Order\n\n// Obtener orden con su usuario\nconst orderWithUser = await Order.where(\n  { id: \"order-456\" },\n  { include: { user: true } }\n);\n\nconsole.log(orderWithUser[0].user.name); // Nombre del usuario\n</code></pre>"},{"location":"api/table/#relaciones-anidadas-profundas","title":"Relaciones Anidadas Profundas","text":"<pre><code>// Estructura: User -&gt; Orders -&gt; OrderItems -&gt; Products -&gt; Categories\nconst completeUserData = await User.where(\n  { id: \"user-123\" },\n  {\n    include: {\n      orders: {\n        include: {\n          items: {\n            include: {\n              product: {\n                include: {\n                  category: true\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n);\n\n// Acceder a datos anidados\nconst user = completeUserData[0];\nconst firstOrder = user.orders[0];\nconst firstItem = firstOrder.items[0];\nconst product = firstItem.product;\nconst category = product.category;\n\nconsole.log(`Categor\u00eda: ${category.name}`);\n</code></pre>"},{"location":"api/table/#operaciones-en-batch","title":"Operaciones en Batch","text":"<pre><code>// Crear m\u00faltiples registros\nconst users = await Promise.all([\n  User.create({ email: \"user1@example.com\", name: \"User 1\" }),\n  User.create({ email: \"user2@example.com\", name: \"User 2\" }),\n  User.create({ email: \"user3@example.com\", name: \"User 3\" })\n]);\n\n// Actualizar m\u00faltiples registros\nawait User.update(\n  { verified: true },\n  { registrationDate: \"2025-01-01\" }\n);\n\n// Eliminar m\u00faltiples registros\nawait User.delete({ status: \"inactive\" });\n</code></pre>"},{"location":"api/table/#validacion-y-manejo-de-errores","title":"Validaci\u00f3n y Manejo de Errores","text":"<pre><code>try {\n  const user = await User.create({\n    email: \"invalid-email\",  // Email inv\u00e1lido\n    name: \"Test User\"\n  });\n} catch (error) {\n  console.error(`Validaci\u00f3n fallida: ${error.message}`);\n  // \"Validaci\u00f3n fallida: Email inv\u00e1lido\"\n}\n\n// Verificar existencia antes de actualizar\nconst user = await User.first({ id: \"user-123\" });\nif (user) {\n  await user.update({ name: \"New Name\" });\n} else {\n  console.log(\"Usuario no encontrado\");\n}\n</code></pre>"},{"location":"api/table/#seleccion-parcial-de-campos","title":"Selecci\u00f3n Parcial de Campos","text":"<pre><code>// Solo obtener campos espec\u00edficos (reduce transferencia de datos)\nconst lightUsers = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\"]\n});\n\n// Los campos no solicitados ser\u00e1n undefined\nconsole.log(lightUsers[0].id);      // \"user-123\"\nconsole.log(lightUsers[0].name);    // \"John Doe\"\nconsole.log(lightUsers[0].age);     // undefined\nconsole.log(lightUsers[0].balance); // undefined\n</code></pre>"},{"location":"api/table/#inferencia-de-tipos","title":"Inferencia de Tipos","text":"<p>Dynamite ORM proporciona inferencia de tipos completa con TypeScript.</p>"},{"location":"api/table/#inferattributes","title":"InferAttributes <p>Extrae solo los atributos (excluye m\u00e9todos y relaciones).</p> <pre><code>import type { InferAttributes } from '@arcaelas/dynamite';\n\ntype UserAttributes = InferAttributes&lt;User&gt;;\n// {\n//   id: string;\n//   email: string;\n//   name: string;\n//   age: number;\n//   createdAt: string;\n//   updatedAt: string;\n// }\n\n// Uso en funciones\nfunction createUser(data: InferAttributes&lt;User&gt;) {\n  return User.create(data);\n}\n</code></pre>","text":""},{"location":"api/table/#creationoptional","title":"CreationOptional <p>Marca campos que son opcionales durante la creaci\u00f3n (tienen valores por defecto).</p> <pre><code>import { CreationOptional } from '@arcaelas/dynamite';\n\n@Name(\"products\")\nclass Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare name: string;\n\n  @Default(() =&gt; 0)\n  declare stock: CreationOptional&lt;number&gt;; // Opcional en create()\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n}\n\n// TypeScript permite omitir campos CreationOptional\nawait Product.create({\n  id: \"prod-123\",\n  name: \"Product Name\"\n  // stock y active son opcionales\n});\n</code></pre>","text":""},{"location":"api/table/#tipos-de-relaciones","title":"Tipos de Relaciones <pre><code>import { HasMany, BelongsTo } from '@arcaelas/dynamite';\n\n@Name(\"users\")\nclass User extends Table&lt;User&gt; {\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: HasMany&lt;Order&gt;; // Array de Order\n\n  @HasMany(() =&gt; Review, \"user_id\")\n  declare reviews: HasMany&lt;Review&gt;;\n}\n\n@Name(\"orders\")\nclass Order extends Table&lt;Order&gt; {\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: BelongsTo&lt;User&gt;; // User o null\n}\n</code></pre>","text":""},{"location":"api/table/#manejo-de-errores","title":"Manejo de Errores","text":""},{"location":"api/table/#errores-comunes","title":"Errores Comunes <pre><code>// 1. Validaci\u00f3n fallida\ntry {\n  await User.create({\n    email: \"invalid\",\n    name: \"Test\"\n  });\n} catch (error) {\n  // ValidationError: Email inv\u00e1lido\n}\n\n// 2. Campo requerido faltante\ntry {\n  await User.create({\n    name: \"Test\"\n    // email es @NotNull y falta\n  });\n} catch (error) {\n  // ValidationError: email es requerido\n}\n\n// 3. Intentar destruir sin id\nconst user = new User({ email: \"test@example.com\", name: \"Test\" });\ntry {\n  await user.destroy();\n} catch (error) {\n  // Error: destroy() requiere que la instancia tenga un id\n}\n\n// 4. Operador inv\u00e1lido\ntry {\n  await User.where(\"age\", \"===\", 25); // Operador inv\u00e1lido\n} catch (error) {\n  // Error: Operador inv\u00e1lido: ===\n}\n</code></pre>","text":""},{"location":"api/table/#buenas-practicas-de-manejo-de-errores","title":"Buenas Pr\u00e1cticas de Manejo de Errores <pre><code>async function safeCreateUser(data: InferAttributes&lt;User&gt;) {\n  try {\n    const user = await User.create(data);\n    return { success: true, data: user };\n  } catch (error) {\n    console.error(\"Error creating user:\", error);\n    return { success: false, error: error.message };\n  }\n}\n\n// Uso\nconst result = await safeCreateUser({\n  email: \"test@example.com\",\n  name: \"Test User\"\n});\n\nif (result.success) {\n  console.log(`Usuario creado: ${result.data.id}`);\n} else {\n  console.log(`Error: ${result.error}`);\n}\n</code></pre>","text":""},{"location":"api/table/#rendimiento-y-optimizacion","title":"Rendimiento y Optimizaci\u00f3n","text":""},{"location":"api/table/#1-seleccion-de-atributos-especificos","title":"1. Selecci\u00f3n de Atributos Espec\u00edficos <p>Reduce la transferencia de datos seleccionando solo los campos necesarios:</p> <pre><code>// \u274c Mal: Obtiene todos los campos (incluye campos grandes innecesarios)\nconst users = await User.where({});\n\n// \u2705 Bien: Solo campos necesarios\nconst users = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\"]\n});\n</code></pre>","text":""},{"location":"api/table/#2-paginacion-efectiva","title":"2. Paginaci\u00f3n Efectiva <pre><code>// \u2705 Usar limit para evitar cargar demasiados registros\nconst users = await User.where({}, {\n  limit: 20,\n  skip: (page - 1) * 20\n});\n</code></pre>","text":""},{"location":"api/table/#3-inclusion-selectiva-de-relaciones","title":"3. Inclusi\u00f3n Selectiva de Relaciones <pre><code>// \u274c Mal: Incluir todas las relaciones siempre\nconst users = await User.where({}, {\n  include: {\n    orders: true,\n    reviews: true,\n    notifications: true\n  }\n});\n\n// \u2705 Bien: Solo incluir relaciones necesarias con l\u00edmites\nconst users = await User.where({}, {\n  include: {\n    orders: {\n      limit: 5,\n      order: \"DESC\"\n    }\n  }\n});\n</code></pre>","text":""},{"location":"api/table/#4-operaciones-en-batch","title":"4. Operaciones en Batch <pre><code>// \u2705 Crear m\u00faltiples registros en paralelo\nawait Promise.all([\n  User.create({ email: \"user1@example.com\", name: \"User 1\" }),\n  User.create({ email: \"user2@example.com\", name: \"User 2\" }),\n  User.create({ email: \"user3@example.com\", name: \"User 3\" })\n]);\n</code></pre>","text":""},{"location":"api/table/#restricciones-y-limitaciones","title":"Restricciones y Limitaciones","text":""},{"location":"api/table/#1-consultas-and-vs-or","title":"1. Consultas AND vs OR <ul> <li><code>where()</code> con m\u00faltiples campos usa operador <code>AND</code> impl\u00edcito</li> <li>No hay soporte nativo para operador <code>OR</code> en un solo <code>where()</code></li> <li>Soluci\u00f3n: Realizar m\u00faltiples consultas y combinar resultados</li> </ul> <pre><code>// Solo soporta AND\nconst result = await User.where({\n  role: \"admin\",\n  active: true  // AND active = true\n});\n\n// Para OR, hacer m\u00faltiples consultas\nconst admins = await User.where({ role: \"admin\" });\nconst employees = await User.where({ role: \"employee\" });\nconst staff = [...admins, ...employees];\n</code></pre>","text":""},{"location":"api/table/#2-profundidad-de-relaciones","title":"2. Profundidad de Relaciones <ul> <li>Las relaciones anidadas pueden aumentar el tiempo de consulta exponencialmente</li> <li>Recomendaci\u00f3n: Limitar a 3-4 niveles de profundidad</li> <li>Usar <code>limit</code> en relaciones anidadas</li> </ul>","text":""},{"location":"api/table/#3-scan-vs-query","title":"3. Scan vs Query <ul> <li><code>where()</code> internamente usa <code>ScanCommand</code> de DynamoDB</li> <li>Los scans son m\u00e1s lentos que queries pero m\u00e1s flexibles</li> <li>Para mejor rendimiento, considerar \u00edndices en DynamoDB</li> </ul>","text":""},{"location":"api/table/#migracion-y-compatibilidad","title":"Migraci\u00f3n y Compatibilidad","text":""},{"location":"api/table/#desde-otros-orms","title":"Desde otros ORMs <p>Sequelize:</p> <pre><code>// Sequelize\nconst users = await User.findAll({ where: { role: \"admin\" } });\n\n// Dynamite\nconst users = await User.where({ role: \"admin\" });\n</code></pre> <p>TypeORM:</p> <pre><code>// TypeORM\nconst users = await userRepository.find({ where: { role: \"admin\" } });\n\n// Dynamite\nconst users = await User.where({ role: \"admin\" });\n</code></pre>","text":""},{"location":"api/table/#changelog-de-versiones","title":"Changelog de Versiones","text":""},{"location":"api/table/#v100","title":"v1.0.0 <ul> <li>\u2705 Implementaci\u00f3n completa de m\u00e9todos CRUD</li> <li>\u2705 Soporte para relaciones HasMany y BelongsTo</li> <li>\u2705 Sistema de validaciones y mutaciones</li> <li>\u2705 Paginaci\u00f3n y ordenamiento</li> <li>\u2705 Selecci\u00f3n de atributos espec\u00edficos</li> <li>\u2705 Inclusi\u00f3n de relaciones anidadas</li> <li>\u2705 Timestamps autom\u00e1ticos (createdAt/updatedAt)</li> </ul>","text":""},{"location":"api/table/#archivo-fuente","title":"Archivo Fuente","text":"<p>Ubicaci\u00f3n: <code>/tmp/dynamite/src/core/table.ts</code> L\u00edneas de c\u00f3digo: 636 l\u00edneas \u00daltima actualizaci\u00f3n: 2025-07-30</p>"},{"location":"api/table/#soporte-y-contribucion","title":"Soporte y Contribuci\u00f3n","text":"<ul> <li>Documentaci\u00f3n completa: https://github.com/arcaelas/dynamite</li> <li>Reportar bugs: https://github.com/arcaelas/dynamite/issues</li> <li>Discusiones: https://github.com/arcaelas/dynamite/discussions</li> </ul> <p>Nota: Este documento fue generado a partir del c\u00f3digo fuente real en <code>/tmp/dynamite/src/core/table.ts</code>. Para cualquier discrepancia, consulta el c\u00f3digo fuente como fuente de verdad.</p>"},{"location":"api/types/","title":"Referencia de API: Tipos","text":"<p>Esta gu\u00eda documenta todos los tipos TypeScript exportados por Dynamite ORM que permiten crear modelos con type-safety completo.</p>"},{"location":"api/types/#tabla-de-contenidos","title":"Tabla de Contenidos","text":"<ul> <li>Tipos de Marca de Atributos</li> <li>CreationOptional\\&lt;T&gt;</li> <li>NonAttribute\\&lt;T&gt;</li> <li>Tipos de Inferencia</li> <li>InferAttributes\\&lt;T&gt;</li> <li>FilterableAttributes\\&lt;T&gt;</li> <li>Tipos de Relaciones</li> <li>HasMany\\&lt;T&gt;</li> <li>BelongsTo\\&lt;T&gt;</li> <li>Tipos de Consultas</li> <li>QueryOperator</li> <li>QueryResult\\&lt;T, A, I&gt;</li> <li>WhereOptions\\&lt;T&gt;</li> <li>WhereOptionsWithoutWhere\\&lt;T&gt;</li> </ul>"},{"location":"api/types/#tipos-de-marca-de-atributos","title":"Tipos de Marca de Atributos","text":""},{"location":"api/types/#creationoptionalt","title":"CreationOptional\\&lt;T&gt;","text":"<p>Marca un campo como opcional durante la creaci\u00f3n pero presente despu\u00e9s de guardar. Usar para campos con valores por defecto, auto-generados o auto-calculados.</p> <p>Sintaxis: <pre><code>declare field_name: CreationOptional&lt;Type&gt;;\n</code></pre></p> <p>Caracter\u00edsticas: - Campo opcional al llamar <code>Model.create()</code> - Campo presente en la instancia despu\u00e9s de guardar - Ideal para IDs auto-generados, timestamps y valores por defecto</p> <p>Ejemplos:</p> <pre><code>import { Table, PrimaryKey, Default, CreatedAt, UpdatedAt, CreationOptional } from '@arcaelas/dynamite';\n\nclass User extends Table&lt;User&gt; {\n  // ID auto-generado - SIEMPRE usar CreationOptional\n  @PrimaryKey()\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Campo requerido durante creaci\u00f3n\n  @NotNull()\n  declare email: string;\n\n  // Campo con valor por defecto - usar CreationOptional\n  @Default(() =&gt; 'customer')\n  declare role: CreationOptional&lt;string&gt;;\n\n  // Booleano con valor por defecto - usar CreationOptional\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  // Num\u00e9rico con valor por defecto - usar CreationOptional\n  @Default(() =&gt; 0)\n  declare balance: CreationOptional&lt;number&gt;;\n\n  // Timestamps auto-generados - SIEMPRE usar CreationOptional\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n}\n\n// Durante creaci\u00f3n: solo campos requeridos\nconst user = await User.create({\n  email: 'user@test.com'\n  // id, role, active, balance, createdAt, updatedAt son opcionales\n});\n\n// Despu\u00e9s de guardar: todos los campos est\u00e1n presentes\nconsole.log(user.id);        // string (auto-generado)\nconsole.log(user.role);      // 'customer' (valor por defecto)\nconsole.log(user.active);    // true (valor por defecto)\nconsole.log(user.balance);   // 0 (valor por defecto)\nconsole.log(user.createdAt); // string (timestamp auto-generado)\nconsole.log(user.updatedAt); // string (timestamp auto-generado)\n</code></pre> <p>Regla de uso:</p> <p>Usar <code>CreationOptional&lt;T&gt;</code> para: 1. Campos con decorador <code>@PrimaryKey()</code> (IDs auto-generados) 2. Campos con decorador <code>@Default()</code> (valores por defecto) 3. Campos con decorador <code>@CreatedAt()</code> o <code>@UpdatedAt()</code> (timestamps) 4. Cualquier campo calculado autom\u00e1ticamente por el sistema</p>"},{"location":"api/types/#nonattributet","title":"NonAttribute\\&lt;T&gt;","text":"<p>Marca un campo como no persistente en la base de datos. Usar para propiedades calculadas, getters, m\u00e9todos o datos temporales.</p> <p>Sintaxis: <pre><code>declare field_name: NonAttribute&lt;Type&gt;;\n</code></pre></p> <p>Caracter\u00edsticas: - Campo NO se guarda en DynamoDB - Campo NO se incluye en queries - Ideal para propiedades computadas, getters y m\u00e9todos de instancia - Se excluye autom\u00e1ticamente de <code>InferAttributes&lt;T&gt;</code></p> <p>Ejemplos:</p> <pre><code>import { Table, PrimaryKey, NotNull, NonAttribute } from '@arcaelas/dynamite';\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare first_name: string;\n\n  @NotNull()\n  declare last_name: string;\n\n  @NotNull()\n  declare birth_date: string;\n\n  // Propiedad computada - NO se persiste\n  declare full_name: NonAttribute&lt;string&gt;;\n\n  // Propiedad computada - NO se persiste\n  declare age: NonAttribute&lt;number&gt;;\n\n  // M\u00e9todo de instancia - NO se persiste\n  declare get_display_name: NonAttribute&lt;() =&gt; string&gt;;\n\n  constructor(data: any) {\n    super(data);\n\n    // Calcular propiedades computadas\n    this.full_name = `${this.first_name} ${this.last_name}`;\n\n    const birth = new Date(this.birth_date);\n    const today = new Date();\n    this.age = today.getFullYear() - birth.getFullYear();\n\n    // Definir m\u00e9todo de instancia\n    this.get_display_name = () =&gt; {\n      return `${this.full_name} (${this.age} a\u00f1os)`;\n    };\n  }\n}\n\nconst user = await User.create({\n  id: 'user-1',\n  first_name: 'Juan',\n  last_name: 'P\u00e9rez',\n  birth_date: '1990-05-15'\n});\n\n// Propiedades computadas disponibles\nconsole.log(user.full_name);           // 'Juan P\u00e9rez'\nconsole.log(user.age);                 // 34\nconsole.log(user.get_display_name());  // 'Juan P\u00e9rez (34 a\u00f1os)'\n\n// Pero NO se guardan en la base de datos\n// Solo se persisten: id, first_name, last_name, birth_date\n</code></pre> <p>Casos de uso:</p> <pre><code>class Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare name: string;\n\n  @NotNull()\n  declare price: number;\n\n  @Default(() =&gt; 0)\n  declare discount: CreationOptional&lt;number&gt;;\n\n  // Precio final calculado - NonAttribute\n  declare final_price: NonAttribute&lt;number&gt;;\n\n  // Indicador si est\u00e1 en oferta - NonAttribute\n  declare is_on_sale: NonAttribute&lt;boolean&gt;;\n\n  // M\u00e9todo para aplicar descuento - NonAttribute\n  declare apply_discount: NonAttribute&lt;(additional: number) =&gt; number&gt;;\n\n  constructor(data: any) {\n    super(data);\n\n    this.final_price = this.price * (1 - (this.discount ?? 0) / 100);\n    this.is_on_sale = (this.discount ?? 0) &gt; 0;\n\n    this.apply_discount = (additional: number) =&gt; {\n      const total_discount = (this.discount ?? 0) + additional;\n      return this.price * (1 - total_discount / 100);\n    };\n  }\n}\n\nconst product = await Product.create({\n  id: 'prod-1',\n  name: 'Laptop',\n  price: 1000,\n  discount: 10\n});\n\nconsole.log(product.final_price);        // 900 (calculado)\nconsole.log(product.is_on_sale);         // true (calculado)\nconsole.log(product.apply_discount(5));  // 850 (m\u00e9todo)\n</code></pre>"},{"location":"api/types/#tipos-de-inferencia","title":"Tipos de Inferencia","text":""},{"location":"api/types/#inferattributest","title":"InferAttributes\\&lt;T&gt;","text":"<p>Infiere autom\u00e1ticamente los atributos persistentes de un modelo, excluyendo relaciones, m\u00e9todos y campos <code>NonAttribute</code>.</p> <p>Sintaxis: <pre><code>type ModelAttributes = InferAttributes&lt;ModelClass&gt;;\n</code></pre></p> <p>Caracter\u00edsticas: - Excluye autom\u00e1ticamente relaciones (<code>HasMany</code>, <code>BelongsTo</code>) - Excluye autom\u00e1ticamente campos <code>NonAttribute</code> - Excluye autom\u00e1ticamente m\u00e9todos - Incluye solo campos que se persisten en DynamoDB - Usado internamente por <code>where()</code>, <code>create()</code>, <code>update()</code></p> <p>Ejemplos:</p> <pre><code>import { Table, PrimaryKey, NotNull, HasMany, BelongsTo, NonAttribute, InferAttributes } from '@arcaelas/dynamite';\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare email: string;\n\n  @NotNull()\n  declare name: string;\n\n  @Default(() =&gt; 'customer')\n  declare role: CreationOptional&lt;string&gt;;\n\n  // Relaci\u00f3n - NO es atributo persistente\n  @HasMany(() =&gt; Order, 'user_id')\n  declare orders: any;\n\n  // Campo computado - NO es atributo persistente\n  declare display_name: NonAttribute&lt;string&gt;;\n}\n\n// InferAttributes excluye 'orders' y 'display_name'\ntype UserAttributes = InferAttributes&lt;User&gt;;\n// Equivale a:\n// {\n//   id: string;\n//   email: string;\n//   name: string;\n//   role: string | undefined;\n// }\n\n// Uso en queries\nconst users = await User.where({\n  role: 'customer',\n  // orders: {} // \u274c Error: 'orders' no es atributo filtrable\n  // display_name: 'X' // \u274c Error: 'display_name' no es atributo filtrable\n});\n\n// Uso en updates\nawait User.update(\n  {\n    name: 'Nuevo Nombre',\n    // orders: [] // \u274c Error: no se puede actualizar relaci\u00f3n\n    // display_name: 'X' // \u274c Error: no se puede actualizar NonAttribute\n  },\n  { id: 'user-1' }\n);\n</code></pre> <p>Uso interno:</p> <pre><code>// Dynamite usa InferAttributes internamente\nclass Table&lt;T&gt; {\n  // Constructor solo acepta atributos persistentes\n  constructor(data: InferAttributes&lt;T&gt;) { }\n\n  // where() solo acepta atributos persistentes como filtros\n  static async where&lt;M extends Table&gt;(\n    this: { new (data: InferAttributes&lt;M&gt;): M },\n    filters: Partial&lt;InferAttributes&lt;M&gt;&gt;\n  ): Promise&lt;M[]&gt; { }\n\n  // update() solo permite actualizar atributos persistentes\n  static async update&lt;M extends Table&gt;(\n    this: { new (data: InferAttributes&lt;M&gt;): M },\n    updates: Partial&lt;InferAttributes&lt;M&gt;&gt;,\n    filters: Partial&lt;InferAttributes&lt;M&gt;&gt;\n  ): Promise&lt;number&gt; { }\n}\n</code></pre>"},{"location":"api/types/#filterableattributest","title":"FilterableAttributes\\&lt;T&gt;","text":"<p>Alias de <code>InferAttributes&lt;T&gt;</code> que representa atributos que pueden usarse en filtros de consultas.</p> <p>Sintaxis: <pre><code>type Filterable = FilterableAttributes&lt;ModelClass&gt;;\n</code></pre></p> <p>Caracter\u00edsticas: - Es equivalente a <code>InferAttributes&lt;T&gt;</code> - Usado en <code>WhereOptions&lt;T&gt;</code> para validar filtros - M\u00e1s sem\u00e1ntico cuando se usa en contexto de queries</p> <p>Ejemplos:</p> <pre><code>import { Table, PrimaryKey, NotNull, FilterableAttributes } from '@arcaelas/dynamite';\n\nclass Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare name: string;\n\n  @NotNull()\n  declare price: number;\n\n  @Default(() =&gt; 0)\n  declare stock: CreationOptional&lt;number&gt;;\n\n  @HasMany(() =&gt; Review, 'product_id')\n  declare reviews: any;\n}\n\n// FilterableAttributes solo incluye campos persistentes\ntype ProductFilters = FilterableAttributes&lt;Product&gt;;\n// Equivale a:\n// {\n//   id: string;\n//   name: string;\n//   price: number;\n//   stock: number | undefined;\n// }\n\n// Uso en queries con type-safety\nconst filters: Partial&lt;ProductFilters&gt; = {\n  price: 100,\n  stock: 50,\n  // reviews: [] // \u274c Error: 'reviews' no es filtrable\n};\n\nconst products = await Product.where(filters);\n</code></pre>"},{"location":"api/types/#tipos-de-relaciones","title":"Tipos de Relaciones","text":""},{"location":"api/types/#hasmanyt","title":"HasMany\\&lt;T&gt;","text":"<p>Representa una relaci\u00f3n uno-a-muchos donde el modelo actual tiene m\u00faltiples instancias del modelo relacionado.</p> <p>Sintaxis: <pre><code>@HasMany(() =&gt; RelatedModel, 'foreign_key')\ndeclare relation_name: any;\n</code></pre></p> <p>Caracter\u00edsticas: - Retorna array de instancias del modelo relacionado - Se carga mediante opci\u00f3n <code>include</code> en queries - Soporta filtros, l\u00edmites y ordenamiento en la relaci\u00f3n - Implementa lazy loading autom\u00e1tico</p> <p>Ejemplos b\u00e1sicos:</p> <pre><code>import { Table, PrimaryKey, NotNull, HasMany } from '@arcaelas/dynamite';\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare name: string;\n\n  // Un usuario tiene muchas \u00f3rdenes\n  @HasMany(() =&gt; Order, 'user_id')\n  declare orders: any;\n\n  // Un usuario tiene muchas reviews\n  @HasMany(() =&gt; Review, 'user_id')\n  declare reviews: any;\n}\n\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare user_id: string;\n\n  @NotNull()\n  declare total: number;\n\n  // Una orden tiene muchos items\n  @HasMany(() =&gt; OrderItem, 'order_id')\n  declare items: any;\n}\n\nclass OrderItem extends Table&lt;OrderItem&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare order_id: string;\n\n  @NotNull()\n  declare product_id: string;\n\n  @NotNull()\n  declare quantity: number;\n}\n\nclass Review extends Table&lt;Review&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare user_id: string;\n\n  @NotNull()\n  declare product_id: string;\n\n  @NotNull()\n  declare rating: number;\n}\n</code></pre> <p>Ejemplos de uso:</p> <pre><code>// 1. Include simple\nconst users = await User.where({}, {\n  include: {\n    orders: {}\n  }\n});\n\nusers.forEach(user =&gt; {\n  console.log(user.name);\n  console.log(user.orders); // Array de Order[]\n});\n\n// 2. Include con filtros\nconst users_with_pending = await User.where({}, {\n  include: {\n    orders: {\n      where: { status: 'pending' },\n      limit: 10,\n      order: 'DESC'\n    }\n  }\n});\n\n// 3. Include con m\u00faltiples relaciones\nconst users_full = await User.where({ id: 'user-1' }, {\n  include: {\n    orders: {\n      include: {\n        items: {} // Relaci\u00f3n anidada\n      }\n    },\n    reviews: {\n      where: { rating: 5 }\n    }\n  }\n});\n\nconsole.log(users_full[0].orders);        // Order[]\nconsole.log(users_full[0].orders[0].items); // OrderItem[]\nconsole.log(users_full[0].reviews);       // Review[]\n\n// 4. Include con atributos selectivos\nconst users_minimal = await User.where({}, {\n  attributes: ['id', 'name'],\n  include: {\n    orders: {\n      attributes: ['id', 'total', 'status']\n    }\n  }\n});\n</code></pre> <p>Opciones de relaci\u00f3n HasMany:</p> <pre><code>interface IncludeOptions {\n  where?: Record&lt;string, any&gt;;    // Filtros para la relaci\u00f3n\n  attributes?: string[];          // Campos a seleccionar\n  limit?: number;                 // L\u00edmite de resultados\n  skip?: number;                  // Offset para paginaci\u00f3n\n  order?: 'ASC' | 'DESC';         // Ordenamiento\n  include?: Record&lt;string, any&gt;;  // Relaciones anidadas\n}\n</code></pre>"},{"location":"api/types/#belongstot","title":"BelongsTo\\&lt;T&gt;","text":"<p>Representa una relaci\u00f3n muchos-a-uno donde el modelo actual pertenece a una instancia del modelo relacionado.</p> <p>Sintaxis: <pre><code>@BelongsTo(() =&gt; RelatedModel, 'local_key')\ndeclare relation_name: any;\n</code></pre></p> <p>Caracter\u00edsticas: - Retorna una instancia del modelo relacionado o <code>null</code> - Se carga mediante opci\u00f3n <code>include</code> en queries - Usa la clave local (foreign key) para encontrar el registro relacionado - Soporta relaciones anidadas</p> <p>Ejemplos b\u00e1sicos:</p> <pre><code>import { Table, PrimaryKey, NotNull, BelongsTo } from '@arcaelas/dynamite';\n\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare user_id: string;\n\n  @NotNull()\n  declare total: number;\n\n  // Una orden pertenece a un usuario\n  @BelongsTo(() =&gt; User, 'user_id')\n  declare user: any;\n}\n\nclass Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare category_id: string;\n\n  @NotNull()\n  declare name: string;\n\n  // Un producto pertenece a una categor\u00eda\n  @BelongsTo(() =&gt; Category, 'category_id')\n  declare category: any;\n}\n\nclass OrderItem extends Table&lt;OrderItem&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare order_id: string;\n\n  @NotNull()\n  declare product_id: string;\n\n  // Un item pertenece a una orden\n  @BelongsTo(() =&gt; Order, 'order_id')\n  declare order: any;\n\n  // Un item pertenece a un producto\n  @BelongsTo(() =&gt; Product, 'product_id')\n  declare product: any;\n}\n\nclass Category extends Table&lt;Category&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare name: string;\n}\n</code></pre> <p>Ejemplos de uso:</p> <pre><code>// 1. Include simple\nconst orders = await Order.where({}, {\n  include: {\n    user: {}\n  }\n});\n\norders.forEach(order =&gt; {\n  console.log(order.total);\n  console.log(order.user.name); // User | null\n});\n\n// 2. Include con relaciones anidadas\nconst products = await Product.where({}, {\n  include: {\n    category: {}\n  }\n});\n\nproducts.forEach(product =&gt; {\n  console.log(product.name);\n  if (product.category) {\n    console.log(product.category.name);\n  }\n});\n\n// 3. Include m\u00faltiples BelongsTo\nconst items = await OrderItem.where({}, {\n  include: {\n    order: {\n      include: {\n        user: {} // Relaci\u00f3n anidada\n      }\n    },\n    product: {\n      include: {\n        category: {} // Relaci\u00f3n anidada\n      }\n    }\n  }\n});\n\nitems.forEach(item =&gt; {\n  console.log(item.order.user.name);      // Usuario de la orden\n  console.log(item.product.category.name); // Categor\u00eda del producto\n});\n\n// 4. Include con filtros en relaci\u00f3n padre\nconst recent_orders = await Order.where(\n  { status: 'delivered' },\n  {\n    include: {\n      user: {\n        where: { active: true }\n      }\n    }\n  }\n);\n</code></pre> <p>Manejo de valores nulos:</p> <pre><code>const products = await Product.where({}, {\n  include: {\n    category: {}\n  }\n});\n\nproducts.forEach(product =&gt; {\n  // BelongsTo puede retornar null si la relaci\u00f3n no existe\n  if (product.category) {\n    console.log(product.category.name);\n  } else {\n    console.log('Producto sin categor\u00eda');\n  }\n});\n</code></pre>"},{"location":"api/types/#tipos-de-consultas","title":"Tipos de Consultas","text":""},{"location":"api/types/#queryoperator","title":"QueryOperator","text":"<p>Operadores disponibles para filtros en consultas where.</p> <p>Sintaxis: <pre><code>type QueryOperator =\n  | '='           // Igual\n  | '!='          // Diferente\n  | '&lt;'           // Menor que\n  | '&lt;='          // Menor o igual\n  | '&gt;'           // Mayor que\n  | '&gt;='          // Mayor o igual\n  | 'in'          // En array\n  | 'not-in'      // No en array\n  | 'contains'    // Contiene (strings)\n  | 'begins-with' // Comienza con (strings)\n</code></pre></p> <p>Ejemplos:</p> <pre><code>import { Table, PrimaryKey, NotNull } from '@arcaelas/dynamite';\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare name: string;\n\n  @NotNull()\n  declare email: string;\n\n  @NotNull()\n  declare age: number;\n\n  @NotNull()\n  declare role: string;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n}\n\n// Operador '=' (impl\u00edcito)\nconst admins = await User.where('role', 'admin');\nconst admins2 = await User.where('role', '=', 'admin');\n\n// Operador '!='\nconst non_admins = await User.where('role', '!=', 'admin');\n\n// Operadores num\u00e9ricos\nconst adults = await User.where('age', '&gt;=', 18);\nconst young = await User.where('age', '&lt;', 30);\nconst specific_age = await User.where('age', '&gt;', 25);\nconst age_limit = await User.where('age', '&lt;=', 65);\n\n// Operador 'in'\nconst staff = await User.where('role', 'in', ['admin', 'employee']);\nconst staff2 = await User.where('role', ['admin', 'employee']); // Atajo\n\n// Operador 'not-in'\nconst customers = await User.where('role', 'not-in', ['admin', 'employee']);\n\n// Operador 'contains' (strings)\nconst gmail_users = await User.where('email', 'contains', '@gmail.com');\nconst name_with_a = await User.where('name', 'contains', 'a');\n\n// Operador 'begins-with' (strings)\nconst admins_by_email = await User.where('email', 'begins-with', 'admin@');\nconst a_names = await User.where('name', 'begins-with', 'A');\n</code></pre> <p>Combinaci\u00f3n de operadores:</p> <pre><code>// M\u00faltiples condiciones con objeto\nconst active_admins = await User.where({\n  role: 'admin',\n  active: true\n});\n\n// Operadores en cadena\nconst young_admins = await User.where('age', '&lt;', 30);\nconst active_young_admins = young_admins.filter(u =&gt; u.active);\n\n// Operadores con opciones\nconst paginated = await User.where(\n  'age',\n  '&gt;=',\n  18,\n  {\n    limit: 10,\n    skip: 20,\n    order: 'DESC'\n  }\n);\n</code></pre>"},{"location":"api/types/#queryresultt-a-i","title":"QueryResult\\&lt;T, A, I&gt;","text":"<p>Tipo del resultado de una consulta con includes y selecci\u00f3n de atributos.</p> <p>Sintaxis: <pre><code>type Result = QueryResult&lt;Model, Attributes, Includes&gt;;\n</code></pre></p> <p>Par\u00e1metros: - <code>T</code>: Clase del modelo - <code>A</code>: Atributos seleccionados (keys de T) - <code>I</code>: Relaciones incluidas (objeto de configuraci\u00f3n de includes)</p> <p>Caracter\u00edsticas: - Infiere autom\u00e1ticamente el tipo de retorno basado en includes - Type-safety completo para relaciones incluidas - Soporta selecci\u00f3n parcial de atributos</p> <p>Ejemplos:</p> <pre><code>import { Table, PrimaryKey, NotNull, HasMany, BelongsTo, QueryResult } from '@arcaelas/dynamite';\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare name: string;\n\n  @NotNull()\n  declare email: string;\n\n  @HasMany(() =&gt; Order, 'user_id')\n  declare orders: any;\n}\n\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare user_id: string;\n\n  @NotNull()\n  declare total: number;\n\n  @BelongsTo(() =&gt; User, 'user_id')\n  declare user: any;\n\n  @HasMany(() =&gt; OrderItem, 'order_id')\n  declare items: any;\n}\n\nclass OrderItem extends Table&lt;OrderItem&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare order_id: string;\n\n  @NotNull()\n  declare quantity: number;\n}\n\n// Ejemplo 1: Sin includes\nconst users1 = await User.where({});\n// Tipo: User[]\n\n// Ejemplo 2: Con include simple\nconst users2 = await User.where({}, {\n  include: {\n    orders: {}\n  }\n});\n// Tipo inferido:\n// (User &amp; { orders: Order[] })[]\n\n// Ejemplo 3: Con selecci\u00f3n de atributos\nconst users3 = await User.where({}, {\n  attributes: ['id', 'name']\n});\n// Tipo inferido:\n// Pick&lt;User, 'id' | 'name'&gt;[]\n\n// Ejemplo 4: Con includes anidados\nconst users4 = await User.where({}, {\n  include: {\n    orders: {\n      include: {\n        items: {}\n      }\n    }\n  }\n});\n// Tipo inferido:\n// (User &amp; {\n//   orders: (Order &amp; {\n//     items: OrderItem[]\n//   })[]\n// })[]\n\n// Uso con type-safety\nusers4.forEach(user =&gt; {\n  console.log(user.name);      // \u2713 Type-safe\n  console.log(user.orders);    // \u2713 Order[]\n  user.orders.forEach(order =&gt; {\n    console.log(order.items);  // \u2713 OrderItem[]\n  });\n});\n</code></pre>"},{"location":"api/types/#whereoptionst","title":"WhereOptions\\&lt;T&gt;","text":"<p>Opciones completas para consultas where, incluyendo filtros, paginaci\u00f3n, ordenamiento e includes.</p> <p>Sintaxis: <pre><code>interface WhereOptions&lt;T&gt; {\n  where?: Partial&lt;FilterableAttributes&lt;T&gt;&gt;;\n  skip?: number;\n  limit?: number;\n  order?: 'ASC' | 'DESC';\n  attributes?: (keyof FilterableAttributes&lt;T&gt;)[];\n  include?: {\n    [K in keyof T]?: T[K] extends HasMany&lt;any&gt; | BelongsTo&lt;any&gt;\n      ? IncludeOptions | {}\n      : never;\n  };\n}\n</code></pre></p> <p>Propiedades:</p> Propiedad Tipo Descripci\u00f3n <code>where</code> <code>Partial&lt;FilterableAttributes&lt;T&gt;&gt;</code> Filtros para la consulta <code>skip</code> <code>number</code> Offset para paginaci\u00f3n <code>limit</code> <code>number</code> L\u00edmite de resultados <code>order</code> <code>'ASC' \\| 'DESC'</code> Ordenamiento por clave primaria <code>attributes</code> <code>(keyof FilterableAttributes&lt;T&gt;)[]</code> Campos a seleccionar <code>include</code> <code>object</code> Relaciones a incluir <p>Ejemplos:</p> <pre><code>import { Table, PrimaryKey, NotNull, HasMany, WhereOptions } from '@arcaelas/dynamite';\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare name: string;\n\n  @NotNull()\n  declare email: string;\n\n  @NotNull()\n  declare age: number;\n\n  @Default(() =&gt; 'customer')\n  declare role: CreationOptional&lt;string&gt;;\n\n  @HasMany(() =&gt; Order, 'user_id')\n  declare orders: any;\n}\n\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare user_id: string;\n\n  @NotNull()\n  declare total: number;\n}\n\n// Ejemplo 1: Solo filtros\nconst options1: WhereOptions&lt;User&gt; = {\n  where: {\n    role: 'admin',\n    age: 30\n  }\n};\nconst admins = await User.where({}, options1);\n\n// Ejemplo 2: Con paginaci\u00f3n\nconst options2: WhereOptions&lt;User&gt; = {\n  where: {\n    role: 'customer'\n  },\n  limit: 10,\n  skip: 20,\n  order: 'DESC'\n};\nconst customers = await User.where({}, options2);\n\n// Ejemplo 3: Con selecci\u00f3n de atributos\nconst options3: WhereOptions&lt;User&gt; = {\n  where: {\n    age: 25\n  },\n  attributes: ['id', 'name', 'email']\n};\nconst users = await User.where({}, options3);\n\n// Ejemplo 4: Con includes\nconst options4: WhereOptions&lt;User&gt; = {\n  where: {\n    role: 'customer'\n  },\n  include: {\n    orders: {\n      where: { total: 100 },\n      limit: 5,\n      order: 'DESC'\n    }\n  }\n};\nconst customers_with_orders = await User.where({}, options4);\n\n// Ejemplo 5: Completo\nconst options5: WhereOptions&lt;User&gt; = {\n  where: {\n    role: 'customer',\n    age: 30\n  },\n  attributes: ['id', 'name', 'email'],\n  limit: 20,\n  skip: 0,\n  order: 'ASC',\n  include: {\n    orders: {\n      attributes: ['id', 'total'],\n      where: { total: 500 },\n      limit: 10\n    }\n  }\n};\nconst filtered = await User.where({}, options5);\n</code></pre> <p>Uso con operadores:</p> <pre><code>// where() acepta operadores y opciones\nconst users = await User.where(\n  'age',\n  '&gt;=',\n  18,\n  {\n    limit: 10,\n    order: 'DESC',\n    attributes: ['id', 'name'],\n    include: {\n      orders: {}\n    }\n  } as WhereOptions&lt;User&gt;\n);\n</code></pre>"},{"location":"api/types/#whereoptionswithoutwheret","title":"WhereOptionsWithoutWhere\\&lt;T&gt;","text":"<p>Opciones de consulta sin el campo <code>where</code>, \u00fatil cuando los filtros se pasan como primer argumento.</p> <p>Sintaxis: <pre><code>type OptionsWithoutWhere&lt;T&gt; = Omit&lt;WhereOptions&lt;T&gt;, 'where'&gt;;\n</code></pre></p> <p>Caracter\u00edsticas: - Es <code>WhereOptions&lt;T&gt;</code> sin la propiedad <code>where</code> - Usado cuando los filtros se pasan separadamente - M\u00e1s sem\u00e1ntico en ciertos contextos</p> <p>Ejemplos:</p> <pre><code>import { Table, PrimaryKey, NotNull, HasMany, WhereOptionsWithoutWhere } from '@arcaelas/dynamite';\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare name: string;\n\n  @HasMany(() =&gt; Order, 'user_id')\n  declare orders: any;\n}\n\n// Filtros separados de opciones\nconst filters = { role: 'admin' };\n\nconst options: WhereOptionsWithoutWhere&lt;User&gt; = {\n  limit: 10,\n  skip: 0,\n  order: 'DESC',\n  attributes: ['id', 'name'],\n  include: {\n    orders: {}\n  }\n};\n\nconst users = await User.where(filters, options);\n\n// Tambi\u00e9n \u00fatil en funciones helper\nasync function find_paginated&lt;T extends Table&gt;(\n  Model: { new (data: any): T },\n  filters: Partial&lt;InferAttributes&lt;T&gt;&gt;,\n  page: number,\n  page_size: number\n): Promise&lt;T[]&gt; {\n  const options: WhereOptionsWithoutWhere&lt;T&gt; = {\n    limit: page_size,\n    skip: page * page_size,\n    order: 'ASC'\n  };\n\n  return Model.where(filters, options);\n}\n</code></pre>"},{"location":"api/types/#patrones-comunes","title":"Patrones Comunes","text":""},{"location":"api/types/#modelo-completo-con-todos-los-tipos","title":"Modelo completo con todos los tipos","text":"<pre><code>import {\n  Table,\n  PrimaryKey,\n  NotNull,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  HasMany,\n  BelongsTo,\n  CreationOptional,\n  NonAttribute,\n  InferAttributes,\n  FilterableAttributes\n} from '@arcaelas/dynamite';\n\nclass User extends Table&lt;User&gt; {\n  // ID auto-generado - CreationOptional\n  @PrimaryKey()\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Campos requeridos - sin marca\n  @NotNull()\n  declare email: string;\n\n  @NotNull()\n  declare name: string;\n\n  // Campos con valores por defecto - CreationOptional\n  @Default(() =&gt; 'customer')\n  declare role: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  @Default(() =&gt; 0)\n  declare balance: CreationOptional&lt;number&gt;;\n\n  // Timestamps auto-generados - CreationOptional\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n\n  // Propiedades computadas - NonAttribute\n  declare full_name: NonAttribute&lt;string&gt;;\n  declare display_role: NonAttribute&lt;string&gt;;\n\n  // Relaciones - no requieren marca especial\n  @HasMany(() =&gt; Order, 'user_id')\n  declare orders: any;\n\n  @HasMany(() =&gt; Review, 'user_id')\n  declare reviews: any;\n\n  constructor(data: InferAttributes&lt;User&gt;) {\n    super(data);\n\n    this.full_name = `${this.name} &lt;${this.email}&gt;`;\n    this.display_role = this.role === 'admin' ? 'Administrador' : 'Cliente';\n  }\n}\n\n// Durante creaci\u00f3n: solo campos requeridos\nconst user = await User.create({\n  email: 'user@test.com',\n  name: 'Juan P\u00e9rez'\n});\n\n// Despu\u00e9s de guardar: todos los campos presentes\nconsole.log(user.id);          // string (auto-generado)\nconsole.log(user.role);        // 'customer' (default)\nconsole.log(user.active);      // true (default)\nconsole.log(user.balance);     // 0 (default)\nconsole.log(user.createdAt);   // string (timestamp)\nconsole.log(user.full_name);   // 'Juan P\u00e9rez &lt;user@test.com&gt;' (computed)\nconsole.log(user.display_role); // 'Cliente' (computed)\n</code></pre>"},{"location":"api/types/#query-avanzada-con-todos-los-tipos","title":"Query avanzada con todos los tipos","text":"<pre><code>import { WhereOptions, QueryOperator } from '@arcaelas/dynamite';\n\n// Funci\u00f3n helper gen\u00e9rica con type-safety\nasync function find_advanced&lt;T extends Table&gt;(\n  Model: { new (data: InferAttributes&lt;T&gt;): T },\n  field: keyof FilterableAttributes&lt;T&gt;,\n  operator: QueryOperator,\n  value: any,\n  options?: WhereOptionsWithoutWhere&lt;T&gt;\n): Promise&lt;T[]&gt; {\n  return Model.where(field as string, operator, value, options);\n}\n\n// Uso con inferencia completa\nconst admins = await find_advanced(\n  User,\n  'role',\n  '=',\n  'admin',\n  {\n    limit: 10,\n    attributes: ['id', 'name', 'email'],\n    include: {\n      orders: {\n        where: { status: 'delivered' },\n        limit: 5\n      }\n    }\n  }\n);\n</code></pre>"},{"location":"api/types/#resumen","title":"Resumen","text":"Tipo Prop\u00f3sito Cu\u00e1ndo Usar <code>CreationOptional&lt;T&gt;</code> Campos opcionales al crear IDs auto-generados, defaults, timestamps <code>NonAttribute&lt;T&gt;</code> Campos no persistentes Propiedades computadas, getters, m\u00e9todos <code>InferAttributes&lt;T&gt;</code> Atributos persistentes Type-safety en queries y updates <code>FilterableAttributes&lt;T&gt;</code> Atributos filtrables Type-safety en where clauses <code>HasMany&lt;T&gt;</code> Relaci\u00f3n uno-a-muchos Cuando un modelo tiene m\u00faltiples instancias relacionadas <code>BelongsTo&lt;T&gt;</code> Relaci\u00f3n muchos-a-uno Cuando un modelo pertenece a otro <code>QueryOperator</code> Operadores de consulta Filtros avanzados en where <code>QueryResult&lt;T, A, I&gt;</code> Tipo de resultado Inferencia de tipo en queries con includes <code>WhereOptions&lt;T&gt;</code> Opciones de consulta Queries completas con filtros, paginaci\u00f3n e includes <code>WhereOptionsWithoutWhere&lt;T&gt;</code> Opciones sin filtros Queries donde filtros se pasan separadamente"},{"location":"api/types/#mejores-practicas","title":"Mejores Pr\u00e1cticas","text":"<ol> <li>Siempre usar <code>CreationOptional&lt;T&gt;</code> para:</li> <li>Campos con <code>@PrimaryKey()</code> (auto-generados)</li> <li>Campos con <code>@Default()</code> (valores por defecto)</li> <li> <p>Campos con <code>@CreatedAt()</code> o <code>@UpdatedAt()</code> (timestamps)</p> </li> <li> <p>Siempre usar <code>NonAttribute&lt;T&gt;</code> para:</p> </li> <li>Propiedades calculadas en el constructor</li> <li>Getters que derivan de otros campos</li> <li> <p>M\u00e9todos de instancia</p> </li> <li> <p>Relaciones:</p> </li> <li>Usar <code>@HasMany</code> para arrays de modelos relacionados</li> <li>Usar <code>@BelongsTo</code> para referencias \u00fanicas a modelos relacionados</li> <li> <p>No aplicar marcas de tipo adicionales a relaciones</p> </li> <li> <p>Type-safety:</p> </li> <li>Usar <code>InferAttributes&lt;T&gt;</code> en funciones gen\u00e9ricas</li> <li>Usar <code>FilterableAttributes&lt;T&gt;</code> para validar filtros</li> <li> <p>Usar <code>WhereOptions&lt;T&gt;</code> para opciones completas de query</p> </li> <li> <p>Performance:</p> </li> <li>Solo incluir relaciones necesarias con <code>include</code></li> <li>Usar <code>attributes</code> para seleccionar solo campos requeridos</li> <li>Aplicar <code>limit</code> y <code>skip</code> para paginaci\u00f3n</li> </ol> <p>Para m\u00e1s informaci\u00f3n, consulta: - Gu\u00eda de Instalaci\u00f3n - Referencia de Decoradores - Referencia de Table</p>"},{"location":"api/decorators/default/","title":"@Default Decorator","text":""},{"location":"api/decorators/default/#overview","title":"Overview","text":"<p>The <code>@Default</code> decorator automatically sets default values for model properties when instances are created. It supports both static values and dynamic functions, making it essential for generating timestamps, UUIDs, and computed defaults.</p>"},{"location":"api/decorators/default/#syntax","title":"Syntax","text":"<pre><code>@Default(value: any | (() =&gt; any))\n</code></pre>"},{"location":"api/decorators/default/#parameters","title":"Parameters","text":""},{"location":"api/decorators/default/#value","title":"value","text":"<ul> <li>Type: <code>any | (() =&gt; any)</code></li> <li>Required: Yes</li> <li>Description: Static value or function that returns the default value</li> </ul>"},{"location":"api/decorators/default/#basic-usage","title":"Basic Usage","text":""},{"location":"api/decorators/default/#static-defaults","title":"Static Defaults","text":"<pre><code>import { Model, PrimaryKey, Default } from 'dynamite-orm';\n\nclass User extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default('active')\n  status!: string;\n\n  @Default(0)\n  login_count!: number;\n\n  @Default(true)\n  email_verified!: boolean;\n}\n\nconst user = new User();\nuser.id = 'user123';\n// status = 'active', login_count = 0, email_verified = true\nawait user.save();\n</code></pre>"},{"location":"api/decorators/default/#dynamic-defaults","title":"Dynamic Defaults","text":"<pre><code>class Document extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  id!: string;\n\n  @Default(() =&gt; Date.now())\n  created_at!: number;\n\n  @Default(() =&gt; ({ views: 0, likes: 0 }))\n  stats!: { views: number; likes: number };\n\n  title!: string;\n}\n\nconst doc = new Document();\ndoc.title = 'My Document';\nawait doc.save();\n// id = auto-generated UUID\n// created_at = current timestamp\n// stats = { views: 0, likes: 0 }\n</code></pre>"},{"location":"api/decorators/default/#advanced-examples","title":"Advanced Examples","text":""},{"location":"api/decorators/default/#uuid-generation","title":"UUID Generation","text":"<pre><code>import { v4 as uuidv4, v1 as uuidv1 } from 'uuid';\n\nclass Resource extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; uuidv4())\n  id!: string;\n\n  @Default(() =&gt; uuidv1())\n  time_based_id!: string;\n\n  name!: string;\n}\n</code></pre>"},{"location":"api/decorators/default/#timestamp-defaults","title":"Timestamp Defaults","text":"<pre><code>class Post extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  title!: string;\n\n  @Default(() =&gt; Date.now())\n  created_at!: number;\n\n  @Default(() =&gt; new Date().toISOString())\n  iso_timestamp!: string;\n\n  @Default(() =&gt; Math.floor(Date.now() / 1000))\n  unix_timestamp!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#computed-defaults","title":"Computed Defaults","text":"<pre><code>class Order extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`)\n  order_number!: string;\n\n  @Default(() =&gt; {\n    const now = new Date();\n    return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000).getTime();\n  })\n  estimated_delivery!: number;\n\n  customer_id!: string;\n  total_amount!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#complex-object-defaults","title":"Complex Object Defaults","text":"<pre><code>class UserProfile extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  @Default(() =&gt; ({\n    theme: 'light',\n    language: 'en',\n    notifications: {\n      email: true,\n      push: true,\n      sms: false\n    }\n  }))\n  preferences!: {\n    theme: string;\n    language: string;\n    notifications: Record&lt;string, boolean&gt;;\n  };\n\n  @Default(() =&gt; [])\n  tags!: string[];\n\n  @Default(() =&gt; new Map())\n  metadata!: Map&lt;string, any&gt;;\n}\n</code></pre>"},{"location":"api/decorators/default/#environment-based-defaults","title":"Environment-Based Defaults","text":"<pre><code>class Configuration extends Model {\n  @PrimaryKey()\n  config_id!: string;\n\n  @Default(() =&gt; process.env.NODE_ENV || 'development')\n  environment!: string;\n\n  @Default(() =&gt; process.env.API_URL || 'http://localhost:3000')\n  api_url!: string;\n\n  @Default(() =&gt; parseInt(process.env.MAX_RETRIES || '3'))\n  max_retries!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#common-patterns","title":"Common Patterns","text":""},{"location":"api/decorators/default/#counters-and-accumulators","title":"Counters and Accumulators","text":"<pre><code>class Account extends Model {\n  @PrimaryKey()\n  account_id!: string;\n\n  @Default(0)\n  balance!: number;\n\n  @Default(0)\n  transaction_count!: number;\n\n  @Default(() =&gt; [])\n  transaction_history!: string[];\n\n  created_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#status-workflows","title":"Status Workflows","text":"<pre><code>class Task extends Model {\n  @PrimaryKey()\n  task_id!: string;\n\n  title!: string;\n\n  @Default('pending')\n  status!: 'pending' | 'in_progress' | 'completed' | 'cancelled';\n\n  @Default(0)\n  priority!: number;\n\n  @Default(() =&gt; Date.now() + 86400000)  // 24 hours from now\n  due_date!: number;\n\n  assigned_to?: string;\n}\n</code></pre>"},{"location":"api/decorators/default/#audit-fields","title":"Audit Fields","text":"<pre><code>class AuditedModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default(() =&gt; Date.now())\n  created_at!: number;\n\n  @Default(() =&gt; Date.now())\n  updated_at!: number;\n\n  @Default(() =&gt; 'system')\n  created_by!: string;\n\n  @Default(() =&gt; 'system')\n  updated_by!: string;\n\n  @Default(1)\n  version!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#array-and-collection-defaults","title":"Array and Collection Defaults","text":"<pre><code>class Collection extends Model {\n  @PrimaryKey()\n  collection_id!: string;\n\n  name!: string;\n\n  @Default(() =&gt; [])\n  items!: string[];\n\n  @Default(() =&gt; new Set())\n  unique_tags!: Set&lt;string&gt;;\n\n  @Default(() =&gt; ({ total: 0, active: 0 }))\n  counts!: { total: number; active: number };\n}\n</code></pre>"},{"location":"api/decorators/default/#random-defaults","title":"Random Defaults","text":"<pre><code>class Session extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  session_id!: string;\n\n  @Default(() =&gt; Math.random().toString(36).substring(2, 15))\n  csrf_token!: string;\n\n  @Default(() =&gt; crypto.getRandomValues(new Uint8Array(32)))\n  encryption_key!: Uint8Array;\n\n  @Default(() =&gt; Date.now() + 3600000)  // 1 hour\n  expires_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#integration-with-other-decorators","title":"Integration with Other Decorators","text":""},{"location":"api/decorators/default/#with-primarykey","title":"With @PrimaryKey","text":"<pre><code>class Entity extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; `ENT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`)\n  id!: string;\n\n  name!: string;\n}\n</code></pre>"},{"location":"api/decorators/default/#with-validate","title":"With @Validate","text":"<pre><code>class ValidatedModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default(() =&gt; Date.now())\n  @Validate((value) =&gt; value &gt; 0)\n  timestamp!: number;\n\n  @Default('active')\n  @Validate((value) =&gt; ['active', 'inactive', 'suspended'].includes(value))\n  status!: string;\n}\n</code></pre>"},{"location":"api/decorators/default/#with-mutate","title":"With @Mutate","text":"<pre><code>class NormalizedModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default('untitled')\n  @Mutate((value) =&gt; value.trim().toLowerCase())\n  slug!: string;\n\n  @Default(() =&gt; [])\n  @Mutate((value) =&gt; value.map((tag: string) =&gt; tag.toLowerCase()))\n  tags!: string[];\n}\n</code></pre>"},{"location":"api/decorators/default/#with-indexsort","title":"With @IndexSort","text":"<pre><code>class SearchableModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  title!: string;\n\n  @Default(() =&gt; Date.now())\n  @IndexSort()\n  created_at!: number;\n\n  @Default('draft')\n  @IndexSort()\n  status!: string;\n}\n</code></pre>"},{"location":"api/decorators/default/#with-timestamps","title":"With Timestamps","text":"<pre><code>class TimestampedModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default(() =&gt; Date.now())\n  @CreatedAt()\n  created_at!: number;\n\n  @Default(() =&gt; Date.now())\n  @UpdatedAt()\n  updated_at!: number;\n\n  content!: string;\n}\n</code></pre>"},{"location":"api/decorators/default/#best-practices","title":"Best Practices","text":""},{"location":"api/decorators/default/#1-use-functions-for-dynamic-values","title":"1. Use Functions for Dynamic Values","text":"<pre><code>// Good - Function generates new value each time\nclass GoodModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default(() =&gt; Date.now())\n  timestamp!: number;\n}\n\n// Bad - Static value is the same for all instances\nclass BadModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default(Date.now())  // \u274c Evaluated once at class definition\n  timestamp!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#2-avoid-side-effects-in-default-functions","title":"2. Avoid Side Effects in Default Functions","text":"<pre><code>// Good - Pure function\nclass GoodModel extends Model {\n  @Default(() =&gt; Date.now())\n  created_at!: number;\n}\n\n// Avoid - Side effects\nclass AvoidModel extends Model {\n  @Default(() =&gt; {\n    console.log('Creating instance');  // \u274c Side effect\n    return Date.now();\n  })\n  created_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#3-use-appropriate-types","title":"3. Use Appropriate Types","text":"<pre><code>// Good - Type-safe defaults\nclass TypeSafeModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default(0)\n  count!: number;\n\n  @Default(() =&gt; [])\n  items!: string[];\n\n  @Default(() =&gt; ({ key: 'value' }))\n  metadata!: Record&lt;string, string&gt;;\n}\n</code></pre>"},{"location":"api/decorators/default/#4-document-complex-defaults","title":"4. Document Complex Defaults","text":"<pre><code>class WellDocumented extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  /**\n   * Auto-generated order number format: ORD-{timestamp}-{random}\n   * Example: ORD-1234567890-abc123def\n   */\n  @Default(() =&gt; `ORD-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`)\n  order_number!: string;\n\n  /**\n   * Estimated delivery date: 7 days from creation\n   */\n  @Default(() =&gt; Date.now() + 7 * 24 * 60 * 60 * 1000)\n  estimated_delivery!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#5-consider-performance","title":"5. Consider Performance","text":"<pre><code>// Good - Simple, fast defaults\nclass Efficient extends Model {\n  @Default(0)\n  counter!: number;\n\n  @Default(() =&gt; Date.now())\n  timestamp!: number;\n}\n\n// Avoid - Expensive defaults\nclass Inefficient extends Model {\n  @Default(() =&gt; {\n    // \u274c Expensive computation\n    const result = Array.from({ length: 10000 }, (_, i) =&gt; i)\n      .reduce((sum, n) =&gt; sum + n, 0);\n    return result;\n  })\n  computed_value!: number;\n}\n</code></pre>"},{"location":"api/decorators/default/#default-value-resolution","title":"Default Value Resolution","text":"<p>The <code>@Default</code> decorator follows this resolution order:</p> <ol> <li>If property is explicitly set, use that value</li> <li>If <code>@Default</code> is present and property is undefined, apply default</li> <li>Otherwise, property remains undefined</li> </ol> <pre><code>class Model1 extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default('default_value')\n  field!: string;\n}\n\n// Scenario 1: Explicit value\nconst m1 = new Model1();\nm1.field = 'custom_value';\nawait m1.save();\n// field = 'custom_value'\n\n// Scenario 2: Use default\nconst m2 = new Model1();\nawait m2.save();\n// field = 'default_value'\n\n// Scenario 3: Set to null explicitly\nconst m3 = new Model1();\nm3.field = null as any;\nawait m3.save();\n// field = null (default not applied)\n</code></pre>"},{"location":"api/decorators/default/#default-functions-context","title":"Default Functions Context","text":"<pre><code>class ContextAware extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  name!: string;\n\n  // Default function has access to 'this' context\n  @Default(function(this: ContextAware) {\n    return `${this.name}_${Date.now()}`;\n  })\n  slug!: string;\n}\n\nconst model = new ContextAware();\nmodel.id = 'test';\nmodel.name = 'Example';\nawait model.save();\n// slug = 'Example_1234567890'\n</code></pre>"},{"location":"api/decorators/default/#overriding-defaults","title":"Overriding Defaults","text":"<pre><code>class Configurable extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default('default_value')\n  field!: string;\n\n  // Override default in constructor or method\n  constructor(override_field?: string) {\n    super();\n    if (override_field) {\n      this.field = override_field;\n    }\n  }\n}\n\nconst with_default = new Configurable();\n// field = 'default_value'\n\nconst with_override = new Configurable('custom_value');\n// field = 'custom_value'\n</code></pre>"},{"location":"api/decorators/default/#testing-defaults","title":"Testing Defaults","text":"<pre><code>import { describe, it, expect } from 'vitest';\n\ndescribe('Default Decorator', () =&gt; {\n  it('should apply static defaults', () =&gt; {\n    const model = new TestModel();\n    expect(model.status).toBe('active');\n    expect(model.count).toBe(0);\n  });\n\n  it('should apply dynamic defaults', () =&gt; {\n    const before = Date.now();\n    const model = new TestModel();\n    const after = Date.now();\n\n    expect(model.created_at).toBeGreaterThanOrEqual(before);\n    expect(model.created_at).toBeLessThanOrEqual(after);\n  });\n\n  it('should not override explicit values', () =&gt; {\n    const model = new TestModel();\n    model.status = 'inactive';\n    expect(model.status).toBe('inactive');\n  });\n});\n</code></pre>"},{"location":"api/decorators/default/#see-also","title":"See Also","text":"<ul> <li>@Validate - Validate default values</li> <li>@Mutate - Transform default values</li> <li>@CreatedAt - Specialized timestamp defaults</li> <li>@UpdatedAt - Auto-updating timestamps</li> </ul>"},{"location":"api/decorators/index-sort/","title":"@IndexSort Decorator","text":""},{"location":"api/decorators/index-sort/#overview","title":"Overview","text":"<p>The <code>@IndexSort</code> decorator creates Global Secondary Indexes (GSI) or Local Secondary Indexes (LSI) on DynamoDB tables, enabling efficient queries on non-primary key attributes. This decorator is crucial for supporting multiple access patterns in your application.</p>"},{"location":"api/decorators/index-sort/#syntax","title":"Syntax","text":"<pre><code>@IndexSort(options?: IndexSortOptions)\n</code></pre>"},{"location":"api/decorators/index-sort/#parameters","title":"Parameters","text":""},{"location":"api/decorators/index-sort/#indexsortoptions","title":"IndexSortOptions","text":"<pre><code>interface IndexSortOptions {\n  /** Index name (defaults to property name) */\n  name?: string;\n\n  /** Index type: 'global' or 'local' */\n  type?: 'global' | 'local';\n\n  /** Projection type: 'ALL', 'KEYS_ONLY', or 'INCLUDE' */\n  projection?: 'ALL' | 'KEYS_ONLY' | 'INCLUDE';\n\n  /** Attributes to include when projection is 'INCLUDE' */\n  include_attributes?: string[];\n\n  /** Read capacity units for GSI (defaults to table RCU) */\n  read_capacity?: number;\n\n  /** Write capacity units for GSI (defaults to table WCU) */\n  write_capacity?: number;\n}\n</code></pre>"},{"location":"api/decorators/index-sort/#basic-usage","title":"Basic Usage","text":""},{"location":"api/decorators/index-sort/#global-secondary-index","title":"Global Secondary Index","text":"<pre><code>import { Model, PrimaryKey, IndexSort } from 'dynamite-orm';\n\nclass User extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @IndexSort()\n  email!: string;\n\n  name!: string;\n  created_at!: number;\n}\n\n// Query by email\nconst user = await User.query()\n  .usingIndex('email')\n  .where('email', '=', 'user@example.com')\n  .first();\n</code></pre>"},{"location":"api/decorators/index-sort/#local-secondary-index","title":"Local Secondary Index","text":"<pre><code>class OrderItem extends Model {\n  @PrimaryKey('HASH')\n  order_id!: string;\n\n  @PrimaryKey('RANGE')\n  item_id!: string;\n\n  @IndexSort({ type: 'local' })\n  created_at!: number;\n\n  quantity!: number;\n}\n\n// Query order items sorted by creation time\nconst items = await OrderItem.query()\n  .where('order_id', '=', 'ORD123')\n  .usingIndex('created_at')\n  .sortBy('created_at', 'DESC')\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#advanced-examples","title":"Advanced Examples","text":""},{"location":"api/decorators/index-sort/#multiple-indexes","title":"Multiple Indexes","text":"<pre><code>class Product extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  name!: string;\n\n  @IndexSort({ name: 'category_index' })\n  category!: string;\n\n  @IndexSort({ name: 'price_index' })\n  price!: number;\n\n  @IndexSort({ name: 'created_index' })\n  created_at!: number;\n\n  stock_count!: number;\n}\n\n// Query by category\nconst electronics = await Product.query()\n  .usingIndex('category_index')\n  .where('category', '=', 'Electronics')\n  .execute();\n\n// Query by price range\nconst affordable = await Product.query()\n  .usingIndex('price_index')\n  .where('price', '&lt;', 100)\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#composite-gsi-keys","title":"Composite GSI Keys","text":"<pre><code>class Event extends Model {\n  @PrimaryKey()\n  event_id!: string;\n\n  @IndexSort({\n    name: 'user_timestamp_index',\n    type: 'global'\n  })\n  user_id!: string;\n\n  @IndexSort({\n    name: 'user_timestamp_index',\n    type: 'global'\n  })\n  timestamp!: number;\n\n  event_type!: string;\n  data!: any;\n}\n\n// Query user events in time range\nconst user_events = await Event.query()\n  .usingIndex('user_timestamp_index')\n  .where('user_id', '=', 'user123')\n  .where('timestamp', 'between', [start, end])\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#sparse-indexes","title":"Sparse Indexes","text":"<pre><code>class Task extends Model {\n  @PrimaryKey()\n  task_id!: string;\n\n  title!: string;\n  status!: 'pending' | 'completed';\n\n  @IndexSort({ name: 'assigned_index' })\n  assigned_to?: string;  // Only indexed when assigned\n\n  created_at!: number;\n}\n\n// Query tasks assigned to a user\nconst assigned_tasks = await Task.query()\n  .usingIndex('assigned_index')\n  .where('assigned_to', '=', 'user456')\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#projection-optimization","title":"Projection Optimization","text":"<pre><code>class Article extends Model {\n  @PrimaryKey()\n  article_id!: string;\n\n  title!: string;\n\n  @IndexSort({\n    name: 'author_index',\n    projection: 'INCLUDE',\n    include_attributes: ['title', 'published_at', 'summary']\n  })\n  author_id!: string;\n\n  content!: string;  // Large field, not in index\n  summary!: string;\n  published_at!: number;\n}\n\n// Efficient query - no additional table reads needed\nconst articles = await Article.query()\n  .usingIndex('author_index')\n  .where('author_id', '=', 'author789')\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#common-patterns","title":"Common Patterns","text":""},{"location":"api/decorators/index-sort/#status-based-queries","title":"Status-Based Queries","text":"<pre><code>class Order extends Model {\n  @PrimaryKey()\n  order_id!: string;\n\n  @IndexSort({ name: 'status_created_index' })\n  status!: 'pending' | 'processing' | 'shipped' | 'delivered';\n\n  @IndexSort({ name: 'status_created_index' })\n  created_at!: number;\n\n  customer_id!: string;\n  total_amount!: number;\n}\n\n// Query pending orders sorted by creation time\nconst pending_orders = await Order.query()\n  .usingIndex('status_created_index')\n  .where('status', '=', 'pending')\n  .sortBy('created_at', 'ASC')\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#user-activity-tracking","title":"User Activity Tracking","text":"<pre><code>class Activity extends Model {\n  @PrimaryKey()\n  activity_id!: string;\n\n  @IndexSort({\n    name: 'user_activity_index',\n    projection: 'KEYS_ONLY'\n  })\n  user_id!: string;\n\n  @IndexSort({ name: 'user_activity_index' })\n  timestamp!: number;\n\n  activity_type!: string;\n  details!: Record&lt;string, any&gt;;\n}\n\n// Get recent user activity\nconst recent_activity = await Activity.query()\n  .usingIndex('user_activity_index')\n  .where('user_id', '=', 'user123')\n  .where('timestamp', '&gt;', Date.now() - 604800000)\n  .sortBy('timestamp', 'DESC')\n  .limit(20)\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#tag-based-search","title":"Tag-Based Search","text":"<pre><code>class Resource extends Model {\n  @PrimaryKey()\n  resource_id!: string;\n\n  name!: string;\n\n  @IndexSort({ name: 'tag_index' })\n  tag!: string;\n\n  @IndexSort({ name: 'tag_index' })\n  updated_at!: number;\n\n  content!: any;\n}\n\n// Find resources by tag\nconst tagged_resources = await Resource.query()\n  .usingIndex('tag_index')\n  .where('tag', '=', 'important')\n  .sortBy('updated_at', 'DESC')\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#geospatial-queries","title":"Geospatial Queries","text":"<pre><code>class Location extends Model {\n  @PrimaryKey()\n  location_id!: string;\n\n  name!: string;\n\n  @IndexSort({ name: 'geohash_index' })\n  geohash!: string;  // First 6 chars of geohash\n\n  @IndexSort({ name: 'geohash_index' })\n  timestamp!: number;\n\n  latitude!: number;\n  longitude!: number;\n}\n\n// Query locations in area\nconst nearby = await Location.query()\n  .usingIndex('geohash_index')\n  .where('geohash', 'beginsWith', 'u4pruydqqvj')\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#integration-with-other-decorators","title":"Integration with Other Decorators","text":""},{"location":"api/decorators/index-sort/#with-default","title":"With @Default","text":"<pre><code>class Document extends Model {\n  @PrimaryKey()\n  document_id!: string;\n\n  title!: string;\n\n  @IndexSort()\n  @Default(() =&gt; Date.now())\n  created_at!: number;\n\n  content!: string;\n}\n</code></pre>"},{"location":"api/decorators/index-sort/#with-validate","title":"With @Validate","text":"<pre><code>class Membership extends Model {\n  @PrimaryKey()\n  membership_id!: string;\n\n  @IndexSort()\n  @Validate((value) =&gt; ['free', 'premium', 'enterprise'].includes(value))\n  tier!: string;\n\n  user_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/index-sort/#with-createdat-and-updatedat","title":"With @CreatedAt and @UpdatedAt","text":"<pre><code>class Post extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  title!: string;\n  content!: string;\n\n  @IndexSort({ name: 'created_index' })\n  @CreatedAt()\n  created_at!: number;\n\n  @IndexSort({ name: 'updated_index' })\n  @UpdatedAt()\n  updated_at!: number;\n}\n\n// Query recently created posts\nconst recent = await Post.query()\n  .usingIndex('created_index')\n  .where('created_at', '&gt;', Date.now() - 86400000)\n  .execute();\n\n// Query recently updated posts\nconst updated = await Post.query()\n  .usingIndex('updated_index')\n  .where('updated_at', '&gt;', Date.now() - 3600000)\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#with-relationships","title":"With Relationships","text":"<pre><code>class Comment extends Model {\n  @PrimaryKey()\n  comment_id!: string;\n\n  content!: string;\n\n  @IndexSort()\n  @BelongsTo(() =&gt; Post)\n  post_id!: string;\n\n  @IndexSort()\n  @BelongsTo(() =&gt; User)\n  user_id!: string;\n\n  created_at!: number;\n}\n\n// Query comments for a post\nconst post_comments = await Comment.query()\n  .usingIndex('post_id')\n  .where('post_id', '=', 'post123')\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#best-practices","title":"Best Practices","text":""},{"location":"api/decorators/index-sort/#1-design-indexes-for-query-patterns","title":"1. Design Indexes for Query Patterns","text":"<pre><code>// Good - Index supports specific query patterns\nclass BlogPost extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @IndexSort({ name: 'author_published_index' })\n  author_id!: string;\n\n  @IndexSort({ name: 'author_published_index' })\n  published_at!: number;\n\n  title!: string;\n}\n\n// Query: \"Get all posts by author sorted by publication date\"\n</code></pre>"},{"location":"api/decorators/index-sort/#2-use-projection-to-reduce-costs","title":"2. Use Projection to Reduce Costs","text":"<pre><code>// Good - Only include necessary attributes\nclass Message extends Model {\n  @PrimaryKey()\n  message_id!: string;\n\n  @IndexSort({\n    name: 'recipient_index',\n    projection: 'INCLUDE',\n    include_attributes: ['sender_id', 'subject', 'sent_at']\n  })\n  recipient_id!: string;\n\n  sender_id!: string;\n  subject!: string;\n  body!: string;  // Large field excluded from index\n  sent_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/index-sort/#3-limit-number-of-indexes","title":"3. Limit Number of Indexes","text":"<pre><code>// Avoid - Too many indexes increase storage and write costs\nclass OverIndexed extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @IndexSort()  // \u274c\n  field1!: string;\n\n  @IndexSort()  // \u274c\n  field2!: string;\n\n  @IndexSort()  // \u274c\n  field3!: string;\n\n  @IndexSort()  // \u274c\n  field4!: string;\n}\n\n// Good - Strategic indexes\nclass WellIndexed extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @IndexSort()  // \u2713 Common query pattern\n  status!: string;\n\n  @IndexSort()  // \u2713 Time-based queries\n  created_at!: number;\n\n  field3!: string;  // No index needed\n  field4!: string;  // No index needed\n}\n</code></pre>"},{"location":"api/decorators/index-sort/#4-use-local-indexes-for-same-partition","title":"4. Use Local Indexes for Same Partition","text":"<pre><code>// Good - Local index for queries within partition\nclass CustomerOrder extends Model {\n  @PrimaryKey('HASH')\n  customer_id!: string;\n\n  @PrimaryKey('RANGE')\n  order_id!: string;\n\n  @IndexSort({ type: 'local' })\n  status!: string;\n\n  @IndexSort({ type: 'local' })\n  total_amount!: number;\n}\n\n// Efficient query within customer partition\n</code></pre>"},{"location":"api/decorators/index-sort/#5-consider-write-amplification","title":"5. Consider Write Amplification","text":"<pre><code>// Be aware - Each index adds write cost\nclass HighThroughput extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @IndexSort()  // +1 write per update\n  status!: string;\n\n  @IndexSort()  // +1 write per update\n  updated_at!: number;\n\n  // Each write to this model = 3 writes (1 table + 2 indexes)\n}\n</code></pre>"},{"location":"api/decorators/index-sort/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/decorators/index-sort/#1-index-capacity-planning","title":"1. Index Capacity Planning","text":"<pre><code>class AnalyticsEvent extends Model {\n  @PrimaryKey()\n  event_id!: string;\n\n  @IndexSort({\n    name: 'high_traffic_index',\n    read_capacity: 100,\n    write_capacity: 50\n  })\n  event_type!: string;\n\n  timestamp!: number;\n  data!: any;\n}\n</code></pre>"},{"location":"api/decorators/index-sort/#2-eventual-consistency","title":"2. Eventual Consistency","text":"<pre><code>// GSI queries are eventually consistent\nconst recent_items = await Item.query()\n  .usingIndex('created_index')\n  .where('created_at', '&gt;', Date.now() - 1000)\n  .execute();\n\n// May not include items created in the last few milliseconds\n</code></pre>"},{"location":"api/decorators/index-sort/#3-query-optimization","title":"3. Query Optimization","text":"<pre><code>// Efficient - Uses index with sort key\nconst filtered = await Order.query()\n  .usingIndex('status_created_index')\n  .where('status', '=', 'pending')\n  .where('created_at', '&gt;', yesterday)\n  .execute();\n\n// Less efficient - Full index scan\nconst all_pending = await Order.query()\n  .usingIndex('status_created_index')\n  .where('status', '=', 'pending')\n  .execute();\n</code></pre>"},{"location":"api/decorators/index-sort/#migration-and-maintenance","title":"Migration and Maintenance","text":""},{"location":"api/decorators/index-sort/#adding-new-index","title":"Adding New Index","text":"<pre><code>// Step 1: Add decorator\nclass User extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  email!: string;\n\n  // New index\n  @IndexSort()\n  last_login!: number;\n}\n\n// Step 2: Update table schema\nawait dynamodb.updateTable({\n  TableName: 'Users',\n  AttributeDefinitions: [\n    { AttributeName: 'last_login', AttributeType: 'N' }\n  ],\n  GlobalSecondaryIndexUpdates: [{\n    Create: {\n      IndexName: 'last_login',\n      KeySchema: [\n        { AttributeName: 'last_login', KeyType: 'HASH' }\n      ],\n      Projection: { ProjectionType: 'ALL' },\n      ProvisionedThroughput: {\n        ReadCapacityUnits: 5,\n        WriteCapacityUnits: 5\n      }\n    }\n  }]\n});\n</code></pre>"},{"location":"api/decorators/index-sort/#monitoring-index-usage","title":"Monitoring Index Usage","text":"<pre><code>// Track query performance\nclass MonitoredModel extends Model {\n  static async queryWithMetrics(index_name: string) {\n    const start = Date.now();\n    const results = await this.query()\n      .usingIndex(index_name)\n      .execute();\n    const duration = Date.now() - start;\n\n    console.log(`Index ${index_name} query took ${duration}ms`);\n    return results;\n  }\n}\n</code></pre>"},{"location":"api/decorators/index-sort/#see-also","title":"See Also","text":"<ul> <li>@PrimaryKey - Define primary keys</li> <li>Query API - Using indexes in queries</li> <li>Performance Guide - Index optimization</li> </ul>"},{"location":"api/decorators/mutate/","title":"@Mutate Decorator","text":""},{"location":"api/decorators/mutate/#overview","title":"Overview","text":"<p>The <code>@Mutate</code> decorator transforms property values automatically before persistence. It enables data normalization, sanitization, and formatting, ensuring consistent data representation in your DynamoDB tables.</p>"},{"location":"api/decorators/mutate/#syntax","title":"Syntax","text":"<pre><code>@Mutate(transformer: TransformerFunction | TransformerFunction[])\n</code></pre>"},{"location":"api/decorators/mutate/#parameters","title":"Parameters","text":""},{"location":"api/decorators/mutate/#transformerfunction","title":"TransformerFunction","text":"<pre><code>type TransformerFunction = (value: any, context?: MutationContext) =&gt; any | Promise&lt;any&gt;;\n</code></pre> <ul> <li>Returns: Transformed value</li> <li>Async: Can return a Promise for asynchronous transformations</li> </ul>"},{"location":"api/decorators/mutate/#mutationcontext","title":"MutationContext","text":"<pre><code>interface MutationContext {\n  /** Current model instance */\n  instance: Model;\n\n  /** Property name being mutated */\n  property: string;\n\n  /** All property values */\n  values: Record&lt;string, any&gt;;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#basic-usage","title":"Basic Usage","text":""},{"location":"api/decorators/mutate/#simple-transformations","title":"Simple Transformations","text":"<pre><code>import { Model, PrimaryKey, Mutate } from 'dynamite-orm';\n\nclass User extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; value.toLowerCase())\n  email!: string;\n\n  @Mutate((value) =&gt; value.trim())\n  username!: string;\n\n  @Mutate((value) =&gt; Math.round(value))\n  age!: number;\n}\n\nconst user = new User();\nuser.email = 'USER@EXAMPLE.COM';\nuser.username = '  john_doe  ';\nuser.age = 25.7;\nawait user.save();\n// email = 'user@example.com'\n// username = 'john_doe'\n// age = 26\n</code></pre>"},{"location":"api/decorators/mutate/#string-mutations","title":"String Mutations","text":"<pre><code>class Article extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; value.trim())\n  title!: string;\n\n  @Mutate((value) =&gt; value.toLowerCase().replace(/\\s+/g, '-'))\n  slug!: string;\n\n  @Mutate((value) =&gt; value.replace(/&lt;[^&gt;]*&gt;/g, ''))\n  content!: string;  // Strip HTML tags\n}\n</code></pre>"},{"location":"api/decorators/mutate/#advanced-examples","title":"Advanced Examples","text":""},{"location":"api/decorators/mutate/#multiple-transformers","title":"Multiple Transformers","text":"<pre><code>class Product extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate([\n    (value) =&gt; value.trim(),\n    (value) =&gt; value.toLowerCase(),\n    (value) =&gt; value.replace(/[^a-z0-9-]/g, '-'),\n    (value) =&gt; value.replace(/-+/g, '-'),\n    (value) =&gt; value.replace(/^-|-$/g, '')\n  ])\n  sku!: string;\n\n  name!: string;\n}\n\nconst product = new Product();\nproduct.sku = '  Product @@ 123  ';\nawait product.save();\n// sku = 'product-123'\n</code></pre>"},{"location":"api/decorators/mutate/#number-transformations","title":"Number Transformations","text":"<pre><code>class FinancialRecord extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; Math.round(value * 100) / 100)  // 2 decimal places\n  amount!: number;\n\n  @Mutate((value) =&gt; Math.max(0, value))  // Ensure non-negative\n  balance!: number;\n\n  @Mutate((value) =&gt; parseInt(value))\n  quantity!: number;\n\n  @Mutate((value) =&gt; parseFloat(value.toFixed(4)))\n  percentage!: number;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#array-transformations","title":"Array Transformations","text":"<pre><code>class Post extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  title!: string;\n\n  @Mutate((value) =&gt; value.map((tag: string) =&gt; tag.toLowerCase().trim()))\n  tags!: string[];\n\n  @Mutate((value) =&gt; [...new Set(value)])  // Remove duplicates\n  categories!: string[];\n\n  @Mutate((value) =&gt; value.sort())\n  keywords!: string[];\n}\n</code></pre>"},{"location":"api/decorators/mutate/#object-transformations","title":"Object Transformations","text":"<pre><code>class Profile extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  @Mutate((value) =&gt; ({\n    street: value.street?.trim(),\n    city: value.city?.trim(),\n    state: value.state?.toUpperCase(),\n    zip: value.zip?.replace(/\\D/g, '')\n  }))\n  address!: {\n    street: string;\n    city: string;\n    state: string;\n    zip: string;\n  };\n\n  @Mutate((value) =&gt; {\n    const cleaned: Record&lt;string, any&gt; = {};\n    for (const [key, val] of Object.entries(value)) {\n      if (val !== null &amp;&amp; val !== undefined) {\n        cleaned[key] = val;\n      }\n    }\n    return cleaned;\n  })\n  metadata!: Record&lt;string, any&gt;;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#date-transformations","title":"Date Transformations","text":"<pre><code>class Event extends Model {\n  @PrimaryKey()\n  event_id!: string;\n\n  @Mutate((value) =&gt; {\n    if (typeof value === 'string') {\n      return new Date(value).getTime();\n    }\n    if (value instanceof Date) {\n      return value.getTime();\n    }\n    return value;\n  })\n  start_time!: number;\n\n  @Mutate((value) =&gt; Math.floor(value / 1000))  // Convert ms to seconds\n  unix_timestamp!: number;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#contextual-transformations","title":"Contextual Transformations","text":"<pre><code>class Document extends Model {\n  @PrimaryKey()\n  document_id!: string;\n\n  title!: string;\n\n  @Mutate((value, context) =&gt; {\n    const title = context?.instance.title || 'untitled';\n    return `${title.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}`;\n  })\n  filename!: string;\n\n  content!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#common-patterns","title":"Common Patterns","text":""},{"location":"api/decorators/mutate/#email-normalization","title":"Email Normalization","text":"<pre><code>class Contact extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate([\n    (value) =&gt; value.trim(),\n    (value) =&gt; value.toLowerCase(),\n    (value) =&gt; value.replace(/\\s+/g, '')\n  ])\n  email!: string;\n\n  name!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#phone-number-formatting","title":"Phone Number Formatting","text":"<pre><code>class Customer extends Model {\n  @PrimaryKey()\n  customer_id!: string;\n\n  @Mutate((value) =&gt; {\n    const digits = value.replace(/\\D/g, '');\n    if (digits.length === 10) {\n      return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;\n    }\n    return value;\n  })\n  phone!: string;\n\n  name!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#url-normalization","title":"URL Normalization","text":"<pre><code>class Link extends Model {\n  @PrimaryKey()\n  link_id!: string;\n\n  @Mutate([\n    (value) =&gt; value.trim(),\n    (value) =&gt; value.toLowerCase(),\n    (value) =&gt; value.replace(/^https?:\\/\\//, ''),\n    (value) =&gt; value.replace(/\\/$/, ''),\n    (value) =&gt; `https://${value}`\n  ])\n  url!: string;\n\n  title!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#slug-generation","title":"Slug Generation","text":"<pre><code>class BlogPost extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  title!: string;\n\n  @Mutate((value, context) =&gt; {\n    const title = context?.instance.title || value;\n    return title\n      .toLowerCase()\n      .trim()\n      .replace(/[^\\w\\s-]/g, '')\n      .replace(/\\s+/g, '-')\n      .replace(/-+/g, '-')\n      .substring(0, 50);\n  })\n  slug!: string;\n\n  content!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#json-serialization","title":"JSON Serialization","text":"<pre><code>class Configuration extends Model {\n  @PrimaryKey()\n  config_id!: string;\n\n  @Mutate((value) =&gt; typeof value === 'string' ? value : JSON.stringify(value))\n  json_data!: string;\n\n  @Mutate((value) =&gt; typeof value === 'string' ? JSON.parse(value) : value)\n  parsed_data!: any;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#sanitization","title":"Sanitization","text":"<pre><code>class Comment extends Model {\n  @PrimaryKey()\n  comment_id!: string;\n\n  @Mutate([\n    (value) =&gt; value.trim(),\n    (value) =&gt; value.replace(/&lt;script\\b[^&lt;]*(?:(?!&lt;\\/script&gt;)&lt;[^&lt;]*)*&lt;\\/script&gt;/gi, ''),\n    (value) =&gt; value.replace(/javascript:/gi, ''),\n    (value) =&gt; value.replace(/on\\w+\\s*=/gi, '')\n  ])\n  content!: string;\n\n  author_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#case-normalization","title":"Case Normalization","text":"<pre><code>class Identifier extends Model {\n  @PrimaryKey()\n  @Mutate((value) =&gt; value.toUpperCase())\n  id!: string;\n\n  @Mutate((value) =&gt; value.toLowerCase())\n  username!: string;\n\n  @Mutate((value) =&gt; {\n    return value\n      .toLowerCase()\n      .split(' ')\n      .map((word: string) =&gt; word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  })\n  full_name!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#whitespace-handling","title":"Whitespace Handling","text":"<pre><code>class TextContent extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; value.trim())\n  title!: string;\n\n  @Mutate((value) =&gt; value.replace(/\\s+/g, ' ').trim())\n  description!: string;\n\n  @Mutate((value) =&gt; value.replace(/^\\s+|\\s+$/gm, ''))\n  multiline_text!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#integration-with-other-decorators","title":"Integration with Other Decorators","text":""},{"location":"api/decorators/mutate/#with-validate","title":"With @Validate","text":"<pre><code>class ValidatedMutation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; value.toLowerCase().trim())\n  @Validate((value) =&gt; value.length &gt;= 3)\n  username!: string;\n\n  @Mutate((value) =&gt; value.replace(/\\s+/g, ''))\n  @Validate((value) =&gt; /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value))\n  email!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#with-default","title":"With @Default","text":"<pre><code>class DefaultMutation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default(() =&gt; Date.now())\n  @Mutate((value) =&gt; Math.floor(value / 1000))\n  created_timestamp!: number;\n\n  @Default(() =&gt; [])\n  @Mutate((value) =&gt; [...new Set(value)])\n  unique_items!: string[];\n}\n</code></pre>"},{"location":"api/decorators/mutate/#with-indexsort","title":"With @IndexSort","text":"<pre><code>class IndexedMutation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; value.toLowerCase())\n  @IndexSort()\n  category!: string;\n\n  @Mutate((value) =&gt; Math.round(value * 100) / 100)\n  @IndexSort()\n  price!: number;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#with-primarykey","title":"With @PrimaryKey","text":"<pre><code>class MutatedKey extends Model {\n  @PrimaryKey()\n  @Mutate((value) =&gt; value.toLowerCase().replace(/\\s+/g, '-'))\n  id!: string;\n\n  @PrimaryKey('RANGE')\n  @Mutate((value) =&gt; Math.floor(value))\n  timestamp!: number;\n\n  data!: any;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#best-practices","title":"Best Practices","text":""},{"location":"api/decorators/mutate/#1-keep-transformations-pure","title":"1. Keep Transformations Pure","text":"<pre><code>// Good - Pure transformation\nclass GoodMutation extends Model {\n  @Mutate((value) =&gt; value.toLowerCase())\n  field!: string;\n}\n\n// Avoid - Side effects\nclass BadMutation extends Model {\n  @Mutate((value) =&gt; {\n    console.log('Mutating:', value);  // \u274c Side effect\n    return value.toLowerCase();\n  })\n  field!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#2-order-matters","title":"2. Order Matters","text":"<pre><code>// Good - Logical order\nclass OrderedMutation extends Model {\n  @Mutate([\n    (value) =&gt; value.trim(),           // 1. Remove whitespace\n    (value) =&gt; value.toLowerCase(),    // 2. Normalize case\n    (value) =&gt; value.replace(/\\s+/g, '-'),  // 3. Replace spaces\n    (value) =&gt; value.replace(/-+/g, '-')    // 4. Collapse dashes\n  ])\n  slug!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#3-handle-edge-cases","title":"3. Handle Edge Cases","text":"<pre><code>class SafeMutation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; {\n    if (value === null || value === undefined) return value;\n    if (typeof value !== 'string') return String(value);\n    return value.trim().toLowerCase();\n  })\n  safe_field!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#4-avoid-data-loss","title":"4. Avoid Data Loss","text":"<pre><code>// Good - Preserves information\nclass PreserveData extends Model {\n  @Mutate((value) =&gt; value.trim())\n  name!: string;\n}\n\n// Avoid - Loses data\nclass LoseData extends Model {\n  @Mutate((value) =&gt; value.substring(0, 10))  // \u274c Truncates without warning\n  name!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#5-document-complex-transformations","title":"5. Document Complex Transformations","text":"<pre><code>class DocumentedMutation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  /**\n   * Normalizes SKU format:\n   * - Converts to uppercase\n   * - Removes special characters\n   * - Ensures 10 character length with leading zeros\n   * Example: \"abc-123\" -&gt; \"ABC0000123\"\n   */\n  @Mutate((value) =&gt; {\n    const cleaned = value.toUpperCase().replace(/[^A-Z0-9]/g, '');\n    return cleaned.padStart(10, '0');\n  })\n  sku!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#async-transformations","title":"Async Transformations","text":""},{"location":"api/decorators/mutate/#api-based-mutations","title":"API-Based Mutations","text":"<pre><code>class EnrichedData extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate(async (value) =&gt; {\n    const response = await fetch(`https://api.geocode.com?address=${value}`);\n    const data = await response.json();\n    return {\n      original: value,\n      latitude: data.lat,\n      longitude: data.lng\n    };\n  })\n  address!: any;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#async-sanitization","title":"Async Sanitization","text":"<pre><code>class SecureContent extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate(async (value) =&gt; {\n    const sanitized = await security_service.sanitize(value);\n    return sanitized;\n  })\n  user_content!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#error-handling","title":"Error Handling","text":""},{"location":"api/decorators/mutate/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>class ErrorHandling extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; {\n    try {\n      return JSON.parse(value);\n    } catch (error) {\n      console.error('Failed to parse JSON:', error);\n      return value;  // Return original on error\n    }\n  })\n  json_field!: any;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#validation-after-mutation","title":"Validation After Mutation","text":"<pre><code>class ValidatedTransform extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; {\n    const transformed = value.toLowerCase().trim();\n    if (!transformed) {\n      throw new Error('Transformation resulted in empty value');\n    }\n    return transformed;\n  })\n  required_field!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#custom-transformers","title":"Custom Transformers","text":""},{"location":"api/decorators/mutate/#reusable-transformer-functions","title":"Reusable Transformer Functions","text":"<pre><code>// transformers.ts\nexport const ToLowerCase = (value: string) =&gt; value.toLowerCase();\n\nexport const Trim = (value: string) =&gt; value.trim();\n\nexport const RemoveSpaces = (value: string) =&gt; value.replace(/\\s+/g, '');\n\nexport const Slugify = (value: string) =&gt;\n  value\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '')\n    .replace(/\\s+/g, '-');\n\nexport const Round = (decimals: number) =&gt; (value: number) =&gt;\n  Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals);\n\nexport const Clamp = (min: number, max: number) =&gt; (value: number) =&gt;\n  Math.min(Math.max(value, min), max);\n\n// Usage\nclass Product extends Model {\n  @Mutate(Slugify)\n  slug!: string;\n\n  @Mutate(Round(2))\n  price!: number;\n\n  @Mutate(Clamp(0, 100))\n  discount_percentage!: number;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#transformer-composition","title":"Transformer Composition","text":"<pre><code>const Compose = (...transformers: TransformerFunction[]) =&gt;\n  (value: any, context?: MutationContext) =&gt;\n    transformers.reduce((acc, transformer) =&gt; transformer(acc, context), value);\n\nclass ComposedMutation extends Model {\n  @Mutate(Compose(\n    Trim,\n    ToLowerCase,\n    RemoveSpaces\n  ))\n  normalized_field!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/decorators/mutate/#avoid-expensive-operations","title":"Avoid Expensive Operations","text":"<pre><code>// Good - Simple, fast transformation\nclass Efficient extends Model {\n  @Mutate((value) =&gt; value.toLowerCase())\n  field!: string;\n}\n\n// Avoid - Expensive operation\nclass Inefficient extends Model {\n  @Mutate((value) =&gt; {\n    // \u274c Expensive regex on large strings\n    return value.replace(/(.{1})/g, '$1-');\n  })\n  field!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#cache-results-when-possible","title":"Cache Results When Possible","text":"<pre><code>const transformation_cache = new Map&lt;string, string&gt;();\n\nclass CachedMutation extends Model {\n  @Mutate((value) =&gt; {\n    if (transformation_cache.has(value)) {\n      return transformation_cache.get(value);\n    }\n\n    const result = expensive_transformation(value);\n    transformation_cache.set(value, result);\n    return result;\n  })\n  computed_field!: string;\n}\n</code></pre>"},{"location":"api/decorators/mutate/#testing-transformers","title":"Testing Transformers","text":"<pre><code>import { describe, it, expect } from 'vitest';\n\ndescribe('Mutate Decorator', () =&gt; {\n  it('should transform to lowercase', () =&gt; {\n    const model = new TestModel();\n    model.field = 'UPPERCASE';\n    expect(model.field).toBe('uppercase');\n  });\n\n  it('should chain transformations', () =&gt; {\n    const model = new TestModel();\n    model.slug = '  My Title  ';\n    expect(model.slug).toBe('my-title');\n  });\n});\n</code></pre>"},{"location":"api/decorators/mutate/#see-also","title":"See Also","text":"<ul> <li>@Validate - Validate transformed values</li> <li>@Default - Set default values before mutation</li> <li>Data Modeling - Best practices for data transformation</li> </ul>"},{"location":"api/decorators/primary-key/","title":"@PrimaryKey Decorator","text":""},{"location":"api/decorators/primary-key/#overview","title":"Overview","text":"<p>The <code>@PrimaryKey</code> decorator marks a property as the primary key for a DynamoDB table. This decorator is essential for defining the partition key and optional sort key that uniquely identify items in your table.</p>"},{"location":"api/decorators/primary-key/#syntax","title":"Syntax","text":"<pre><code>@PrimaryKey(type?: 'HASH' | 'RANGE')\n</code></pre>"},{"location":"api/decorators/primary-key/#parameters","title":"Parameters","text":""},{"location":"api/decorators/primary-key/#type","title":"type","text":"<ul> <li>Type: <code>'HASH' | 'RANGE'</code></li> <li>Default: <code>'HASH'</code></li> <li>Required: No</li> <li>Description: Specifies whether this is a partition key (HASH) or sort key (RANGE)</li> </ul>"},{"location":"api/decorators/primary-key/#basic-usage","title":"Basic Usage","text":""},{"location":"api/decorators/primary-key/#simple-partition-key","title":"Simple Partition Key","text":"<pre><code>import { Model, PrimaryKey } from 'dynamite-orm';\n\nclass User extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  name!: string;\n  email!: string;\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#composite-primary-key","title":"Composite Primary Key","text":"<pre><code>class OrderItem extends Model {\n  @PrimaryKey('HASH')\n  order_id!: string;\n\n  @PrimaryKey('RANGE')\n  item_id!: string;\n\n  quantity!: number;\n  price!: number;\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#advanced-examples","title":"Advanced Examples","text":""},{"location":"api/decorators/primary-key/#uuid-primary-key","title":"UUID Primary Key","text":"<pre><code>import { v4 as uuidv4 } from 'uuid';\n\nclass Product extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; uuidv4())\n  id!: string;\n\n  name!: string;\n  category!: string;\n}\n\n// Usage\nconst product = new Product();\nproduct.name = 'Laptop';\nproduct.category = 'Electronics';\nawait product.save();\n// id is automatically generated\n</code></pre>"},{"location":"api/decorators/primary-key/#timestamp-based-sort-key","title":"Timestamp-Based Sort Key","text":"<pre><code>class Event extends Model {\n  @PrimaryKey('HASH')\n  user_id!: string;\n\n  @PrimaryKey('RANGE')\n  @Default(() =&gt; Date.now())\n  timestamp!: number;\n\n  event_type!: string;\n  data!: Record&lt;string, any&gt;;\n}\n\n// Query events for a user\nconst events = await Event.query()\n  .where('user_id', '=', 'user123')\n  .sortBy('timestamp', 'DESC')\n  .limit(10)\n  .execute();\n</code></pre>"},{"location":"api/decorators/primary-key/#compound-sort-key-pattern","title":"Compound Sort Key Pattern","text":"<pre><code>class Message extends Model {\n  @PrimaryKey('HASH')\n  chat_room_id!: string;\n\n  @PrimaryKey('RANGE')\n  @Default(() =&gt; `${Date.now()}#${Math.random().toString(36).substr(2, 9)}`)\n  timestamp_id!: string;\n\n  sender_id!: string;\n  content!: string;\n}\n\n// Ensures unique messages even if sent at the same millisecond\n</code></pre>"},{"location":"api/decorators/primary-key/#hierarchical-data-with-sort-key","title":"Hierarchical Data with Sort Key","text":"<pre><code>class FileSystem extends Model {\n  @PrimaryKey('HASH')\n  root_path!: string;\n\n  @PrimaryKey('RANGE')\n  full_path!: string;\n\n  file_type!: 'file' | 'directory';\n  size!: number;\n  created_at!: number;\n}\n\n// Query all files in a directory\nconst files = await FileSystem.query()\n  .where('root_path', '=', '/home/user')\n  .where('full_path', 'beginsWith', '/home/user/documents')\n  .execute();\n</code></pre>"},{"location":"api/decorators/primary-key/#common-patterns","title":"Common Patterns","text":""},{"location":"api/decorators/primary-key/#multi-tenant-application","title":"Multi-Tenant Application","text":"<pre><code>class TenantData extends Model {\n  @PrimaryKey('HASH')\n  tenant_id!: string;\n\n  @PrimaryKey('RANGE')\n  @Default(() =&gt; `DATA#${Date.now()}`)\n  data_key!: string;\n\n  content!: any;\n  metadata!: Record&lt;string, any&gt;;\n}\n\n// Isolate data by tenant\nconst tenant_data = await TenantData.query()\n  .where('tenant_id', '=', 'tenant-abc')\n  .execute();\n</code></pre>"},{"location":"api/decorators/primary-key/#time-series-data","title":"Time-Series Data","text":"<pre><code>class Metric extends Model {\n  @PrimaryKey('HASH')\n  metric_name!: string;\n\n  @PrimaryKey('RANGE')\n  @IndexSort()\n  timestamp!: number;\n\n  value!: number;\n  unit!: string;\n}\n\n// Query metrics for a time range\nconst metrics = await Metric.query()\n  .where('metric_name', '=', 'cpu_usage')\n  .where('timestamp', 'between', [start_time, end_time])\n  .execute();\n</code></pre>"},{"location":"api/decorators/primary-key/#version-controlled-records","title":"Version-Controlled Records","text":"<pre><code>class Document extends Model {\n  @PrimaryKey('HASH')\n  document_id!: string;\n\n  @PrimaryKey('RANGE')\n  @Default(() =&gt; `v${Date.now()}`)\n  version!: string;\n\n  content!: string;\n  author!: string;\n  changes!: string;\n}\n\n// Get latest version\nconst latest = await Document.query()\n  .where('document_id', '=', 'doc123')\n  .sortBy('version', 'DESC')\n  .limit(1)\n  .first();\n</code></pre>"},{"location":"api/decorators/primary-key/#integration-with-other-decorators","title":"Integration with Other Decorators","text":""},{"location":"api/decorators/primary-key/#with-default","title":"With @Default","text":"<pre><code>class Session extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  session_id!: string;\n\n  user_id!: string;\n  expires_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#with-validate","title":"With @Validate","text":"<pre><code>class Account extends Model {\n  @PrimaryKey()\n  @Validate((value) =&gt; /^ACC[0-9]{10}$/.test(value))\n  account_number!: string;\n\n  balance!: number;\n  status!: string;\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#with-mutate","title":"With @Mutate","text":"<pre><code>class Identifier extends Model {\n  @PrimaryKey()\n  @Mutate((value) =&gt; value.toLowerCase().trim())\n  username!: string;\n\n  display_name!: string;\n  email!: string;\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#with-createdat","title":"With @CreatedAt","text":"<pre><code>class AuditLog extends Model {\n  @PrimaryKey('HASH')\n  entity_id!: string;\n\n  @PrimaryKey('RANGE')\n  @CreatedAt()\n  created_at!: number;\n\n  action!: string;\n  user_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#best-practices","title":"Best Practices","text":""},{"location":"api/decorators/primary-key/#1-choose-appropriate-key-types","title":"1. Choose Appropriate Key Types","text":"<pre><code>// Good - Use string for partition keys to avoid hot partitions\nclass Item extends Model {\n  @PrimaryKey()\n  id!: string;  // UUID or prefixed ID\n}\n\n// Avoid - Sequential numbers can create hot partitions\nclass BadItem extends Model {\n  @PrimaryKey()\n  id!: number;  // Sequential auto-increment\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#2-design-for-query-patterns","title":"2. Design for Query Patterns","text":"<pre><code>// Good - Sort key enables range queries\nclass LogEntry extends Model {\n  @PrimaryKey('HASH')\n  service_name!: string;\n\n  @PrimaryKey('RANGE')\n  timestamp!: number;\n\n  level!: string;\n  message!: string;\n}\n\n// Query logs for a service in a time range\nconst logs = await LogEntry.query()\n  .where('service_name', '=', 'api')\n  .where('timestamp', '&gt;', yesterday)\n  .execute();\n</code></pre>"},{"location":"api/decorators/primary-key/#3-use-prefixes-for-clarity","title":"3. Use Prefixes for Clarity","text":"<pre><code>class Resource extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; `USER#${uuidv4()}`)\n  id!: string;\n\n  type!: 'user' | 'admin';\n}\n\n// Makes the entity type immediately clear\n</code></pre>"},{"location":"api/decorators/primary-key/#4-compound-sort-keys-for-flexibility","title":"4. Compound Sort Keys for Flexibility","text":"<pre><code>class Activity extends Model {\n  @PrimaryKey('HASH')\n  user_id!: string;\n\n  @PrimaryKey('RANGE')\n  @Default(() =&gt; `${Date.now()}#${activity_type}`)\n  timestamp_type!: string;\n\n  activity_type!: string;\n  details!: any;\n}\n\n// Enables queries by both time and type\n</code></pre>"},{"location":"api/decorators/primary-key/#5-immutable-primary-keys","title":"5. Immutable Primary Keys","text":"<pre><code>class Record extends Model {\n  @PrimaryKey()\n  private readonly id!: string;\n\n  // Prevent accidental modification\n  get record_id(): string {\n    return this.id;\n  }\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#validation-rules","title":"Validation Rules","text":"<p>The <code>@PrimaryKey</code> decorator enforces several rules:</p> <ol> <li>Required Field: Primary key fields cannot be undefined or null</li> <li>Unique Values: DynamoDB enforces uniqueness for partition key or composite key</li> <li>Supported Types: String, number, or binary data</li> <li>Immutability: Primary key values cannot be changed after creation</li> </ol>"},{"location":"api/decorators/primary-key/#error-handling","title":"Error Handling","text":"<pre><code>try {\n  const user = new User();\n  // Missing primary key\n  await user.save();\n} catch (error) {\n  // Error: Primary key 'id' is required\n}\n\ntry {\n  const order = new OrderItem();\n  order.order_id = 'ORD123';\n  // Missing sort key\n  await order.save();\n} catch (error) {\n  // Error: Sort key 'item_id' is required\n}\n\n// Update with new primary key (not allowed)\nconst existing = await User.find('user123');\nexisting.id = 'user456';  // This will fail\nawait existing.save();\n</code></pre>"},{"location":"api/decorators/primary-key/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/decorators/primary-key/#1-partition-key-distribution","title":"1. Partition Key Distribution","text":"<pre><code>// Good - Distributes load evenly\nclass Event extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; `${Math.floor(Math.random() * 100)}#${Date.now()}`)\n  event_id!: string;\n}\n\n// Avoid - Creates hot partition\nclass BadEvent extends Model {\n  @PrimaryKey()\n  @Default(() =&gt; 'ALL_EVENTS')\n  partition!: string;\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#2-sort-key-for-efficient-queries","title":"2. Sort Key for Efficient Queries","text":"<pre><code>// Efficient - Query specific time range\nclass Transaction extends Model {\n  @PrimaryKey('HASH')\n  account_id!: string;\n\n  @PrimaryKey('RANGE')\n  timestamp!: number;\n}\n\nconst recent = await Transaction.query()\n  .where('account_id', '=', 'ACC123')\n  .where('timestamp', '&gt;', Date.now() - 86400000)\n  .execute();\n</code></pre>"},{"location":"api/decorators/primary-key/#migration-considerations","title":"Migration Considerations","text":"<p>When changing primary key structure:</p> <pre><code>// Old structure\nclass OldUser extends Model {\n  @PrimaryKey()\n  email!: string;\n}\n\n// New structure with UUID\nclass NewUser extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  email!: string;\n}\n\n// Migration script\nasync function migrate() {\n  const old_users = await OldUser.scan().execute();\n\n  for (const old_user of old_users) {\n    const new_user = new NewUser();\n    new_user.id = uuidv4();\n    new_user.email = old_user.email;\n    // Copy other fields\n    await new_user.save();\n  }\n}\n</code></pre>"},{"location":"api/decorators/primary-key/#see-also","title":"See Also","text":"<ul> <li>@IndexSort - Create secondary indexes</li> <li>@Default - Set default values for keys</li> <li>@Validate - Validate key values</li> <li>Query API - Query using primary keys</li> </ul>"},{"location":"api/decorators/relationships/","title":"Relationship Decorators","text":""},{"location":"api/decorators/relationships/#overview","title":"Overview","text":"<p>The <code>@HasMany</code> and <code>@BelongsTo</code> decorators define relationships between models, enabling intuitive navigation and querying of related data. These decorators implement common database relationship patterns in DynamoDB.</p>"},{"location":"api/decorators/relationships/#decorators","title":"Decorators","text":""},{"location":"api/decorators/relationships/#hasmany","title":"@HasMany","text":"<p>Defines a one-to-many relationship where the current model has many instances of another model.</p> <pre><code>@HasMany(model: () =&gt; ModelClass, options?: HasManyOptions)\n</code></pre>"},{"location":"api/decorators/relationships/#belongsto","title":"@BelongsTo","text":"<p>Defines a many-to-one relationship where the current model belongs to another model.</p> <pre><code>@BelongsTo(model: () =&gt; ModelClass, options?: BelongsToOptions)\n</code></pre>"},{"location":"api/decorators/relationships/#parameters","title":"Parameters","text":""},{"location":"api/decorators/relationships/#hasmanyoptions","title":"HasManyOptions","text":"<pre><code>interface HasManyOptions {\n  /** Foreign key property name in related model */\n  foreign_key?: string;\n\n  /** Local key property name (defaults to primary key) */\n  local_key?: string;\n\n  /** Index name for efficient queries */\n  index?: string;\n\n  /** Eager load related models */\n  eager?: boolean;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#belongstooptions","title":"BelongsToOptions","text":"<pre><code>interface BelongsToOptions {\n  /** Foreign key property name (defaults to {model}_id) */\n  foreign_key?: string;\n\n  /** Owner key property name in parent model */\n  owner_key?: string;\n\n  /** Eager load parent model */\n  eager?: boolean;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#basic-usage","title":"Basic Usage","text":""},{"location":"api/decorators/relationships/#one-to-many-relationship","title":"One-to-Many Relationship","text":"<pre><code>import { Model, PrimaryKey, HasMany, BelongsTo } from 'dynamite-orm';\n\nclass User extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  name!: string;\n  email!: string;\n\n  @HasMany(() =&gt; Post)\n  posts!: Post[];\n}\n\nclass Post extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  title!: string;\n  content!: string;\n\n  @BelongsTo(() =&gt; User)\n  user_id!: string;\n}\n\n// Usage\nconst user = await User.find('user123');\nconst posts = await user.posts;  // Lazy load posts\n\nfor (const post of posts) {\n  console.log(post.title);\n}\n</code></pre>"},{"location":"api/decorators/relationships/#accessing-parent","title":"Accessing Parent","text":"<pre><code>const post = await Post.find('post456');\nconst author = await post.user;  // Load parent user\n\nconsole.log(`Written by: ${author.name}`);\n</code></pre>"},{"location":"api/decorators/relationships/#advanced-examples","title":"Advanced Examples","text":""},{"location":"api/decorators/relationships/#custom-foreign-keys","title":"Custom Foreign Keys","text":"<pre><code>class Company extends Model {\n  @PrimaryKey()\n  company_id!: string;\n\n  name!: string;\n\n  @HasMany(() =&gt; Employee, {\n    foreign_key: 'employer_id',\n    local_key: 'company_id'\n  })\n  employees!: Employee[];\n}\n\nclass Employee extends Model {\n  @PrimaryKey()\n  employee_id!: string;\n\n  name!: string;\n\n  @BelongsTo(() =&gt; Company, {\n    foreign_key: 'employer_id',\n    owner_key: 'company_id'\n  })\n  employer_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#multiple-relationships","title":"Multiple Relationships","text":"<pre><code>class BlogPost extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  title!: string;\n  content!: string;\n\n  @BelongsTo(() =&gt; User)\n  author_id!: string;\n\n  @BelongsTo(() =&gt; Category)\n  category_id!: string;\n\n  @HasMany(() =&gt; Comment)\n  comments!: Comment[];\n\n  @HasMany(() =&gt; Like)\n  likes!: Like[];\n}\n\nclass Comment extends Model {\n  @PrimaryKey()\n  comment_id!: string;\n\n  content!: string;\n\n  @BelongsTo(() =&gt; BlogPost)\n  post_id!: string;\n\n  @BelongsTo(() =&gt; User)\n  user_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#nested-relationships","title":"Nested Relationships","text":"<pre><code>class Category extends Model {\n  @PrimaryKey()\n  category_id!: string;\n\n  name!: string;\n\n  @HasMany(() =&gt; Product)\n  products!: Product[];\n}\n\nclass Product extends Model {\n  @PrimaryKey()\n  product_id!: string;\n\n  name!: string;\n\n  @BelongsTo(() =&gt; Category)\n  category_id!: string;\n\n  @HasMany(() =&gt; Review)\n  reviews!: Review[];\n}\n\nclass Review extends Model {\n  @PrimaryKey()\n  review_id!: string;\n\n  rating!: number;\n  content!: string;\n\n  @BelongsTo(() =&gt; Product)\n  product_id!: string;\n\n  @BelongsTo(() =&gt; User)\n  user_id!: string;\n}\n\n// Navigate relationships\nconst category = await Category.find('cat123');\nconst products = await category.products;\n\nfor (const product of products) {\n  const reviews = await product.reviews;\n  console.log(`${product.name}: ${reviews.length} reviews`);\n}\n</code></pre>"},{"location":"api/decorators/relationships/#self-referential-relationships","title":"Self-Referential Relationships","text":"<pre><code>class TreeNode extends Model {\n  @PrimaryKey()\n  node_id!: string;\n\n  name!: string;\n\n  @BelongsTo(() =&gt; TreeNode, {\n    foreign_key: 'parent_id',\n    owner_key: 'node_id'\n  })\n  parent_id?: string;\n\n  @HasMany(() =&gt; TreeNode, {\n    foreign_key: 'parent_id',\n    local_key: 'node_id'\n  })\n  children!: TreeNode[];\n}\n\n// Build tree structure\nconst root = await TreeNode.find('root');\nconst children = await root.children;\n\nfor (const child of children) {\n  const grandchildren = await child.children;\n  console.log(`${child.name} has ${grandchildren.length} children`);\n}\n</code></pre>"},{"location":"api/decorators/relationships/#common-patterns","title":"Common Patterns","text":""},{"location":"api/decorators/relationships/#blog-system","title":"Blog System","text":"<pre><code>class Author extends Model {\n  @PrimaryKey()\n  author_id!: string;\n\n  name!: string;\n  email!: string;\n  bio!: string;\n\n  @HasMany(() =&gt; Article)\n  articles!: Article[];\n\n  @HasMany(() =&gt; Comment)\n  comments!: Comment[];\n}\n\nclass Article extends Model {\n  @PrimaryKey()\n  article_id!: string;\n\n  title!: string;\n  content!: string;\n\n  @BelongsTo(() =&gt; Author)\n  author_id!: string;\n\n  @HasMany(() =&gt; Comment)\n  comments!: Comment[];\n\n  @CreatedAt()\n  created_at!: number;\n}\n\nclass Comment extends Model {\n  @PrimaryKey()\n  comment_id!: string;\n\n  content!: string;\n\n  @BelongsTo(() =&gt; Article)\n  article_id!: string;\n\n  @BelongsTo(() =&gt; Author)\n  author_id!: string;\n\n  @CreatedAt()\n  created_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#e-commerce-system","title":"E-Commerce System","text":"<pre><code>class Customer extends Model {\n  @PrimaryKey()\n  customer_id!: string;\n\n  name!: string;\n  email!: string;\n\n  @HasMany(() =&gt; Order)\n  orders!: Order[];\n\n  @HasMany(() =&gt; Review)\n  reviews!: Review[];\n}\n\nclass Order extends Model {\n  @PrimaryKey()\n  order_id!: string;\n\n  total_amount!: number;\n  status!: string;\n\n  @BelongsTo(() =&gt; Customer)\n  customer_id!: string;\n\n  @HasMany(() =&gt; OrderItem)\n  items!: OrderItem[];\n\n  @CreatedAt()\n  created_at!: number;\n}\n\nclass OrderItem extends Model {\n  @PrimaryKey()\n  item_id!: string;\n\n  quantity!: number;\n  price!: number;\n\n  @BelongsTo(() =&gt; Order)\n  order_id!: string;\n\n  @BelongsTo(() =&gt; Product)\n  product_id!: string;\n}\n\nclass Product extends Model {\n  @PrimaryKey()\n  product_id!: string;\n\n  name!: string;\n  price!: number;\n\n  @HasMany(() =&gt; OrderItem)\n  order_items!: OrderItem[];\n\n  @HasMany(() =&gt; Review)\n  reviews!: Review[];\n}\n\nclass Review extends Model {\n  @PrimaryKey()\n  review_id!: string;\n\n  rating!: number;\n  content!: string;\n\n  @BelongsTo(() =&gt; Product)\n  product_id!: string;\n\n  @BelongsTo(() =&gt; Customer)\n  customer_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#project-management","title":"Project Management","text":"<pre><code>class Team extends Model {\n  @PrimaryKey()\n  team_id!: string;\n\n  name!: string;\n\n  @HasMany(() =&gt; Project)\n  projects!: Project[];\n\n  @HasMany(() =&gt; Member)\n  members!: Member[];\n}\n\nclass Project extends Model {\n  @PrimaryKey()\n  project_id!: string;\n\n  name!: string;\n  description!: string;\n\n  @BelongsTo(() =&gt; Team)\n  team_id!: string;\n\n  @HasMany(() =&gt; Task)\n  tasks!: Task[];\n}\n\nclass Task extends Model {\n  @PrimaryKey()\n  task_id!: string;\n\n  title!: string;\n  status!: string;\n\n  @BelongsTo(() =&gt; Project)\n  project_id!: string;\n\n  @BelongsTo(() =&gt; Member)\n  assigned_to!: string;\n}\n\nclass Member extends Model {\n  @PrimaryKey()\n  member_id!: string;\n\n  name!: string;\n  role!: string;\n\n  @BelongsTo(() =&gt; Team)\n  team_id!: string;\n\n  @HasMany(() =&gt; Task)\n  tasks!: Task[];\n}\n</code></pre>"},{"location":"api/decorators/relationships/#social-network","title":"Social Network","text":"<pre><code>class Profile extends Model {\n  @PrimaryKey()\n  profile_id!: string;\n\n  username!: string;\n  bio!: string;\n\n  @HasMany(() =&gt; Post)\n  posts!: Post[];\n\n  @HasMany(() =&gt; Follow, { foreign_key: 'follower_id' })\n  following!: Follow[];\n\n  @HasMany(() =&gt; Follow, { foreign_key: 'following_id' })\n  followers!: Follow[];\n}\n\nclass Post extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  content!: string;\n\n  @BelongsTo(() =&gt; Profile)\n  profile_id!: string;\n\n  @HasMany(() =&gt; Like)\n  likes!: Like[];\n\n  @HasMany(() =&gt; Comment)\n  comments!: Comment[];\n\n  @CreatedAt()\n  created_at!: number;\n}\n\nclass Follow extends Model {\n  @PrimaryKey()\n  follow_id!: string;\n\n  @BelongsTo(() =&gt; Profile, { foreign_key: 'follower_id' })\n  follower_id!: string;\n\n  @BelongsTo(() =&gt; Profile, { foreign_key: 'following_id' })\n  following_id!: string;\n\n  @CreatedAt()\n  created_at!: number;\n}\n\nclass Like extends Model {\n  @PrimaryKey()\n  like_id!: string;\n\n  @BelongsTo(() =&gt; Post)\n  post_id!: string;\n\n  @BelongsTo(() =&gt; Profile)\n  profile_id!: string;\n\n  @CreatedAt()\n  created_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#integration-with-other-decorators","title":"Integration with Other Decorators","text":""},{"location":"api/decorators/relationships/#with-indexsort","title":"With @IndexSort","text":"<pre><code>class OptimizedPost extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  title!: string;\n\n  @BelongsTo(() =&gt; User)\n  @IndexSort()  // Index for efficient relationship queries\n  user_id!: string;\n\n  @CreatedAt()\n  @IndexSort()\n  created_at!: number;\n}\n\n// Efficient query\nconst user_posts = await OptimizedPost.query()\n  .usingIndex('user_id')\n  .where('user_id', '=', 'user123')\n  .execute();\n</code></pre>"},{"location":"api/decorators/relationships/#with-validate","title":"With @Validate","text":"<pre><code>class ValidatedRelationship extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @BelongsTo(() =&gt; Parent)\n  @Validate(async (value) =&gt; {\n    const parent = await Parent.find(value);\n    return parent !== null || 'Parent does not exist';\n  })\n  parent_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#with-timestamps","title":"With Timestamps","text":"<pre><code>class TimestampedRelation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @BelongsTo(() =&gt; Parent)\n  parent_id!: string;\n\n  @CreatedAt()\n  created_at!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#best-practices","title":"Best Practices","text":""},{"location":"api/decorators/relationships/#1-use-indexes-for-foreign-keys","title":"1. Use Indexes for Foreign Keys","text":"<pre><code>// Good - Indexed foreign key\nclass GoodRelation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @BelongsTo(() =&gt; Parent)\n  @IndexSort()\n  parent_id!: string;\n}\n\n// Avoid - Unindexed foreign key\nclass SlowRelation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @BelongsTo(() =&gt; Parent)\n  parent_id!: string;  // \u274c Slow queries\n}\n</code></pre>"},{"location":"api/decorators/relationships/#2-lazy-load-by-default","title":"2. Lazy Load by Default","text":"<pre><code>// Good - Lazy loading\nclass LazyPost extends Model {\n  @HasMany(() =&gt; Comment)\n  comments!: Comment[];\n\n  async get_comments(): Promise&lt;Comment[]&gt; {\n    return await this.comments;  // Load when needed\n  }\n}\n\n// Avoid - Eager loading everything\nclass EagerPost extends Model {\n  @HasMany(() =&gt; Comment, { eager: true })\n  comments!: Comment[];  // \u274c Always loaded, even when not needed\n}\n</code></pre>"},{"location":"api/decorators/relationships/#3-name-foreign-keys-clearly","title":"3. Name Foreign Keys Clearly","text":"<pre><code>// Good - Clear naming\nclass ClearRelation extends Model {\n  @BelongsTo(() =&gt; User)\n  author_id!: string;\n\n  @BelongsTo(() =&gt; User)\n  reviewer_id!: string;\n}\n\n// Avoid - Ambiguous naming\nclass ConfusingRelation extends Model {\n  @BelongsTo(() =&gt; User)\n  user_id_1!: string;  // \u274c What does this represent?\n\n  @BelongsTo(() =&gt; User)\n  user_id_2!: string;  // \u274c Unclear purpose\n}\n</code></pre>"},{"location":"api/decorators/relationships/#4-validate-relationships","title":"4. Validate Relationships","text":"<pre><code>class SafeRelation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @BelongsTo(() =&gt; Parent)\n  @Validate(async (value) =&gt; {\n    if (!value) return 'Parent ID required';\n\n    const exists = await Parent.find(value);\n    return exists !== null || 'Parent not found';\n  })\n  parent_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#5-document-complex-relationships","title":"5. Document Complex Relationships","text":"<pre><code>class WellDocumented extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  /**\n   * References the author of this post.\n   * Each post has exactly one author.\n   */\n  @BelongsTo(() =&gt; User)\n  author_id!: string;\n\n  /**\n   * References the user who last edited this post.\n   * May be different from the original author.\n   */\n  @BelongsTo(() =&gt; User, { foreign_key: 'editor_id' })\n  editor_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#eager-loading","title":"Eager Loading","text":""},{"location":"api/decorators/relationships/#basic-eager-loading","title":"Basic Eager Loading","text":"<pre><code>class Post extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  title!: string;\n\n  @BelongsTo(() =&gt; User, { eager: true })\n  user_id!: string;\n}\n\n// User is automatically loaded\nconst post = await Post.find('post123');\nconst author_name = post.user.name;  // No additional query\n</code></pre>"},{"location":"api/decorators/relationships/#selective-eager-loading","title":"Selective Eager Loading","text":"<pre><code>class Article extends Model {\n  @PrimaryKey()\n  article_id!: string;\n\n  @BelongsTo(() =&gt; Author)\n  author_id!: string;\n\n  @HasMany(() =&gt; Comment)\n  comments!: Comment[];\n\n  async load_with_relations(): Promise&lt;void&gt; {\n    // Load author\n    this.author = await Author.find(this.author_id);\n\n    // Load comments\n    this.comments = await Comment.query()\n      .where('article_id', '=', this.article_id)\n      .execute();\n  }\n}\n</code></pre>"},{"location":"api/decorators/relationships/#performance-optimization","title":"Performance Optimization","text":""},{"location":"api/decorators/relationships/#batch-loading","title":"Batch Loading","text":"<pre><code>async function load_posts_with_authors(post_ids: string[]): Promise&lt;Post[]&gt; {\n  const posts = await Post.batchGet(post_ids);\n  const author_ids = [...new Set(posts.map(p =&gt; p.author_id))];\n  const authors = await User.batchGet(author_ids);\n\n  const author_map = new Map(authors.map(a =&gt; [a.user_id, a]));\n\n  for (const post of posts) {\n    post.author = author_map.get(post.author_id);\n  }\n\n  return posts;\n}\n</code></pre>"},{"location":"api/decorators/relationships/#caching-relationships","title":"Caching Relationships","text":"<pre><code>class CachedRelation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @BelongsTo(() =&gt; Parent)\n  parent_id!: string;\n\n  private _cached_parent?: Parent;\n\n  async get_parent(): Promise&lt;Parent&gt; {\n    if (!this._cached_parent) {\n      this._cached_parent = await Parent.find(this.parent_id);\n    }\n    return this._cached_parent;\n  }\n}\n</code></pre>"},{"location":"api/decorators/relationships/#denormalization","title":"Denormalization","text":"<pre><code>class OptimizedPost extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  title!: string;\n\n  @BelongsTo(() =&gt; User)\n  author_id!: string;\n\n  // Denormalized data for performance\n  author_name!: string;\n  author_avatar!: string;\n\n  async set_author(author: User): Promise&lt;void&gt; {\n    this.author_id = author.user_id;\n    this.author_name = author.name;\n    this.author_avatar = author.avatar_url;\n  }\n}\n</code></pre>"},{"location":"api/decorators/relationships/#testing-relationships","title":"Testing Relationships","text":"<pre><code>import { describe, it, expect } from 'vitest';\n\ndescribe('Relationships', () =&gt; {\n  it('should load related models', async () =&gt; {\n    const user = new User();\n    user.user_id = 'user123';\n    await user.save();\n\n    const post = new Post();\n    post.post_id = 'post123';\n    post.user_id = user.user_id;\n    await post.save();\n\n    const loaded_posts = await user.posts;\n    expect(loaded_posts).toHaveLength(1);\n    expect(loaded_posts[0].post_id).toBe(post.post_id);\n  });\n\n  it('should load parent model', async () =&gt; {\n    const user = new User();\n    user.user_id = 'user123';\n    user.name = 'John Doe';\n    await user.save();\n\n    const post = new Post();\n    post.post_id = 'post123';\n    post.user_id = user.user_id;\n    await post.save();\n\n    const author = await post.user;\n    expect(author.name).toBe('John Doe');\n  });\n});\n</code></pre>"},{"location":"api/decorators/relationships/#migration-patterns","title":"Migration Patterns","text":""},{"location":"api/decorators/relationships/#adding-relationships","title":"Adding Relationships","text":"<pre><code>// Step 1: Add relationship decorators\nclass Post extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  // New relationship\n  @BelongsTo(() =&gt; Category)\n  @IndexSort()\n  category_id!: string;\n}\n\n// Step 2: Backfill data\nasync function add_categories() {\n  const posts = await Post.scan().execute();\n\n  for (const post of posts) {\n    if (!post.category_id) {\n      post.category_id = 'uncategorized';\n      await post.save();\n    }\n  }\n}\n</code></pre>"},{"location":"api/decorators/relationships/#changing-relationships","title":"Changing Relationships","text":"<pre><code>// Old structure\nclass OldPost extends Model {\n  @BelongsTo(() =&gt; User)\n  user_id!: string;\n}\n\n// New structure with separate author and editor\nclass NewPost extends Model {\n  @BelongsTo(() =&gt; User)\n  author_id!: string;\n\n  @BelongsTo(() =&gt; User)\n  editor_id!: string;\n}\n\n// Migration\nasync function split_user_relation() {\n  const posts = await OldPost.scan().execute();\n\n  for (const post of posts) {\n    const new_post = new NewPost();\n    new_post.author_id = post.user_id;\n    new_post.editor_id = post.user_id;  // Initially same as author\n    // Copy other fields\n    await new_post.save();\n  }\n}\n</code></pre>"},{"location":"api/decorators/relationships/#see-also","title":"See Also","text":"<ul> <li>@IndexSort - Index foreign keys</li> <li>@Validate - Validate relationships</li> <li>Query API - Query related models</li> <li>Performance Guide - Relationship optimization</li> </ul>"},{"location":"api/decorators/timestamps/","title":"Timestamp Decorators","text":""},{"location":"api/decorators/timestamps/#overview","title":"Overview","text":"<p>The <code>@CreatedAt</code> and <code>@UpdatedAt</code> decorators automatically manage creation and modification timestamps for your models. These decorators are essential for audit trails, temporal queries, and tracking data lifecycle.</p>"},{"location":"api/decorators/timestamps/#decorators","title":"Decorators","text":""},{"location":"api/decorators/timestamps/#createdat","title":"@CreatedAt","text":"<p>Automatically sets the timestamp when a model instance is first created. The value is set once and never updated.</p> <pre><code>@CreatedAt(options?: TimestampOptions)\n</code></pre>"},{"location":"api/decorators/timestamps/#updatedat","title":"@UpdatedAt","text":"<p>Automatically updates the timestamp whenever a model instance is modified and saved.</p> <pre><code>@UpdatedAt(options?: TimestampOptions)\n</code></pre>"},{"location":"api/decorators/timestamps/#parameters","title":"Parameters","text":""},{"location":"api/decorators/timestamps/#timestampoptions","title":"TimestampOptions","text":"<pre><code>interface TimestampOptions {\n  /** Format: 'timestamp' (default) or 'iso' */\n  format?: 'timestamp' | 'iso';\n\n  /** Precision: 'milliseconds' (default) or 'seconds' */\n  precision?: 'milliseconds' | 'seconds';\n\n  /** Custom timestamp generator function */\n  generator?: () =&gt; number | string;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#basic-usage","title":"Basic Usage","text":""},{"location":"api/decorators/timestamps/#default-timestamps","title":"Default Timestamps","text":"<pre><code>import { Model, PrimaryKey, CreatedAt, UpdatedAt } from 'dynamite-orm';\n\nclass User extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  name!: string;\n  email!: string;\n\n  @CreatedAt()\n  created_at!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n}\n\nconst user = new User();\nuser.id = 'user123';\nuser.name = 'John Doe';\nawait user.save();\n// created_at = 1704067200000\n// updated_at = 1704067200000\n\nuser.name = 'Jane Doe';\nawait user.save();\n// created_at = 1704067200000 (unchanged)\n// updated_at = 1704067210000 (updated)\n</code></pre>"},{"location":"api/decorators/timestamps/#iso-format","title":"ISO Format","text":"<pre><code>class Article extends Model {\n  @PrimaryKey()\n  article_id!: string;\n\n  title!: string;\n  content!: string;\n\n  @CreatedAt({ format: 'iso' })\n  created_at!: string;\n\n  @UpdatedAt({ format: 'iso' })\n  updated_at!: string;\n}\n\nconst article = new Article();\narticle.article_id = 'art123';\narticle.title = 'My Article';\nawait article.save();\n// created_at = '2024-01-01T00:00:00.000Z'\n// updated_at = '2024-01-01T00:00:00.000Z'\n</code></pre>"},{"location":"api/decorators/timestamps/#unix-seconds","title":"Unix Seconds","text":"<pre><code>class Event extends Model {\n  @PrimaryKey()\n  event_id!: string;\n\n  name!: string;\n\n  @CreatedAt({ precision: 'seconds' })\n  created_at!: number;\n\n  @UpdatedAt({ precision: 'seconds' })\n  updated_at!: number;\n}\n\nconst event = new Event();\nevent.event_id = 'evt123';\nawait event.save();\n// created_at = 1704067200\n// updated_at = 1704067200\n</code></pre>"},{"location":"api/decorators/timestamps/#advanced-examples","title":"Advanced Examples","text":""},{"location":"api/decorators/timestamps/#custom-timestamp-generator","title":"Custom Timestamp Generator","text":"<pre><code>class CustomTimestamp extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @CreatedAt({\n    generator: () =&gt; {\n      const now = new Date();\n      return now.getTime() + now.getTimezoneOffset() * 60000;  // UTC\n    }\n  })\n  created_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#multiple-timestamp-formats","title":"Multiple Timestamp Formats","text":"<pre><code>class AuditLog extends Model {\n  @PrimaryKey()\n  log_id!: string;\n\n  action!: string;\n\n  @CreatedAt({ precision: 'milliseconds' })\n  created_at_ms!: number;\n\n  @CreatedAt({ precision: 'seconds' })\n  created_at_sec!: number;\n\n  @CreatedAt({ format: 'iso' })\n  created_at_iso!: string;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#compound-keys-with-timestamps","title":"Compound Keys with Timestamps","text":"<pre><code>class Message extends Model {\n  @PrimaryKey('HASH')\n  chat_room_id!: string;\n\n  @PrimaryKey('RANGE')\n  @CreatedAt()\n  timestamp!: number;\n\n  sender_id!: string;\n  content!: string;\n\n  @UpdatedAt()\n  edited_at!: number;\n}\n\n// Query messages in chronological order\nconst messages = await Message.query()\n  .where('chat_room_id', '=', 'room123')\n  .sortBy('timestamp', 'ASC')\n  .execute();\n</code></pre>"},{"location":"api/decorators/timestamps/#soft-delete-with-timestamps","title":"Soft Delete with Timestamps","text":"<pre><code>class SoftDeletable extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  name!: string;\n\n  @CreatedAt()\n  created_at!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n\n  deleted_at?: number;\n\n  async soft_delete(): Promise&lt;void&gt; {\n    this.deleted_at = Date.now();\n    await this.save();\n  }\n\n  is_deleted(): boolean {\n    return this.deleted_at !== undefined;\n  }\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#common-patterns","title":"Common Patterns","text":""},{"location":"api/decorators/timestamps/#audit-trail","title":"Audit Trail","text":"<pre><code>class AuditedModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  data!: any;\n\n  @CreatedAt()\n  created_at!: number;\n\n  created_by!: string;\n\n  @UpdatedAt()\n  updated_at!: number;\n\n  updated_by!: string;\n\n  version!: number;\n\n  async save_with_audit(user_id: string): Promise&lt;void&gt; {\n    if (!this.created_at) {\n      this.created_by = user_id;\n      this.version = 1;\n    } else {\n      this.updated_by = user_id;\n      this.version += 1;\n    }\n\n    await this.save();\n  }\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#time-based-indexing","title":"Time-Based Indexing","text":"<pre><code>class IndexedTimestamp extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  title!: string;\n\n  @CreatedAt()\n  @IndexSort()\n  created_at!: number;\n\n  @UpdatedAt()\n  @IndexSort()\n  updated_at!: number;\n}\n\n// Query recently created items\nconst recent = await IndexedTimestamp.query()\n  .usingIndex('created_at')\n  .where('created_at', '&gt;', Date.now() - 86400000)\n  .execute();\n\n// Query recently updated items\nconst updated = await IndexedTimestamp.query()\n  .usingIndex('updated_at')\n  .where('updated_at', '&gt;', Date.now() - 3600000)\n  .execute();\n</code></pre>"},{"location":"api/decorators/timestamps/#expiration-tracking","title":"Expiration Tracking","text":"<pre><code>class ExpiringItem extends Model {\n  @PrimaryKey()\n  item_id!: string;\n\n  content!: string;\n\n  @CreatedAt()\n  created_at!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n\n  ttl_seconds!: number;\n\n  get expires_at(): number {\n    return this.created_at + this.ttl_seconds * 1000;\n  }\n\n  is_expired(): boolean {\n    return Date.now() &gt; this.expires_at;\n  }\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#version-history","title":"Version History","text":"<pre><code>class VersionedDocument extends Model {\n  @PrimaryKey('HASH')\n  document_id!: string;\n\n  @PrimaryKey('RANGE')\n  @CreatedAt()\n  version_timestamp!: number;\n\n  content!: string;\n  author!: string;\n  changes!: string;\n\n  @UpdatedAt()\n  modified_at!: number;\n}\n\n// Create new version\nasync function create_version(doc_id: string, content: string, author: string) {\n  const version = new VersionedDocument();\n  version.document_id = doc_id;\n  version.content = content;\n  version.author = author;\n  await version.save();\n  return version;\n}\n\n// Get version history\nasync function get_history(doc_id: string) {\n  return await VersionedDocument.query()\n    .where('document_id', '=', doc_id)\n    .sortBy('version_timestamp', 'DESC')\n    .execute();\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#activity-timeline","title":"Activity Timeline","text":"<pre><code>class Activity extends Model {\n  @PrimaryKey('HASH')\n  user_id!: string;\n\n  @PrimaryKey('RANGE')\n  @CreatedAt()\n  timestamp!: number;\n\n  activity_type!: 'login' | 'logout' | 'action' | 'error';\n  details!: Record&lt;string, any&gt;;\n\n  @UpdatedAt()\n  updated_at!: number;\n}\n\n// Get user activity timeline\nasync function get_user_timeline(user_id: string, days: number = 7) {\n  const since = Date.now() - days * 24 * 60 * 60 * 1000;\n\n  return await Activity.query()\n    .where('user_id', '=', user_id)\n    .where('timestamp', '&gt;', since)\n    .sortBy('timestamp', 'DESC')\n    .execute();\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#time-based-partitioning","title":"Time-Based Partitioning","text":"<pre><code>class TimeSeriesData extends Model {\n  @PrimaryKey('HASH')\n  get partition_key(): string {\n    const date = new Date(this.timestamp);\n    return `${this.metric_name}#${date.getFullYear()}-${date.getMonth() + 1}`;\n  }\n\n  @PrimaryKey('RANGE')\n  @CreatedAt()\n  timestamp!: number;\n\n  metric_name!: string;\n  value!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#integration-with-other-decorators","title":"Integration with Other Decorators","text":""},{"location":"api/decorators/timestamps/#with-indexsort","title":"With @IndexSort","text":"<pre><code>class SearchableContent extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  title!: string;\n  content!: string;\n\n  @CreatedAt()\n  @IndexSort({ name: 'created_index' })\n  created_at!: number;\n\n  @UpdatedAt()\n  @IndexSort({ name: 'updated_index' })\n  updated_at!: number;\n\n  @IndexSort({ name: 'status_updated_index' })\n  status!: string;\n}\n\n// Query by status and recent updates\nconst recent_published = await SearchableContent.query()\n  .usingIndex('status_updated_index')\n  .where('status', '=', 'published')\n  .where('updated_at', '&gt;', Date.now() - 86400000)\n  .execute();\n</code></pre>"},{"location":"api/decorators/timestamps/#with-default","title":"With @Default","text":"<pre><code>class DefaultTimestamps extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default(() =&gt; Date.now())\n  @CreatedAt()\n  created_at!: number;\n\n  @Default(() =&gt; Date.now())\n  @UpdatedAt()\n  updated_at!: number;\n\n  // @Default is redundant with timestamp decorators\n  // but can be used for manual control\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#with-validate","title":"With @Validate","text":"<pre><code>class ValidatedTimestamps extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @CreatedAt()\n  @Validate((value) =&gt; value &lt;= Date.now())\n  created_at!: number;\n\n  @UpdatedAt()\n  @Validate((value, context) =&gt; {\n    const created = context?.instance.created_at;\n    return value &gt;= created || 'Updated time must be after creation';\n  })\n  updated_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#with-relationships","title":"With Relationships","text":"<pre><code>class Post extends Model {\n  @PrimaryKey()\n  post_id!: string;\n\n  title!: string;\n  content!: string;\n\n  @BelongsTo(() =&gt; User)\n  author_id!: string;\n\n  @CreatedAt()\n  created_at!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n\n  @HasMany(() =&gt; Comment)\n  comments!: Comment[];\n}\n\nclass Comment extends Model {\n  @PrimaryKey()\n  comment_id!: string;\n\n  content!: string;\n\n  @BelongsTo(() =&gt; Post)\n  post_id!: string;\n\n  @CreatedAt()\n  created_at!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#best-practices","title":"Best Practices","text":""},{"location":"api/decorators/timestamps/#1-always-include-both-timestamps","title":"1. Always Include Both Timestamps","text":"<pre><code>// Good - Track both creation and updates\nclass GoodModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @CreatedAt()\n  created_at!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n}\n\n// Avoid - Missing update tracking\nclass IncompleteModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @CreatedAt()\n  created_at!: number;\n  // \u274c No updated_at\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#2-use-milliseconds-for-precision","title":"2. Use Milliseconds for Precision","text":"<pre><code>// Good - Millisecond precision\nclass Precise extends Model {\n  @CreatedAt({ precision: 'milliseconds' })\n  created_at!: number;\n}\n\n// Use seconds only when appropriate\nclass Approximate extends Model {\n  @CreatedAt({ precision: 'seconds' })\n  created_at!: number;  // For TTL or less precise needs\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#3-index-timestamps-for-queries","title":"3. Index Timestamps for Queries","text":"<pre><code>// Good - Indexed for efficient queries\nclass QueryableTimestamps extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @CreatedAt()\n  @IndexSort()\n  created_at!: number;\n\n  @UpdatedAt()\n  @IndexSort()\n  updated_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#4-document-timestamp-usage","title":"4. Document Timestamp Usage","text":"<pre><code>class WellDocumented extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  /**\n   * Unix timestamp in milliseconds when record was created.\n   * Set automatically on first save, never updated.\n   */\n  @CreatedAt()\n  created_at!: number;\n\n  /**\n   * Unix timestamp in milliseconds when record was last modified.\n   * Updated automatically on every save operation.\n   */\n  @UpdatedAt()\n  updated_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#5-consider-time-zones","title":"5. Consider Time Zones","text":"<pre><code>class TimeZoneAware extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @CreatedAt()\n  created_at!: number;  // Store as UTC timestamp\n\n  timezone!: string;  // Store user's timezone separately\n\n  get local_created_at(): string {\n    return new Date(this.created_at)\n      .toLocaleString('en-US', { timeZone: this.timezone });\n  }\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#query-patterns","title":"Query Patterns","text":""},{"location":"api/decorators/timestamps/#time-range-queries","title":"Time Range Queries","text":"<pre><code>// Last 24 hours\nconst recent = await Model.query()\n  .where('created_at', '&gt;', Date.now() - 86400000)\n  .execute();\n\n// Between dates\nconst range = await Model.query()\n  .where('created_at', 'between', [start_date, end_date])\n  .execute();\n\n// Before date\nconst older = await Model.query()\n  .where('created_at', '&lt;', cutoff_date)\n  .execute();\n</code></pre>"},{"location":"api/decorators/timestamps/#sorting-by-timestamps","title":"Sorting by Timestamps","text":"<pre><code>// Newest first\nconst newest = await Model.scan()\n  .sortBy('created_at', 'DESC')\n  .limit(10)\n  .execute();\n\n// Oldest first\nconst oldest = await Model.scan()\n  .sortBy('created_at', 'ASC')\n  .limit(10)\n  .execute();\n</code></pre>"},{"location":"api/decorators/timestamps/#recently-modified","title":"Recently Modified","text":"<pre><code>async function get_recently_modified(hours: number = 1) {\n  const since = Date.now() - hours * 60 * 60 * 1000;\n\n  return await Model.query()\n    .usingIndex('updated_at')\n    .where('updated_at', '&gt;', since)\n    .sortBy('updated_at', 'DESC')\n    .execute();\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/decorators/timestamps/#1-index-strategy","title":"1. Index Strategy","text":"<pre><code>// Index both timestamps if querying frequently\nclass OptimizedTimestamps extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @CreatedAt()\n  @IndexSort({ name: 'created_index' })\n  created_at!: number;\n\n  @UpdatedAt()\n  @IndexSort({ name: 'updated_index' })\n  updated_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#2-composite-indexes","title":"2. Composite Indexes","text":"<pre><code>// Combine status with timestamp for efficient queries\nclass CompositeIndex extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @IndexSort({ name: 'status_time_index' })\n  status!: string;\n\n  @IndexSort({ name: 'status_time_index' })\n  @CreatedAt()\n  created_at!: number;\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#3-sparse-indexes","title":"3. Sparse Indexes","text":"<pre><code>// Index only when certain conditions met\nclass SparseTimestamp extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @CreatedAt()\n  created_at!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n\n  @IndexSort()\n  published_at?: number;  // Only indexed when published\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#migration-patterns","title":"Migration Patterns","text":""},{"location":"api/decorators/timestamps/#adding-timestamps-to-existing-models","title":"Adding Timestamps to Existing Models","text":"<pre><code>// Step 1: Add decorators\nclass ExistingModel extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  data!: any;\n\n  // New fields\n  @CreatedAt()\n  created_at!: number;\n\n  @UpdatedAt()\n  updated_at!: number;\n}\n\n// Step 2: Backfill existing records\nasync function backfill_timestamps() {\n  const items = await ExistingModel.scan().execute();\n\n  for (const item of items) {\n    if (!item.created_at) {\n      item.created_at = Date.now();\n      item.updated_at = Date.now();\n      await item.save();\n    }\n  }\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#changing-timestamp-format","title":"Changing Timestamp Format","text":"<pre><code>// Convert from seconds to milliseconds\nasync function convert_timestamps() {\n  const items = await Model.scan().execute();\n\n  for (const item of items) {\n    if (item.created_at &lt; 10000000000) {  // Seconds\n      item.created_at *= 1000;  // Convert to milliseconds\n      item.updated_at *= 1000;\n      await item.save();\n    }\n  }\n}\n</code></pre>"},{"location":"api/decorators/timestamps/#testing-timestamps","title":"Testing Timestamps","text":"<pre><code>import { describe, it, expect, vi } from 'vitest';\n\ndescribe('Timestamp Decorators', () =&gt; {\n  it('should set created_at on first save', async () =&gt; {\n    const model = new TestModel();\n    expect(model.created_at).toBeUndefined();\n\n    await model.save();\n    expect(model.created_at).toBeDefined();\n    expect(model.created_at).toBeCloseTo(Date.now(), -2);\n  });\n\n  it('should update updated_at on save', async () =&gt; {\n    const model = new TestModel();\n    await model.save();\n\n    const initial_updated = model.updated_at;\n\n    vi.advanceTimersByTime(1000);\n    model.data = 'changed';\n    await model.save();\n\n    expect(model.updated_at).toBeGreaterThan(initial_updated);\n  });\n\n  it('should not change created_at on update', async () =&gt; {\n    const model = new TestModel();\n    await model.save();\n\n    const initial_created = model.created_at;\n\n    model.data = 'changed';\n    await model.save();\n\n    expect(model.created_at).toBe(initial_created);\n  });\n});\n</code></pre>"},{"location":"api/decorators/timestamps/#see-also","title":"See Also","text":"<ul> <li>@IndexSort - Index timestamps for queries</li> <li>@Default - Alternative default value approach</li> <li>Query API - Time-based queries</li> <li>Performance Guide - Timestamp indexing strategies</li> </ul>"},{"location":"api/decorators/validate/","title":"@Validate Decorator","text":""},{"location":"api/decorators/validate/#overview","title":"Overview","text":"<p>The <code>@Validate</code> decorator provides runtime validation for model properties, ensuring data integrity before persistence. It supports custom validation functions, built-in validators, and asynchronous validation logic.</p>"},{"location":"api/decorators/validate/#syntax","title":"Syntax","text":"<pre><code>@Validate(validator: ValidatorFunction | ValidatorFunction[], options?: ValidateOptions)\n</code></pre>"},{"location":"api/decorators/validate/#parameters","title":"Parameters","text":""},{"location":"api/decorators/validate/#validatorfunction","title":"ValidatorFunction","text":"<pre><code>type ValidatorFunction = (value: any, context?: ValidationContext) =&gt; boolean | string | Promise&lt;boolean | string&gt;;\n</code></pre> <ul> <li>Returns: <code>true</code> if valid, <code>false</code> or error message string if invalid</li> <li>Async: Can return a Promise for asynchronous validation</li> </ul>"},{"location":"api/decorators/validate/#validationcontext","title":"ValidationContext","text":"<pre><code>interface ValidationContext {\n  /** Current model instance */\n  instance: Model;\n\n  /** Property name being validated */\n  property: string;\n\n  /** All property values */\n  values: Record&lt;string, any&gt;;\n}\n</code></pre>"},{"location":"api/decorators/validate/#validateoptions","title":"ValidateOptions","text":"<pre><code>interface ValidateOptions {\n  /** Custom error message */\n  message?: string;\n\n  /** Skip validation when value is undefined */\n  allow_undefined?: boolean;\n\n  /** Skip validation when value is null */\n  allow_null?: boolean;\n}\n</code></pre>"},{"location":"api/decorators/validate/#basic-usage","title":"Basic Usage","text":""},{"location":"api/decorators/validate/#simple-validation","title":"Simple Validation","text":"<pre><code>import { Model, PrimaryKey, Validate } from 'dynamite-orm';\n\nclass User extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate((value) =&gt; value.length &gt;= 3)\n  username!: string;\n\n  @Validate((value) =&gt; value.includes('@'))\n  email!: string;\n\n  @Validate((value) =&gt; value &gt;= 18)\n  age!: number;\n}\n\nconst user = new User();\nuser.username = 'ab';  // Will fail validation\nawait user.save();  // Throws validation error\n</code></pre>"},{"location":"api/decorators/validate/#custom-error-messages","title":"Custom Error Messages","text":"<pre><code>class Product extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate(\n    (value) =&gt; value &gt; 0 || 'Price must be positive',\n    { message: 'Invalid price value' }\n  )\n  price!: number;\n\n  @Validate(\n    (value) =&gt; value &gt;= 0 || 'Stock cannot be negative'\n  )\n  stock_count!: number;\n}\n</code></pre>"},{"location":"api/decorators/validate/#advanced-examples","title":"Advanced Examples","text":""},{"location":"api/decorators/validate/#multiple-validators","title":"Multiple Validators","text":"<pre><code>class Account extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate([\n    (value) =&gt; value.length &gt;= 8 || 'Password must be at least 8 characters',\n    (value) =&gt; /[A-Z]/.test(value) || 'Password must contain uppercase letter',\n    (value) =&gt; /[a-z]/.test(value) || 'Password must contain lowercase letter',\n    (value) =&gt; /[0-9]/.test(value) || 'Password must contain number',\n    (value) =&gt; /[^A-Za-z0-9]/.test(value) || 'Password must contain special character'\n  ])\n  password!: string;\n\n  username!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#regular-expression-validation","title":"Regular Expression Validation","text":"<pre><code>class Contact extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate((value) =&gt; /^[A-Z][a-z]+ [A-Z][a-z]+$/.test(value) || 'Invalid name format')\n  full_name!: string;\n\n  @Validate((value) =&gt; /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value) || 'Invalid email')\n  email!: string;\n\n  @Validate((value) =&gt; /^\\+?[1-9]\\d{1,14}$/.test(value) || 'Invalid phone number')\n  phone!: string;\n\n  @Validate((value) =&gt; /^https?:\\/\\/.+/.test(value) || 'Invalid URL')\n  website!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#range-validation","title":"Range Validation","text":"<pre><code>class Rating extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate((value) =&gt; value &gt;= 1 &amp;&amp; value &lt;= 5 || 'Rating must be between 1 and 5')\n  stars!: number;\n\n  @Validate((value) =&gt; value.length &lt;= 500 || 'Review must be 500 characters or less')\n  review!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#enum-validation","title":"Enum Validation","text":"<pre><code>class Order extends Model {\n  @PrimaryKey()\n  order_id!: string;\n\n  @Validate((value) =&gt; ['pending', 'processing', 'shipped', 'delivered', 'cancelled'].includes(value))\n  status!: string;\n\n  @Validate((value) =&gt; ['standard', 'express', 'overnight'].includes(value))\n  shipping_method!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#async-validation","title":"Async Validation","text":"<pre><code>class UniqueUser extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate(async (value, context) =&gt; {\n    const existing = await UniqueUser.query()\n      .where('email', '=', value)\n      .first();\n\n    if (existing &amp;&amp; existing.id !== context?.instance.id) {\n      return 'Email already exists';\n    }\n    return true;\n  })\n  email!: string;\n\n  username!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#contextual-validation","title":"Contextual Validation","text":"<pre><code>class Employee extends Model {\n  @PrimaryKey()\n  employee_id!: string;\n\n  role!: 'staff' | 'manager' | 'admin';\n\n  @Validate((value, context) =&gt; {\n    const role = context?.instance.role;\n    if (role === 'admin') {\n      return value &gt;= 100000 || 'Admin salary must be at least $100,000';\n    } else if (role === 'manager') {\n      return value &gt;= 70000 || 'Manager salary must be at least $70,000';\n    }\n    return value &gt;= 40000 || 'Staff salary must be at least $40,000';\n  })\n  salary!: number;\n}\n</code></pre>"},{"location":"api/decorators/validate/#array-validation","title":"Array Validation","text":"<pre><code>class Task extends Model {\n  @PrimaryKey()\n  task_id!: string;\n\n  @Validate([\n    (value) =&gt; Array.isArray(value) || 'Tags must be an array',\n    (value) =&gt; value.length &lt;= 10 || 'Maximum 10 tags allowed',\n    (value) =&gt; value.every((tag: string) =&gt; typeof tag === 'string') || 'Tags must be strings',\n    (value) =&gt; value.every((tag: string) =&gt; tag.length &lt;= 20) || 'Tags must be 20 chars or less'\n  ])\n  tags!: string[];\n}\n</code></pre>"},{"location":"api/decorators/validate/#object-validation","title":"Object Validation","text":"<pre><code>class Profile extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  @Validate([\n    (value) =&gt; typeof value === 'object' || 'Address must be an object',\n    (value) =&gt; value.street &amp;&amp; value.city &amp;&amp; value.zip || 'Address incomplete',\n    (value) =&gt; /^\\d{5}(-\\d{4})?$/.test(value.zip) || 'Invalid zip code'\n  ])\n  address!: {\n    street: string;\n    city: string;\n    state: string;\n    zip: string;\n  };\n}\n</code></pre>"},{"location":"api/decorators/validate/#common-patterns","title":"Common Patterns","text":""},{"location":"api/decorators/validate/#credit-card-validation","title":"Credit Card Validation","text":"<pre><code>class Payment extends Model {\n  @PrimaryKey()\n  payment_id!: string;\n\n  @Validate((value) =&gt; {\n    // Luhn algorithm\n    const digits = value.replace(/\\D/g, '');\n    let sum = 0;\n    let is_alternate = false;\n\n    for (let i = digits.length - 1; i &gt;= 0; i--) {\n      let digit = parseInt(digits[i]);\n\n      if (is_alternate) {\n        digit *= 2;\n        if (digit &gt; 9) digit -= 9;\n      }\n\n      sum += digit;\n      is_alternate = !is_alternate;\n    }\n\n    return sum % 10 === 0 || 'Invalid credit card number';\n  })\n  card_number!: string;\n\n  @Validate((value) =&gt; /^(0[1-9]|1[0-2])\\/\\d{2}$/.test(value) || 'Invalid expiry format (MM/YY)')\n  expiry!: string;\n\n  @Validate((value) =&gt; /^\\d{3,4}$/.test(value) || 'Invalid CVV')\n  cvv!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#date-range-validation","title":"Date Range Validation","text":"<pre><code>class Event extends Model {\n  @PrimaryKey()\n  event_id!: string;\n\n  @Validate((value) =&gt; value &gt; Date.now() || 'Start date must be in the future')\n  start_date!: number;\n\n  @Validate((value, context) =&gt; {\n    const start = context?.instance.start_date;\n    return value &gt; start || 'End date must be after start date';\n  })\n  end_date!: number;\n}\n</code></pre>"},{"location":"api/decorators/validate/#file-upload-validation","title":"File Upload Validation","text":"<pre><code>class Document extends Model {\n  @PrimaryKey()\n  document_id!: string;\n\n  @Validate([\n    (value) =&gt; ['pdf', 'doc', 'docx', 'txt'].includes(value) || 'Invalid file type',\n  ])\n  file_type!: string;\n\n  @Validate((value) =&gt; value &lt;= 10 * 1024 * 1024 || 'File size must be under 10MB')\n  file_size!: number;\n\n  @Validate((value) =&gt; value.length &lt;= 255 || 'Filename too long')\n  filename!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#business-logic-validation","title":"Business Logic Validation","text":"<pre><code>class BankAccount extends Model {\n  @PrimaryKey()\n  account_id!: string;\n\n  balance!: number;\n\n  @Validate((value, context) =&gt; {\n    const balance = context?.instance.balance;\n    const new_balance = balance - value;\n\n    if (new_balance &lt; 0) {\n      return 'Insufficient funds';\n    }\n    if (value &gt; 10000) {\n      return 'Withdrawal limit exceeded';\n    }\n    return true;\n  })\n  withdrawal_amount!: number;\n}\n</code></pre>"},{"location":"api/decorators/validate/#conditional-validation","title":"Conditional Validation","text":"<pre><code>class ShippingInfo extends Model {\n  @PrimaryKey()\n  order_id!: string;\n\n  requires_shipping!: boolean;\n\n  @Validate((value, context) =&gt; {\n    const requires = context?.instance.requires_shipping;\n    if (!requires) return true;  // Skip validation if shipping not required\n\n    return value &amp;&amp; value.street &amp;&amp; value.city || 'Shipping address required';\n  }, { allow_undefined: true })\n  shipping_address?: {\n    street: string;\n    city: string;\n    zip: string;\n  };\n}\n</code></pre>"},{"location":"api/decorators/validate/#integration-with-other-decorators","title":"Integration with Other Decorators","text":""},{"location":"api/decorators/validate/#with-default","title":"With @Default","text":"<pre><code>class Settings extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Default(50)\n  @Validate((value) =&gt; value &gt;= 0 &amp;&amp; value &lt;= 100 || 'Volume must be 0-100')\n  volume!: number;\n\n  @Default('en')\n  @Validate((value) =&gt; ['en', 'es', 'fr', 'de'].includes(value))\n  language!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#with-mutate","title":"With @Mutate","text":"<pre><code>class Article extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Mutate((value) =&gt; value.trim().toLowerCase())\n  @Validate((value) =&gt; value.length &gt;= 3 || 'Slug must be at least 3 characters')\n  slug!: string;\n\n  title!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#with-indexsort","title":"With @IndexSort","text":"<pre><code>class Product extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @IndexSort()\n  @Validate((value) =&gt; ['electronics', 'clothing', 'food'].includes(value))\n  category!: string;\n\n  @IndexSort()\n  @Validate((value) =&gt; value &gt; 0)\n  price!: number;\n}\n</code></pre>"},{"location":"api/decorators/validate/#with-timestamps","title":"With Timestamps","text":"<pre><code>class Booking extends Model {\n  @PrimaryKey()\n  booking_id!: string;\n\n  @CreatedAt()\n  @Validate((value) =&gt; value &lt;= Date.now())\n  created_at!: number;\n\n  @Validate((value, context) =&gt; {\n    const created = context?.instance.created_at;\n    return value &gt; created || 'Check-out must be after check-in';\n  })\n  checkout_date!: number;\n}\n</code></pre>"},{"location":"api/decorators/validate/#best-practices","title":"Best Practices","text":""},{"location":"api/decorators/validate/#1-provide-clear-error-messages","title":"1. Provide Clear Error Messages","text":"<pre><code>// Good - Specific error messages\nclass GoodModel extends Model {\n  @Validate((value) =&gt; value.length &gt;= 8 || 'Password must be at least 8 characters')\n  password!: string;\n}\n\n// Avoid - Generic errors\nclass BadModel extends Model {\n  @Validate((value) =&gt; value.length &gt;= 8)  // \u274c No error message\n  password!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#2-validate-early","title":"2. Validate Early","text":"<pre><code>class ValidateEarly extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate((value) =&gt; {\n    // Check cheapest validations first\n    if (typeof value !== 'string') return 'Must be string';\n    if (value.length &lt; 3) return 'Too short';\n    if (value.length &gt; 50) return 'Too long';\n\n    // Expensive regex last\n    if (!/^[a-zA-Z0-9_]+$/.test(value)) return 'Invalid characters';\n\n    return true;\n  })\n  username!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#3-avoid-side-effects","title":"3. Avoid Side Effects","text":"<pre><code>// Good - Pure validation\nclass GoodValidator extends Model {\n  @Validate((value) =&gt; value &gt; 0)\n  count!: number;\n}\n\n// Avoid - Side effects\nclass BadValidator extends Model {\n  @Validate((value) =&gt; {\n    console.log('Validating:', value);  // \u274c Side effect\n    return value &gt; 0;\n  })\n  count!: number;\n}\n</code></pre>"},{"location":"api/decorators/validate/#4-use-type-guards","title":"4. Use Type Guards","text":"<pre><code>class TypeSafe extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate((value) =&gt; {\n    if (typeof value !== 'number') return 'Must be number';\n    if (!Number.isFinite(value)) return 'Must be finite';\n    if (value &lt; 0) return 'Must be positive';\n    return true;\n  })\n  amount!: number;\n}\n</code></pre>"},{"location":"api/decorators/validate/#5-handle-async-validation-carefully","title":"5. Handle Async Validation Carefully","text":"<pre><code>class AsyncValidation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate(async (value) =&gt; {\n    try {\n      const result = await external_api.validate(value);\n      return result.valid || result.error;\n    } catch (error) {\n      return 'Validation service unavailable';\n    }\n  })\n  external_id!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#error-handling","title":"Error Handling","text":""},{"location":"api/decorators/validate/#validation-errors","title":"Validation Errors","text":"<pre><code>try {\n  const user = new User();\n  user.email = 'invalid-email';\n  await user.save();\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.error('Validation failed:', error.field, error.message);\n    // error.field = 'email'\n    // error.message = 'Invalid email'\n  }\n}\n</code></pre>"},{"location":"api/decorators/validate/#multiple-validation-errors","title":"Multiple Validation Errors","text":"<pre><code>class MultiValidation extends Model {\n  @PrimaryKey()\n  id!: string;\n\n  @Validate((value) =&gt; value.length &gt;= 3 || 'Too short')\n  username!: string;\n\n  @Validate((value) =&gt; value.includes('@') || 'Invalid email')\n  email!: string;\n\n  async validateAll(): Promise&lt;ValidationResult&gt; {\n    const errors: Record&lt;string, string&gt; = {};\n\n    try {\n      await this.save();\n    } catch (error) {\n      if (error instanceof ValidationError) {\n        errors[error.field] = error.message;\n      }\n    }\n\n    return {\n      valid: Object.keys(errors).length === 0,\n      errors\n    };\n  }\n}\n</code></pre>"},{"location":"api/decorators/validate/#custom-validators","title":"Custom Validators","text":""},{"location":"api/decorators/validate/#reusable-validator-functions","title":"Reusable Validator Functions","text":"<pre><code>// validators.ts\nexport const IsEmail = (value: string) =&gt;\n  /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value) || 'Invalid email';\n\nexport const IsURL = (value: string) =&gt;\n  /^https?:\\/\\/.+/.test(value) || 'Invalid URL';\n\nexport const MinLength = (min: number) =&gt; (value: string) =&gt;\n  value.length &gt;= min || `Must be at least ${min} characters`;\n\nexport const MaxLength = (max: number) =&gt; (value: string) =&gt;\n  value.length &lt;= max || `Must be at most ${max} characters`;\n\nexport const InRange = (min: number, max: number) =&gt; (value: number) =&gt;\n  (value &gt;= min &amp;&amp; value &lt;= max) || `Must be between ${min} and ${max}`;\n\n// Usage\nclass User extends Model {\n  @Validate(IsEmail)\n  email!: string;\n\n  @Validate(MinLength(3))\n  username!: string;\n\n  @Validate(InRange(18, 120))\n  age!: number;\n}\n</code></pre>"},{"location":"api/decorators/validate/#validator-composition","title":"Validator Composition","text":"<pre><code>const Compose = (...validators: ValidatorFunction[]) =&gt; (value: any, context?: ValidationContext) =&gt; {\n  for (const validator of validators) {\n    const result = validator(value, context);\n    if (result !== true) return result;\n  }\n  return true;\n};\n\nclass ComposedValidation extends Model {\n  @Validate(Compose(\n    MinLength(8),\n    (value) =&gt; /[A-Z]/.test(value) || 'Needs uppercase',\n    (value) =&gt; /[0-9]/.test(value) || 'Needs number'\n  ))\n  password!: string;\n}\n</code></pre>"},{"location":"api/decorators/validate/#testing-validators","title":"Testing Validators","text":"<pre><code>import { describe, it, expect } from 'vitest';\n\ndescribe('Validation', () =&gt; {\n  it('should validate email format', async () =&gt; {\n    const user = new User();\n    user.email = 'invalid';\n\n    await expect(user.save()).rejects.toThrow('Invalid email');\n  });\n\n  it('should accept valid email', async () =&gt; {\n    const user = new User();\n    user.id = 'user123';\n    user.email = 'user@example.com';\n\n    await expect(user.save()).resolves.not.toThrow();\n  });\n});\n</code></pre>"},{"location":"api/decorators/validate/#see-also","title":"See Also","text":"<ul> <li>@Mutate - Transform values before validation</li> <li>@Default - Set default values</li> <li>Error Handling - Handle validation errors</li> </ul>"},{"location":"examples/advanced-queries/","title":"Advanced Queries Example","text":"<p>This comprehensive example demonstrates advanced query patterns, pagination, filtering, sorting, and complex data operations in Dynamite ORM. Learn how to build efficient, scalable queries for real-world applications.</p>"},{"location":"examples/advanced-queries/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Query Operators</li> <li>Comparison Queries</li> <li>Array Queries</li> <li>String Queries</li> <li>Pagination</li> <li>Sorting and Ordering</li> <li>Attribute Selection</li> <li>Complex Filtering</li> <li>Complete Working Example</li> <li>Expected Output</li> <li>Performance Optimization</li> <li>Best Practices</li> </ul>"},{"location":"examples/advanced-queries/#query-operators","title":"Query Operators","text":"<p>Dynamite supports a rich set of query operators for flexible data filtering:</p> Operator Description Example <code>=</code> Equal to (default) <code>where(\"age\", 25)</code> <code>!=</code> Not equal to <code>where(\"status\", \"!=\", \"deleted\")</code> <code>&lt;</code> Less than <code>where(\"age\", \"&lt;\", 18)</code> <code>&lt;=</code> Less than or equal <code>where(\"age\", \"&lt;=\", 65)</code> <code>&gt;</code> Greater than <code>where(\"score\", \"&gt;\", 100)</code> <code>&gt;=</code> Greater than or equal <code>where(\"age\", \"&gt;=\", 18)</code> <code>in</code> In array <code>where(\"role\", \"in\", [\"admin\", \"user\"])</code> <code>not-in</code> Not in array <code>where(\"status\", \"not-in\", [\"banned\"])</code> <code>contains</code> String contains <code>where(\"email\", \"contains\", \"gmail\")</code> <code>begins-with</code> String starts with <code>where(\"name\", \"begins-with\", \"John\")</code>"},{"location":"examples/advanced-queries/#comparison-queries","title":"Comparison Queries","text":"<p>Use comparison operators for numeric and date comparisons:</p>"},{"location":"examples/advanced-queries/#equal-to-default","title":"Equal To (Default)","text":"<pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreationOptional\n} from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare age: number;\n  declare role: string;\n}\n\n// Explicit equal\nconst users1 = await User.where(\"age\", \"=\", 25);\n\n// Implicit equal (default operator)\nconst users2 = await User.where(\"age\", 25);\n\n// Object syntax (implicit equal)\nconst users3 = await User.where({ age: 25 });\n\nconsole.log(`Found ${users1.length} users aged 25`);\n</code></pre>"},{"location":"examples/advanced-queries/#not-equal-to","title":"Not Equal To","text":"<pre><code>// Find all non-admin users\nconst non_admins = await User.where(\"role\", \"!=\", \"admin\");\nconsole.log(`Found ${non_admins.length} non-admin users`);\n\n// Find active users (not deleted)\nconst active_users = await User.where(\"status\", \"!=\", \"deleted\");\n</code></pre>"},{"location":"examples/advanced-queries/#greater-than-less-than","title":"Greater Than / Less Than","text":"<pre><code>// Find adults (age &gt;= 18)\nconst adults = await User.where(\"age\", \"&gt;=\", 18);\nconsole.log(`Adults: ${adults.length}`);\n\n// Find minors (age &lt; 18)\nconst minors = await User.where(\"age\", \"&lt;\", 18);\nconsole.log(`Minors: ${minors.length}`);\n\n// Find users in age range (18-65)\nconst working_age = await User.where(\"age\", \"&gt;=\", 18);\nconst filtered = working_age.filter(u =&gt; u.age &lt;= 65);\nconsole.log(`Working age: ${filtered.length}`);\n</code></pre>"},{"location":"examples/advanced-queries/#date-comparisons","title":"Date Comparisons","text":"<pre><code>class Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare user_id: string;\n  declare total: number;\n  declare created_at: string;\n}\n\n// Orders after specific date\nconst recent_orders = await Order.where(\n  \"created_at\",\n  \"&gt;=\",\n  \"2024-01-01T00:00:00.000Z\"\n);\n\n// Orders before specific date\nconst old_orders = await Order.where(\n  \"created_at\",\n  \"&lt;\",\n  \"2023-01-01T00:00:00.000Z\"\n);\n\n// Orders in date range\nconst orders_2024 = await Order.where(\n  \"created_at\",\n  \"&gt;=\",\n  \"2024-01-01T00:00:00.000Z\"\n);\nconst q1_orders = orders_2024.filter(\n  o =&gt; o.created_at &lt; \"2024-04-01T00:00:00.000Z\"\n);\n</code></pre>"},{"location":"examples/advanced-queries/#array-queries","title":"Array Queries","text":"<p>Query records where field values match elements in an array:</p>"},{"location":"examples/advanced-queries/#in-operator","title":"In Operator","text":"<pre><code>// Find users with specific roles\nconst privileged_users = await User.where(\n  \"role\",\n  \"in\",\n  [\"admin\", \"moderator\", \"premium\"]\n);\n\nconsole.log(`Privileged users: ${privileged_users.length}`);\n\n// Find users by multiple IDs\nconst specific_users = await User.where(\n  \"id\",\n  \"in\",\n  [\"user-1\", \"user-2\", \"user-3\"]\n);\n\n// Shorthand: array value implies \"in\" operator\nconst users = await User.where(\"id\", [\"user-1\", \"user-2\", \"user-3\"]);\n</code></pre>"},{"location":"examples/advanced-queries/#not-in-operator","title":"Not In Operator","text":"<pre><code>// Exclude banned and deleted users\nconst active_users = await User.where(\n  \"status\",\n  \"not-in\",\n  [\"banned\", \"deleted\", \"suspended\"]\n);\n\nconsole.log(`Active users: ${active_users.length}`);\n\n// Exclude test users\nconst real_users = await User.where(\n  \"email\",\n  \"not-in\",\n  [\"test@example.com\", \"demo@example.com\"]\n);\n</code></pre>"},{"location":"examples/advanced-queries/#string-queries","title":"String Queries","text":"<p>Perform pattern matching on string fields:</p>"},{"location":"examples/advanced-queries/#contains-operator","title":"Contains Operator","text":"<pre><code>// Find Gmail users\nconst gmail_users = await User.where(\"email\", \"contains\", \"gmail\");\nconsole.log(`Gmail users: ${gmail_users.length}`);\n\n// Find users with \"john\" in name\nconst johns = await User.where(\"name\", \"contains\", \"john\");\n\n// Find users with specific domain\nconst company_users = await User.where(\"email\", \"contains\", \"@company.com\");\n</code></pre>"},{"location":"examples/advanced-queries/#begins-with-operator","title":"Begins With Operator","text":"<pre><code>// Find users with name starting with \"J\"\nconst j_users = await User.where(\"name\", \"begins-with\", \"J\");\nconsole.log(`Names starting with J: ${j_users.length}`);\n\n// Find users with specific prefix\nconst admin_users = await User.where(\"username\", \"begins-with\", \"admin_\");\n\n// Find orders with specific ID prefix\nconst orders_2024 = await Order.where(\"id\", \"begins-with\", \"2024-\");\n</code></pre>"},{"location":"examples/advanced-queries/#case-insensitive-search","title":"Case-Insensitive Search","text":"<pre><code>// Transform to lowercase before searching\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Mutate((value) =&gt; (value as string).toLowerCase())\n  declare email: string;\n}\n\n// Now all emails are stored lowercase\nconst users = await User.where(\"email\", \"contains\", \"gmail\");\n\n// For case-insensitive search on non-mutated fields\nconst all_users = await User.where({});\nconst filtered = all_users.filter(u =&gt;\n  u.name.toLowerCase().includes(\"john\")\n);\n</code></pre>"},{"location":"examples/advanced-queries/#pagination","title":"Pagination","text":"<p>Implement efficient pagination for large datasets:</p>"},{"location":"examples/advanced-queries/#basic-pagination","title":"Basic Pagination","text":"<pre><code>// Page 1: First 10 users\nconst page_1 = await User.where({}, {\n  limit: 10,\n  skip: 0\n});\n\n// Page 2: Next 10 users\nconst page_2 = await User.where({}, {\n  limit: 10,\n  skip: 10\n});\n\n// Page 3: Next 10 users\nconst page_3 = await User.where({}, {\n  limit: 10,\n  skip: 20\n});\n\nconsole.log(`Page 1: ${page_1.length} users`);\nconsole.log(`Page 2: ${page_2.length} users`);\nconsole.log(`Page 3: ${page_3.length} users`);\n</code></pre>"},{"location":"examples/advanced-queries/#pagination-helper-function","title":"Pagination Helper Function","text":"<pre><code>async function paginate_users(\n  page: number,\n  page_size: number,\n  filters: Partial&lt;InferAttributes&lt;User&gt;&gt; = {}\n) {\n  const skip = page * page_size;\n  const users = await User.where(filters, {\n    skip,\n    limit: page_size\n  });\n\n  return {\n    data: users,\n    page,\n    page_size,\n    has_more: users.length === page_size\n  };\n}\n\n// Usage\nconst result = await paginate_users(0, 10, { role: \"customer\" });\nconsole.log(`Page ${result.page}: ${result.data.length} users`);\nconsole.log(`Has more: ${result.has_more}`);\n</code></pre>"},{"location":"examples/advanced-queries/#cursor-based-pagination","title":"Cursor-Based Pagination","text":"<pre><code>async function paginate_by_cursor(\n  last_id: string | null,\n  page_size: number\n) {\n  let users: User[];\n\n  if (last_id) {\n    // Get users after cursor\n    const all_users = await User.where({});\n    const cursor_index = all_users.findIndex(u =&gt; u.id === last_id);\n    users = all_users.slice(cursor_index + 1, cursor_index + 1 + page_size);\n  } else {\n    // First page\n    users = await User.where({}, { limit: page_size });\n  }\n\n  return {\n    data: users,\n    next_cursor: users.length === page_size ? users[users.length - 1].id : null\n  };\n}\n\n// Usage\nconst page_1 = await paginate_by_cursor(null, 10);\nconsole.log(`Page 1: ${page_1.data.length} users`);\n\nconst page_2 = await paginate_by_cursor(page_1.next_cursor, 10);\nconsole.log(`Page 2: ${page_2.data.length} users`);\n</code></pre>"},{"location":"examples/advanced-queries/#sorting-and-ordering","title":"Sorting and Ordering","text":"<p>Control the order of query results:</p>"},{"location":"examples/advanced-queries/#ascending-order","title":"Ascending Order","text":"<pre><code>// Sort by age ascending (youngest first)\nconst users_asc = await User.where({}, {\n  order: \"ASC\"\n});\n\nusers_asc.forEach(user =&gt; {\n  console.log(`${user.name}: ${user.age} years old`);\n});\n</code></pre>"},{"location":"examples/advanced-queries/#descending-order","title":"Descending Order","text":"<pre><code>// Sort by age descending (oldest first)\nconst users_desc = await User.where({}, {\n  order: \"DESC\"\n});\n\nusers_desc.forEach(user =&gt; {\n  console.log(`${user.name}: ${user.age} years old`);\n});\n</code></pre>"},{"location":"examples/advanced-queries/#sort-by-specific-field","title":"Sort by Specific Field","text":"<pre><code>// Get all users and sort by name\nconst all_users = await User.where({});\nconst sorted_by_name = all_users.sort((a, b) =&gt;\n  a.name.localeCompare(b.name)\n);\n\n// Get all users and sort by multiple criteria\nconst sorted = all_users.sort((a, b) =&gt; {\n  // First by role\n  if (a.role !== b.role) {\n    return a.role.localeCompare(b.role);\n  }\n  // Then by name\n  return a.name.localeCompare(b.name);\n});\n</code></pre>"},{"location":"examples/advanced-queries/#recent-records","title":"Recent Records","text":"<pre><code>class Post extends Table&lt;Post&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare title: string;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n}\n\n// Get 10 most recent posts\nconst recent_posts = await Post.where({}, {\n  order: \"DESC\",\n  limit: 10\n});\n\nrecent_posts.forEach(post =&gt; {\n  const date = new Date(post.created_at);\n  console.log(`${post.title} - ${date.toLocaleDateString()}`);\n});\n</code></pre>"},{"location":"examples/advanced-queries/#attribute-selection","title":"Attribute Selection","text":"<p>Load only specific fields to optimize performance:</p>"},{"location":"examples/advanced-queries/#select-specific-attributes","title":"Select Specific Attributes","text":"<pre><code>// Load only id and name\nconst users = await User.where({}, {\n  attributes: [\"id\", \"name\"]\n});\n\nusers.forEach(user =&gt; {\n  console.log(`${user.id}: ${user.name}`);\n  // email, age, role are not loaded\n});\n</code></pre>"},{"location":"examples/advanced-queries/#select-for-display","title":"Select for Display","text":"<pre><code>// Load minimal data for user list\nconst user_list = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\"]\n});\n\n// Display user list\nuser_list.forEach(user =&gt; {\n  console.log(`${user.name} (${user.email})`);\n});\n</code></pre>"},{"location":"examples/advanced-queries/#select-for-performance","title":"Select for Performance","text":"<pre><code>// Load only necessary fields for computation\nconst users = await User.where({ role: \"premium\" }, {\n  attributes: [\"id\", \"total_spent\"]\n});\n\nconst total_revenue = users.reduce((sum, user) =&gt; sum + user.total_spent, 0);\nconsole.log(`Total premium revenue: $${total_revenue}`);\n</code></pre>"},{"location":"examples/advanced-queries/#combined-with-pagination","title":"Combined with Pagination","text":"<pre><code>// Paginated user list with minimal data\nconst users = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\", \"role\"],\n  limit: 20,\n  skip: 0,\n  order: \"ASC\"\n});\n\nconsole.log(`Loaded ${users.length} users with minimal data`);\n</code></pre>"},{"location":"examples/advanced-queries/#complex-filtering","title":"Complex Filtering","text":"<p>Combine multiple query techniques for advanced filtering:</p>"},{"location":"examples/advanced-queries/#multiple-conditions","title":"Multiple Conditions","text":"<pre><code>// Find premium adults\nconst premium_adults = await User.where({\n  role: \"premium\",\n  age: 25\n});\n\n// Find active users with specific role\nconst active_admins = await User.where({\n  role: \"admin\",\n  status: \"active\"\n});\n</code></pre>"},{"location":"examples/advanced-queries/#filter-and-paginate","title":"Filter and Paginate","text":"<pre><code>// Get page 2 of active premium users\nconst users = await User.where(\n  { role: \"premium\", active: true },\n  {\n    skip: 10,\n    limit: 10,\n    order: \"DESC\"\n  }\n);\n</code></pre>"},{"location":"examples/advanced-queries/#filter-with-attribute-selection","title":"Filter with Attribute Selection","text":"<pre><code>// Get names of all admin users\nconst admins = await User.where(\n  { role: \"admin\" },\n  {\n    attributes: [\"id\", \"name\", \"email\"]\n  }\n);\n\nconsole.log(\"Admin users:\");\nadmins.forEach(admin =&gt; {\n  console.log(`  - ${admin.name} (${admin.email})`);\n});\n</code></pre>"},{"location":"examples/advanced-queries/#complex-business-logic","title":"Complex Business Logic","text":"<pre><code>class Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare name: string;\n  declare price: number;\n  declare stock: number;\n  declare category: string;\n}\n\n// Find affordable electronics in stock\nconst affordable_electronics = await Product.where({\n  category: \"electronics\"\n});\n\nconst in_stock = affordable_electronics.filter(p =&gt;\n  p.stock &gt; 0 &amp;&amp; p.price &lt; 500\n);\n\nconsole.log(`Found ${in_stock.length} affordable electronics in stock`);\n</code></pre>"},{"location":"examples/advanced-queries/#date-range-queries","title":"Date Range Queries","text":"<pre><code>class Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare user_id: string;\n  declare total: number;\n  declare status: string;\n  declare created_at: string;\n}\n\n// Get orders from last 30 days\nconst thirty_days_ago = new Date();\nthirty_days_ago.setDate(thirty_days_ago.getDate() - 30);\n\nconst all_orders = await Order.where({});\nconst recent_orders = all_orders.filter(order =&gt;\n  new Date(order.created_at) &gt;= thirty_days_ago\n);\n\nconsole.log(`Orders in last 30 days: ${recent_orders.length}`);\n\n// Calculate total revenue for period\nconst total = recent_orders.reduce((sum, order) =&gt; sum + order.total, 0);\nconsole.log(`Total revenue: $${total.toFixed(2)}`);\n</code></pre>"},{"location":"examples/advanced-queries/#complete-working-example","title":"Complete Working Example","text":"<p>Here's a complete example demonstrating all advanced query patterns:</p> <pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  Validate,\n  Mutate,\n  CreationOptional,\n  Dynamite\n} from \"@arcaelas/dynamite\";\n\n// Configure DynamoDB\nDynamite.config({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  }\n});\n\n// User model\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n\n  @Mutate((value) =&gt; (value as string).toLowerCase())\n  declare email: string;\n\n  declare age: number;\n\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  @Default(() =&gt; 0)\n  declare total_spent: CreationOptional&lt;number&gt;;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n}\n\n// Product model\nclass Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare category: string;\n  declare price: number;\n  declare stock: number;\n\n  @Default(() =&gt; true)\n  declare available: CreationOptional&lt;boolean&gt;;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n}\n\n// Main application\nasync function main() {\n  console.log(\"=== Advanced Queries Example ===\\n\");\n\n  // 1. Create sample users\n  console.log(\"1. Creating sample users...\");\n  await Promise.all([\n    User.create({ name: \"John Doe\", email: \"john@gmail.com\", age: 25, role: \"customer\", total_spent: 150 }),\n    User.create({ name: \"Jane Smith\", email: \"jane@yahoo.com\", age: 32, role: \"premium\", total_spent: 500 }),\n    User.create({ name: \"Bob Johnson\", email: \"bob@gmail.com\", age: 45, role: \"admin\", total_spent: 0 }),\n    User.create({ name: \"Alice Williams\", email: \"alice@gmail.com\", age: 28, role: \"premium\", total_spent: 750 }),\n    User.create({ name: \"Charlie Brown\", email: \"charlie@hotmail.com\", age: 19, role: \"customer\", total_spent: 80 }),\n    User.create({ name: \"David Lee\", email: \"david@gmail.com\", age: 55, role: \"customer\", total_spent: 200 }),\n    User.create({ name: \"Emma Wilson\", email: \"emma@yahoo.com\", age: 23, role: \"premium\", total_spent: 1200 }),\n    User.create({ name: \"Frank Miller\", email: \"frank@gmail.com\", age: 38, role: \"moderator\", total_spent: 350 })\n  ]);\n  console.log(\"Created 8 users\\n\");\n\n  // 2. Create sample products\n  console.log(\"2. Creating sample products...\");\n  await Promise.all([\n    Product.create({ name: \"Laptop\", category: \"electronics\", price: 999.99, stock: 15 }),\n    Product.create({ name: \"Mouse\", category: \"electronics\", price: 29.99, stock: 50 }),\n    Product.create({ name: \"Keyboard\", category: \"electronics\", price: 79.99, stock: 30 }),\n    Product.create({ name: \"Monitor\", category: \"electronics\", price: 299.99, stock: 0 }),\n    Product.create({ name: \"Desk\", category: \"furniture\", price: 199.99, stock: 10 }),\n    Product.create({ name: \"Chair\", category: \"furniture\", price: 149.99, stock: 20 })\n  ]);\n  console.log(\"Created 6 products\\n\");\n\n  // 3. Comparison queries\n  console.log(\"3. Comparison queries...\");\n  const adults = await User.where(\"age\", \"&gt;=\", 18);\n  console.log(`Adults (age &gt;= 18): ${adults.length}`);\n\n  const seniors = await User.where(\"age\", \"&gt;=\", 55);\n  console.log(`Seniors (age &gt;= 55): ${seniors.length}`);\n\n  const young_adults = await User.where(\"age\", \"&lt;\", 30);\n  console.log(`Young adults (age &lt; 30): ${young_adults.length}\\n`);\n\n  // 4. Array queries\n  console.log(\"4. Array queries...\");\n  const privileged = await User.where(\"role\", \"in\", [\"admin\", \"moderator\", \"premium\"]);\n  console.log(`Privileged users: ${privileged.length}`);\n\n  const gmail_users = await User.where(\"email\", \"contains\", \"gmail\");\n  console.log(`Gmail users: ${gmail_users.length}`);\n\n  const j_names = await User.where(\"name\", \"begins-with\", \"J\");\n  console.log(`Names starting with J: ${j_names.length}\\n`);\n\n  // 5. Pagination\n  console.log(\"5. Pagination...\");\n  const page_1 = await User.where({}, { limit: 3, skip: 0 });\n  console.log(`Page 1: ${page_1.length} users`);\n  page_1.forEach(u =&gt; console.log(`  - ${u.name}`));\n\n  const page_2 = await User.where({}, { limit: 3, skip: 3 });\n  console.log(`Page 2: ${page_2.length} users`);\n  page_2.forEach(u =&gt; console.log(`  - ${u.name}`));\n  console.log();\n\n  // 6. Sorting\n  console.log(\"6. Sorting...\");\n  const sorted_users = await User.where({}, { order: \"DESC\" });\n  console.log(\"Users (descending order):\");\n  sorted_users.slice(0, 5).forEach(u =&gt; {\n    console.log(`  - ${u.name} (age: ${u.age})`);\n  });\n  console.log();\n\n  // 7. Attribute selection\n  console.log(\"7. Attribute selection...\");\n  const user_list = await User.where({}, {\n    attributes: [\"id\", \"name\", \"email\"],\n    limit: 3\n  });\n  console.log(\"User summary (minimal data):\");\n  user_list.forEach(u =&gt; {\n    console.log(`  - ${u.name}: ${u.email}`);\n  });\n  console.log();\n\n  // 8. Complex filtering\n  console.log(\"8. Complex filtering...\");\n  const premium_spenders = await User.where({ role: \"premium\" });\n  const high_value = premium_spenders.filter(u =&gt; u.total_spent &gt; 500);\n  console.log(`Premium users with &gt;$500 spent: ${high_value.length}`);\n  high_value.forEach(u =&gt; {\n    console.log(`  - ${u.name}: $${u.total_spent}`);\n  });\n  console.log();\n\n  // 9. Product queries\n  console.log(\"9. Product queries...\");\n  const electronics = await Product.where({ category: \"electronics\" });\n  console.log(`Electronics: ${electronics.length}`);\n\n  const in_stock = electronics.filter(p =&gt; p.stock &gt; 0);\n  console.log(`Electronics in stock: ${in_stock.length}`);\n\n  const affordable = in_stock.filter(p =&gt; p.price &lt; 100);\n  console.log(`Affordable electronics in stock: ${affordable.length}`);\n  affordable.forEach(p =&gt; {\n    console.log(`  - ${p.name}: $${p.price} (${p.stock} in stock)`);\n  });\n  console.log();\n\n  // 10. Aggregations\n  console.log(\"10. Aggregations...\");\n  const all_users = await User.where({});\n\n  // Total spending by role\n  const by_role = all_users.reduce((acc, user) =&gt; {\n    if (!acc[user.role]) acc[user.role] = 0;\n    acc[user.role] += user.total_spent;\n    return acc;\n  }, {} as Record&lt;string, number&gt;);\n\n  console.log(\"Total spending by role:\");\n  Object.entries(by_role).forEach(([role, total]) =&gt; {\n    console.log(`  ${role}: $${total.toFixed(2)}`);\n  });\n\n  // Average age by role\n  const age_by_role = all_users.reduce((acc, user) =&gt; {\n    if (!acc[user.role]) acc[user.role] = { sum: 0, count: 0 };\n    acc[user.role].sum += user.age;\n    acc[user.role].count += 1;\n    return acc;\n  }, {} as Record&lt;string, { sum: number; count: number }&gt;);\n\n  console.log(\"\\nAverage age by role:\");\n  Object.entries(age_by_role).forEach(([role, data]) =&gt; {\n    const avg = data.sum / data.count;\n    console.log(`  ${role}: ${avg.toFixed(1)} years`);\n  });\n  console.log();\n\n  // 11. Search functionality\n  console.log(\"11. Search functionality...\");\n  const search_term = \"john\";\n  const search_results = all_users.filter(user =&gt;\n    user.name.toLowerCase().includes(search_term) ||\n    user.email.toLowerCase().includes(search_term)\n  );\n  console.log(`Search results for \"${search_term}\": ${search_results.length}`);\n  search_results.forEach(u =&gt; {\n    console.log(`  - ${u.name} (${u.email})`);\n  });\n  console.log();\n\n  // 12. Date-based queries\n  console.log(\"12. Date-based queries...\");\n  const one_hour_ago = new Date();\n  one_hour_ago.setHours(one_hour_ago.getHours() - 1);\n\n  const recent_users = all_users.filter(user =&gt;\n    new Date(user.created_at) &gt;= one_hour_ago\n  );\n  console.log(`Users created in last hour: ${recent_users.length}\\n`);\n\n  console.log(\"=== All advanced queries completed ===\");\n}\n\n// Run the application\nmain().catch(console.error);\n</code></pre>"},{"location":"examples/advanced-queries/#expected-output","title":"Expected Output","text":"<pre><code>=== Advanced Queries Example ===\n\n1. Creating sample users...\nCreated 8 users\n\n2. Creating sample products...\nCreated 6 products\n\n3. Comparison queries...\nAdults (age &gt;= 18): 8\nSeniors (age &gt;= 55): 1\nYoung adults (age &lt; 30): 4\n\n4. Array queries...\nPrivileged users: 5\nGmail users: 5\nNames starting with J: 2\n\n5. Pagination...\nPage 1: 3 users\n  - John Doe\n  - Jane Smith\n  - Bob Johnson\nPage 2: 3 users\n  - Alice Williams\n  - Charlie Brown\n  - David Lee\n\n6. Sorting...\nUsers (descending order):\n  - David Lee (age: 55)\n  - Bob Johnson (age: 45)\n  - Frank Miller (age: 38)\n  - Jane Smith (age: 32)\n  - Alice Williams (age: 28)\n\n7. Attribute selection...\nUser summary (minimal data):\n  - John Doe: john@gmail.com\n  - Jane Smith: jane@yahoo.com\n  - Bob Johnson: bob@gmail.com\n\n8. Complex filtering...\nPremium users with &gt;$500 spent: 2\n  - Alice Williams: $750\n  - Emma Wilson: $1200\n\n9. Product queries...\nElectronics: 4\nElectronics in stock: 3\nAffordable electronics in stock: 2\n  - Mouse: $29.99 (50 in stock)\n  - Keyboard: $79.99 (30 in stock)\n\n10. Aggregations...\nTotal spending by role:\n  customer: $430.00\n  premium: $2450.00\n  admin: $0.00\n  moderator: $350.00\n\nAverage age by role:\n  customer: 33.0 years\n  premium: 27.7 years\n  admin: 45.0 years\n  moderator: 38.0 years\n\n11. Search functionality...\nSearch results for \"john\": 2\n  - John Doe (john@gmail.com)\n  - Bob Johnson (bob@gmail.com)\n\n12. Date-based queries...\nUsers created in last hour: 8\n\n=== All advanced queries completed ===\n</code></pre>"},{"location":"examples/advanced-queries/#performance-optimization","title":"Performance Optimization","text":""},{"location":"examples/advanced-queries/#1-use-attribute-selection","title":"1. Use Attribute Selection","text":"<pre><code>// Good - load only needed fields\nconst users = await User.where({}, {\n  attributes: [\"id\", \"name\"]\n});\n\n// Bad - loading all fields when only need a few\nconst users = await User.where({});\n</code></pre>"},{"location":"examples/advanced-queries/#2-implement-pagination","title":"2. Implement Pagination","text":"<pre><code>// Good - paginated queries\nconst users = await User.where({}, {\n  limit: 20,\n  skip: 0\n});\n\n// Bad - loading all records at once\nconst users = await User.where({});\n</code></pre>"},{"location":"examples/advanced-queries/#3-filter-early","title":"3. Filter Early","text":"<pre><code>// Good - filter in DynamoDB\nconst admins = await User.where({ role: \"admin\" });\n\n// Bad - filter in application\nconst all_users = await User.where({});\nconst admins = all_users.filter(u =&gt; u.role === \"admin\");\n</code></pre>"},{"location":"examples/advanced-queries/#4-use-indexes","title":"4. Use Indexes","text":"<pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  // Index frequently queried fields\n  @Index()\n  declare email: string;\n\n  @IndexSort()\n  declare created_at: string;\n}\n</code></pre>"},{"location":"examples/advanced-queries/#5-cache-frequently-accessed-data","title":"5. Cache Frequently Accessed Data","text":"<pre><code>// Simple in-memory cache\nconst cache = new Map&lt;string, any&gt;();\n\nasync function get_user_by_id(id: string) {\n  if (cache.has(id)) {\n    return cache.get(id);\n  }\n\n  const user = await User.first({ id });\n  if (user) {\n    cache.set(id, user);\n  }\n  return user;\n}\n</code></pre>"},{"location":"examples/advanced-queries/#best-practices","title":"Best Practices","text":""},{"location":"examples/advanced-queries/#1-use-specific-operators","title":"1. Use Specific Operators","text":"<pre><code>// Good - specific operator\nconst users = await User.where(\"age\", \"&gt;=\", 18);\n\n// Bad - loading all and filtering\nconst all_users = await User.where({});\nconst adults = all_users.filter(u =&gt; u.age &gt;= 18);\n</code></pre>"},{"location":"examples/advanced-queries/#2-combine-filters","title":"2. Combine Filters","text":"<pre><code>// Good - multiple conditions in one query\nconst users = await User.where({\n  role: \"premium\",\n  active: true\n});\n\n// Bad - multiple separate queries\nconst premium = await User.where({ role: \"premium\" });\nconst active_premium = premium.filter(u =&gt; u.active);\n</code></pre>"},{"location":"examples/advanced-queries/#3-paginate-large-results","title":"3. Paginate Large Results","text":"<pre><code>// Good - paginated results\nasync function* iterate_users(page_size: number) {\n  let page = 0;\n  while (true) {\n    const users = await User.where({}, {\n      skip: page * page_size,\n      limit: page_size\n    });\n\n    if (users.length === 0) break;\n\n    yield users;\n    page++;\n  }\n}\n\nfor await (const users of iterate_users(100)) {\n  // Process batch\n}\n\n// Bad - loading everything\nconst all_users = await User.where({});\n</code></pre>"},{"location":"examples/advanced-queries/#4-select-only-needed-attributes","title":"4. Select Only Needed Attributes","text":"<pre><code>// Good - minimal data for display\nconst users = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\"]\n});\n\n// Bad - loading all fields\nconst users = await User.where({});\n</code></pre>"},{"location":"examples/advanced-queries/#5-use-clear-query-names","title":"5. Use Clear Query Names","text":"<pre><code>// Good - descriptive query\nasync function get_active_premium_users() {\n  return await User.where({\n    role: \"premium\",\n    active: true\n  });\n}\n\n// Bad - unclear query\nasync function get_users_1() {\n  return await User.where({ role: \"premium\", active: true });\n}\n</code></pre>"},{"location":"examples/advanced-queries/#next-steps","title":"Next Steps","text":""},{"location":"examples/advanced-queries/#related-documentation","title":"Related Documentation","text":"<ul> <li>Basic Model Example - Simple CRUD operations</li> <li>Validation Example - Data validation patterns</li> <li>Relationships Example - Relationships and nested includes</li> </ul>"},{"location":"examples/advanced-queries/#api-references","title":"API References","text":"<ul> <li>Table API - Complete Table class documentation</li> <li>Query Operators - All available operators</li> <li>Best Practices - Development best practices</li> </ul>"},{"location":"examples/advanced-queries/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Query Optimization - Optimize query performance</li> <li>Caching Strategies - Implement effective caching</li> <li>Batch Operations - Process large datasets efficiently</li> <li>Real-time Queries - Build reactive queries</li> </ul> <p>Happy querying with Dynamite!</p>"},{"location":"examples/basic-model/","title":"Basic Model Example","text":"<p>This example demonstrates a simple CRUD (Create, Read, Update, Delete) application using Dynamite ORM. We'll build a complete User management system from scratch, covering all essential operations.</p>"},{"location":"examples/basic-model/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Model Definition</li> <li>Setup and Configuration</li> <li>Creating Records</li> <li>Reading Records</li> <li>Updating Records</li> <li>Deleting Records</li> <li>Complete Working Example</li> <li>Expected Output</li> <li>Key Concepts</li> <li>Next Steps</li> </ul>"},{"location":"examples/basic-model/#model-definition","title":"Model Definition","text":"<p>Let's start by defining a User model with essential fields and decorators:</p> <pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  CreationOptional,\n  Dynamite\n} from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  // Auto-generated primary key\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Required field during creation\n  declare name: string;\n\n  // Required email field\n  declare email: string;\n\n  // Optional field with default value\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  // Optional active status with default\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  // Auto-managed timestamps\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n}\n</code></pre> <p>Decorator Breakdown: - <code>@PrimaryKey()</code> - Marks <code>id</code> as the partition key in DynamoDB - <code>@Default()</code> - Provides automatic default values when field is omitted - <code>@CreatedAt()</code> - Automatically sets ISO timestamp on record creation - <code>@UpdatedAt()</code> - Automatically updates ISO timestamp on every save - <code>CreationOptional&lt;T&gt;</code> - Makes field optional during creation but required in instances</p>"},{"location":"examples/basic-model/#setup-and-configuration","title":"Setup and Configuration","text":"<p>Before using your models, configure the DynamoDB connection:</p> <pre><code>// For local development with DynamoDB Local\nDynamite.config({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  }\n});\n\n// For AWS production\nDynamite.config({\n  region: \"us-east-1\",\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!\n  }\n});\n</code></pre> <p>Configuration Options: - <code>region</code> - AWS region (e.g., \"us-east-1\", \"eu-west-1\") - <code>endpoint</code> - DynamoDB endpoint (use localhost:8000 for local development) - <code>credentials</code> - AWS credentials object with accessKeyId and secretAccessKey</p>"},{"location":"examples/basic-model/#creating-records","title":"Creating Records","text":""},{"location":"examples/basic-model/#basic-creation","title":"Basic Creation","text":"<p>The simplest way to create a record is using the static <code>create()</code> method:</p> <pre><code>// Create with only required fields\nconst user1 = await User.create({\n  name: \"John Doe\",\n  email: \"john@example.com\"\n  // id, role, active, timestamps are auto-generated\n});\n\nconsole.log(user1.id);         // \"550e8400-e29b-41d4-a716-446655440000\"\nconsole.log(user1.name);       // \"John Doe\"\nconsole.log(user1.email);      // \"john@example.com\"\nconsole.log(user1.role);       // \"customer\" (default)\nconsole.log(user1.active);     // true (default)\nconsole.log(user1.created_at); // \"2024-01-15T10:30:00.000Z\"\nconsole.log(user1.updated_at); // \"2024-01-15T10:30:00.000Z\"\n</code></pre>"},{"location":"examples/basic-model/#creation-with-all-fields","title":"Creation with All Fields","text":"<p>You can override default values during creation:</p> <pre><code>const user2 = await User.create({\n  id: \"custom-user-id\",\n  name: \"Jane Smith\",\n  email: \"jane@example.com\",\n  role: \"admin\",\n  active: true\n});\n\nconsole.log(user2.id);   // \"custom-user-id\" (custom)\nconsole.log(user2.role); // \"admin\" (overridden default)\n</code></pre>"},{"location":"examples/basic-model/#bulk-creation","title":"Bulk Creation","text":"<p>Create multiple records efficiently using <code>Promise.all()</code>:</p> <pre><code>const users = await Promise.all([\n  User.create({\n    name: \"Alice Johnson\",\n    email: \"alice@example.com\"\n  }),\n  User.create({\n    name: \"Bob Williams\",\n    email: \"bob@example.com\",\n    role: \"moderator\"\n  }),\n  User.create({\n    name: \"Charlie Brown\",\n    email: \"charlie@example.com\"\n  })\n]);\n\nconsole.log(`Created ${users.length} users`);\n// Output: Created 3 users\n</code></pre>"},{"location":"examples/basic-model/#reading-records","title":"Reading Records","text":""},{"location":"examples/basic-model/#get-all-records","title":"Get All Records","text":"<p>Retrieve all records from the table:</p> <pre><code>const all_users = await User.where({});\nconsole.log(`Total users: ${all_users.length}`);\n\n// Iterate through results\nall_users.forEach(user =&gt; {\n  console.log(`${user.name} (${user.email})`);\n});\n</code></pre>"},{"location":"examples/basic-model/#filter-by-exact-match","title":"Filter by Exact Match","text":"<p>Query records matching specific field values:</p> <pre><code>// Single field filter\nconst admins = await User.where({ role: \"admin\" });\nconsole.log(`Found ${admins.length} admin users`);\n\n// Multiple field filters (AND condition)\nconst active_admins = await User.where({\n  role: \"admin\",\n  active: true\n});\nconsole.log(`Found ${active_admins.length} active admin users`);\n</code></pre>"},{"location":"examples/basic-model/#get-first-or-last-record","title":"Get First or Last Record","text":"<p>Retrieve the first or last record matching criteria:</p> <pre><code>// Get first user\nconst first_user = await User.first({});\nconsole.log(`First user: ${first_user?.name}`);\n\n// Get first admin\nconst first_admin = await User.first({ role: \"admin\" });\nconsole.log(`First admin: ${first_admin?.name}`);\n\n// Get last user\nconst last_user = await User.last({});\nconsole.log(`Last user: ${last_user?.name}`);\n\n// Get last customer\nconst last_customer = await User.last({ role: \"customer\" });\nconsole.log(`Last customer: ${last_customer?.name}`);\n</code></pre>"},{"location":"examples/basic-model/#query-by-field-and-value","title":"Query by Field and Value","text":"<p>Use method signature with field name and value:</p> <pre><code>// Query by single field\nconst johns = await User.where(\"name\", \"John Doe\");\nconsole.log(`Found ${johns.length} users named John Doe`);\n\n// Query with array value (IN operator)\nconst specific_users = await User.where(\"id\", [\n  \"user-1\",\n  \"user-2\",\n  \"user-3\"\n]);\nconsole.log(`Found ${specific_users.length} specific users`);\n</code></pre>"},{"location":"examples/basic-model/#query-with-options","title":"Query with Options","text":"<p>Use query options for pagination, sorting, and attribute selection:</p> <pre><code>// Limit results\nconst first_10 = await User.where({}, { limit: 10 });\nconsole.log(`Retrieved ${first_10.length} users`);\n\n// Pagination (skip and limit)\nconst page_2 = await User.where({}, {\n  skip: 10,\n  limit: 10\n});\nconsole.log(`Page 2: ${page_2.length} users`);\n\n// Sort order (ASC or DESC)\nconst sorted_users = await User.where({}, {\n  order: \"DESC\"\n});\n\n// Select specific attributes only\nconst user_summaries = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\"]\n});\n\nuser_summaries.forEach(user =&gt; {\n  console.log(`${user.name}: ${user.email}`);\n  // role, active, timestamps are not loaded\n});\n</code></pre>"},{"location":"examples/basic-model/#updating-records","title":"Updating Records","text":""},{"location":"examples/basic-model/#using-instance-save-method","title":"Using Instance <code>save()</code> Method","text":"<p>Modify instance properties and call <code>save()</code>:</p> <pre><code>// Get a user\nconst user = await User.first({ email: \"john@example.com\" });\n\nif (user) {\n  // Modify properties\n  user.name = \"John Smith\";\n  user.role = \"premium\";\n\n  // Save changes\n  await user.save();\n\n  console.log(`Updated user: ${user.name}`);\n  console.log(`Updated at: ${user.updated_at}`);\n  // updated_at timestamp is automatically updated\n}\n</code></pre>"},{"location":"examples/basic-model/#using-instance-update-method","title":"Using Instance <code>update()</code> Method","text":"<p>Update multiple fields at once:</p> <pre><code>const user = await User.first({ email: \"john@example.com\" });\n\nif (user) {\n  await user.update({\n    name: \"John Smith\",\n    role: \"premium\",\n    active: true\n  });\n\n  console.log(`User updated: ${user.name}`);\n}\n</code></pre>"},{"location":"examples/basic-model/#using-static-update-method","title":"Using Static <code>update()</code> Method","text":"<p>Update records by filter criteria:</p> <pre><code>// Update all users matching filter\nconst updated_count = await User.update(\n  { name: \"John A. Smith\", role: \"premium\" },\n  { email: \"john@example.com\" }\n);\n\nconsole.log(`Updated ${updated_count} user(s)`);\n</code></pre>"},{"location":"examples/basic-model/#batch-updates","title":"Batch Updates","text":"<p>Update multiple records efficiently:</p> <pre><code>// Get all customers\nconst customers = await User.where({ role: \"customer\" });\n\n// Upgrade all to premium\nawait Promise.all(customers.map(user =&gt; {\n  user.role = \"premium\";\n  return user.save();\n}));\n\nconsole.log(`Upgraded ${customers.length} customers to premium`);\n</code></pre>"},{"location":"examples/basic-model/#conditional-updates","title":"Conditional Updates","text":"<p>Update only records matching specific conditions:</p> <pre><code>// Get inactive users\nconst inactive_users = await User.where({ active: false });\n\n// Reactivate users created in the last month\nconst one_month_ago = new Date();\none_month_ago.setMonth(one_month_ago.getMonth() - 1);\n\nconst reactivated = await Promise.all(\n  inactive_users\n    .filter(user =&gt; new Date(user.created_at) &gt; one_month_ago)\n    .map(user =&gt; {\n      user.active = true;\n      return user.save();\n    })\n);\n\nconsole.log(`Reactivated ${reactivated.length} users`);\n</code></pre>"},{"location":"examples/basic-model/#deleting-records","title":"Deleting Records","text":""},{"location":"examples/basic-model/#using-instance-destroy-method","title":"Using Instance <code>destroy()</code> Method","text":"<p>Delete a specific instance:</p> <pre><code>const user = await User.first({ email: \"john@example.com\" });\n\nif (user) {\n  await user.destroy();\n  console.log(`Deleted user: ${user.name}`);\n}\n</code></pre>"},{"location":"examples/basic-model/#using-static-delete-method","title":"Using Static <code>delete()</code> Method","text":"<p>Delete records matching filter criteria:</p> <pre><code>// Delete by filter\nconst deleted_count = await User.delete({ email: \"john@example.com\" });\nconsole.log(`Deleted ${deleted_count} user(s)`);\n\n// Delete multiple users\nconst deleted_inactive = await User.delete({ active: false });\nconsole.log(`Deleted ${deleted_inactive} inactive user(s)`);\n</code></pre>"},{"location":"examples/basic-model/#batch-delete","title":"Batch Delete","text":"<p>Delete multiple records efficiently:</p> <pre><code>// Get all inactive users\nconst inactive_users = await User.where({ active: false });\n\n// Delete all inactive users\nawait Promise.all(inactive_users.map(user =&gt; user.destroy()));\n\nconsole.log(`Deleted ${inactive_users.length} inactive users`);\n</code></pre>"},{"location":"examples/basic-model/#conditional-delete","title":"Conditional Delete","text":"<p>Delete only records matching complex criteria:</p> <pre><code>// Get all users\nconst all_users = await User.where({});\n\n// Delete old inactive users (inactive for over 6 months)\nconst six_months_ago = new Date();\nsix_months_ago.setMonth(six_months_ago.getMonth() - 6);\n\nconst to_delete = all_users.filter(user =&gt;\n  !user.active &amp;&amp; new Date(user.updated_at) &lt; six_months_ago\n);\n\nawait Promise.all(to_delete.map(user =&gt; user.destroy()));\n\nconsole.log(`Deleted ${to_delete.length} old inactive users`);\n</code></pre>"},{"location":"examples/basic-model/#complete-working-example","title":"Complete Working Example","text":"<p>Here's a complete, runnable example that demonstrates all CRUD operations:</p> <pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  CreationOptional,\n  Dynamite\n} from \"@arcaelas/dynamite\";\n\n// Configure DynamoDB connection\nDynamite.config({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  }\n});\n\n// Define User model\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare email: string;\n\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n}\n\n// Main application\nasync function main() {\n  console.log(\"=== User Management System ===\\n\");\n\n  // 1. CREATE - Add new users\n  console.log(\"1. Creating users...\");\n  const user1 = await User.create({\n    name: \"John Doe\",\n    email: \"john@example.com\"\n  });\n  console.log(`Created: ${user1.name} (${user1.id})`);\n\n  const user2 = await User.create({\n    name: \"Jane Smith\",\n    email: \"jane@example.com\",\n    role: \"admin\"\n  });\n  console.log(`Created: ${user2.name} (${user2.id})`);\n\n  const user3 = await User.create({\n    name: \"Bob Johnson\",\n    email: \"bob@example.com\"\n  });\n  console.log(`Created: ${user3.name} (${user3.id})\\n`);\n\n  // 2. READ - Get all users\n  console.log(\"2. Listing all users...\");\n  const all_users = await User.where({});\n  console.log(`Total users: ${all_users.length}`);\n  all_users.forEach(user =&gt; {\n    console.log(`  - ${user.name} (${user.role})`);\n  });\n  console.log();\n\n  // 3. READ - Filter by role\n  console.log(\"3. Filtering users by role...\");\n  const customers = await User.where({ role: \"customer\" });\n  console.log(`Customers: ${customers.length}`);\n  customers.forEach(user =&gt; {\n    console.log(`  - ${user.name}`);\n  });\n  console.log();\n\n  // 4. READ - Get first and last\n  console.log(\"4. Getting first and last users...\");\n  const first_user = await User.first({});\n  const last_user = await User.last({});\n  console.log(`First user: ${first_user?.name}`);\n  console.log(`Last user: ${last_user?.name}\\n`);\n\n  // 5. READ - Query with options\n  console.log(\"5. Getting users with specific attributes...\");\n  const user_summaries = await User.where({}, {\n    attributes: [\"id\", \"name\", \"email\"]\n  });\n  user_summaries.forEach(user =&gt; {\n    console.log(`  - ${user.name}: ${user.email}`);\n  });\n  console.log();\n\n  // 6. UPDATE - Modify a user\n  console.log(\"6. Updating user...\");\n  const user_to_update = await User.first({ name: \"John Doe\" });\n  if (user_to_update) {\n    user_to_update.name = \"John A. Doe\";\n    user_to_update.role = \"premium\";\n    await user_to_update.save();\n    console.log(`Updated: ${user_to_update.name} (${user_to_update.role})\\n`);\n  }\n\n  // 7. UPDATE - Batch update\n  console.log(\"7. Batch updating customers to premium...\");\n  const customers_to_upgrade = await User.where({ role: \"customer\" });\n  await Promise.all(customers_to_upgrade.map(user =&gt; {\n    user.role = \"premium\";\n    return user.save();\n  }));\n  console.log(`Upgraded ${customers_to_upgrade.length} customers\\n`);\n\n  // 8. READ - Verify updates\n  console.log(\"8. Verifying updates...\");\n  const premium_users = await User.where({ role: \"premium\" });\n  console.log(`Premium users: ${premium_users.length}`);\n  premium_users.forEach(user =&gt; {\n    console.log(`  - ${user.name}`);\n  });\n  console.log();\n\n  // 9. DELETE - Remove a user\n  console.log(\"9. Deleting a user...\");\n  const user_to_delete = await User.first({ name: \"Bob Johnson\" });\n  if (user_to_delete) {\n    await user_to_delete.destroy();\n    console.log(`Deleted: ${user_to_delete.name}\\n`);\n  }\n\n  // 10. READ - Final count\n  console.log(\"10. Final user count...\");\n  const final_users = await User.where({});\n  console.log(`Total users: ${final_users.length}`);\n  final_users.forEach(user =&gt; {\n    console.log(`  - ${user.name} (${user.role})`);\n  });\n  console.log();\n\n  console.log(\"=== All operations completed successfully ===\");\n}\n\n// Run the application\nmain().catch(console.error);\n</code></pre>"},{"location":"examples/basic-model/#expected-output","title":"Expected Output","text":"<p>When you run the complete example, you should see output similar to this:</p> <pre><code>=== User Management System ===\n\n1. Creating users...\nCreated: John Doe (550e8400-e29b-41d4-a716-446655440000)\nCreated: Jane Smith (6ba7b810-9dad-11d1-80b4-00c04fd430c8)\nCreated: Bob Johnson (6ba7b811-9dad-11d1-80b4-00c04fd430c9)\n\n2. Listing all users...\nTotal users: 3\n  - John Doe (customer)\n  - Jane Smith (admin)\n  - Bob Johnson (customer)\n\n3. Filtering users by role...\nCustomers: 2\n  - John Doe\n  - Bob Johnson\n\n4. Getting first and last users...\nFirst user: John Doe\nLast user: Bob Johnson\n\n5. Getting users with specific attributes...\n  - John Doe: john@example.com\n  - Jane Smith: jane@example.com\n  - Bob Johnson: bob@example.com\n\n6. Updating user...\nUpdated: John A. Doe (premium)\n\n7. Batch updating customers to premium...\nUpgraded 1 customers\n\n8. Verifying updates...\nPremium users: 2\n  - John A. Doe\n  - Bob Johnson\n\n9. Deleting a user...\nDeleted: Bob Johnson\n\n10. Final user count...\nTotal users: 2\n  - John A. Doe (premium)\n  - Jane Smith (admin)\n\n=== All operations completed successfully ===\n</code></pre>"},{"location":"examples/basic-model/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/basic-model/#1-model-definition","title":"1. Model Definition","text":"<p>Models are TypeScript classes that extend <code>Table&lt;T&gt;</code>:</p> <pre><code>class User extends Table&lt;User&gt; {\n  // Field definitions with decorators\n}\n</code></pre> <p>The generic parameter <code>&lt;User&gt;</code> provides type safety throughout the ORM.</p>"},{"location":"examples/basic-model/#2-decorators","title":"2. Decorators","text":"<p>Decorators define field behavior:</p> <ul> <li>@PrimaryKey() - Marks the partition key (required for every model)</li> <li>@Default() - Provides automatic default values</li> <li>@CreatedAt() - Auto-sets timestamp on creation</li> <li>@UpdatedAt() - Auto-updates timestamp on save</li> </ul>"},{"location":"examples/basic-model/#3-type-safety","title":"3. Type Safety","text":"<p>The <code>CreationOptional&lt;T&gt;</code> type makes fields optional during creation but required in instances:</p> <pre><code>@Default(() =&gt; \"customer\")\ndeclare role: CreationOptional&lt;string&gt;;\n\n// During creation:\nawait User.create({ name: \"John\" }); // role is optional\n\n// In instance:\nconst user = await User.first({});\nconsole.log(user.role); // role is guaranteed to exist (string)\n</code></pre>"},{"location":"examples/basic-model/#4-query-methods","title":"4. Query Methods","text":"<p>Dynamite provides flexible query methods:</p> <ul> <li><code>where()</code> - Filter records with various signatures</li> <li><code>first()</code> - Get first matching record</li> <li><code>last()</code> - Get last matching record</li> <li><code>create()</code> - Create new record</li> <li><code>update()</code> - Update records</li> <li><code>delete()</code> - Delete records</li> </ul>"},{"location":"examples/basic-model/#5-instance-vs-static-methods","title":"5. Instance vs Static Methods","text":"<p>Instance methods operate on a specific record: <pre><code>const user = await User.first({ id: \"123\" });\nuser.name = \"New Name\";\nawait user.save();\nawait user.destroy();\n</code></pre></p> <p>Static methods operate on the model class: <pre><code>await User.create({ name: \"John\" });\nawait User.where({ role: \"admin\" });\nawait User.update({ name: \"New\" }, { id: \"123\" });\nawait User.delete({ id: \"123\" });\n</code></pre></p>"},{"location":"examples/basic-model/#6-timestamps","title":"6. Timestamps","text":"<p>Timestamp fields are automatically managed:</p> <pre><code>@CreatedAt()\ndeclare created_at: CreationOptional&lt;string&gt;;\n\n@UpdatedAt()\ndeclare updated_at: CreationOptional&lt;string&gt;;\n</code></pre> <ul> <li><code>created_at</code> is set once on creation</li> <li><code>updated_at</code> is updated on every <code>save()</code> call</li> </ul>"},{"location":"examples/basic-model/#7-default-values","title":"7. Default Values","text":"<p>Default values can be static or dynamic:</p> <pre><code>// Static default\n@Default(\"customer\")\ndeclare role: CreationOptional&lt;string&gt;;\n\n// Dynamic default (function)\n@Default(() =&gt; crypto.randomUUID())\ndeclare id: CreationOptional&lt;string&gt;;\n\n@Default(() =&gt; new Date().toISOString())\ndeclare joined_date: CreationOptional&lt;string&gt;;\n</code></pre>"},{"location":"examples/basic-model/#next-steps","title":"Next Steps","text":"<p>Now that you understand basic CRUD operations, explore these advanced topics:</p>"},{"location":"examples/basic-model/#related-documentation","title":"Related Documentation","text":"<ul> <li>Validation Example - Data validation and transformation patterns</li> <li>Relationships Example - One-to-many and many-to-one relationships</li> <li>Advanced Queries Example - Complex queries, pagination, and filtering</li> </ul>"},{"location":"examples/basic-model/#api-references","title":"API References","text":"<ul> <li>Table API Reference - Complete Table class documentation</li> <li>Decorators Guide - All available decorators</li> <li>Core Concepts - Deep dive into Dynamite architecture</li> </ul>"},{"location":"examples/basic-model/#best-practices","title":"Best Practices","text":"<ol> <li>Always define a primary key with <code>@PrimaryKey()</code> decorator</li> <li>Use CreationOptional for fields with <code>@Default</code>, <code>@CreatedAt</code>, <code>@UpdatedAt</code></li> <li>Select specific attributes when you don't need all fields (reduces data transfer)</li> <li>Use batch operations for better performance with multiple records</li> <li>Handle errors with try-catch blocks in production code</li> <li>Validate timestamps before using them in date calculations</li> </ol>"},{"location":"examples/basic-model/#common-patterns","title":"Common Patterns","text":"<p>Soft Delete Pattern: <pre><code>class User extends Table&lt;User&gt; {\n  @Default(() =&gt; false)\n  declare deleted: CreationOptional&lt;boolean&gt;;\n\n  @Default(() =&gt; null)\n  declare deleted_at: CreationOptional&lt;string | null&gt;;\n}\n\n// Soft delete\nuser.deleted = true;\nuser.deleted_at = new Date().toISOString();\nawait user.save();\n\n// Query only active users\nconst active_users = await User.where({ deleted: false });\n</code></pre></p> <p>Pagination Pattern: <pre><code>async function get_paginated_users(page: number, page_size: number) {\n  return await User.where({}, {\n    skip: page * page_size,\n    limit: page_size\n  });\n}\n\nconst page_1 = await get_paginated_users(0, 10); // First 10 users\nconst page_2 = await get_paginated_users(1, 10); // Next 10 users\n</code></pre></p> <p>Search Pattern: <pre><code>async function search_users(query: string) {\n  const all_users = await User.where({});\n  return all_users.filter(user =&gt;\n    user.name.toLowerCase().includes(query.toLowerCase()) ||\n    user.email.toLowerCase().includes(query.toLowerCase())\n  );\n}\n\nconst results = await search_users(\"john\");\n</code></pre></p>"},{"location":"examples/basic-model/#troubleshooting","title":"Troubleshooting","text":"<p>Issue: \"Metadata not found\" - Ensure <code>Dynamite.config()</code> is called before using models - Check for circular imports</p> <p>Issue: \"Primary key missing\" - Add <code>@PrimaryKey()</code> decorator to at least one field - Or use <code>@Index()</code> decorator (alias for PrimaryKey)</p> <p>Issue: \"Record not updating\" - Call <code>save()</code> after modifying instance properties - Check that timestamps are using <code>CreationOptional</code></p> <p>Issue: \"Query returns empty array\" - Verify filter criteria match actual data - Check table name matches DynamoDB table (use <code>@Name()</code> if custom)</p>"},{"location":"examples/basic-model/#additional-resources","title":"Additional Resources","text":"<ul> <li>GitHub Repository</li> <li>Getting Started Guide</li> <li>Best Practices</li> </ul> <p>Happy coding with Dynamite!</p>"},{"location":"examples/relationships/","title":"Relationships Example","text":"<p>This comprehensive example demonstrates how to define and use relationships in Dynamite ORM. Learn how to create one-to-many (HasMany) and many-to-one (BelongsTo) relationships, perform nested includes, filter related data, and build complex data structures.</p>"},{"location":"examples/relationships/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Relationship Basics</li> <li>One-to-Many (HasMany)</li> <li>Many-to-One (BelongsTo)</li> <li>Nested Relationships</li> <li>Filtered Relationships</li> <li>Complete E-Commerce Example</li> <li>Expected Output</li> <li>Advanced Patterns</li> <li>Best Practices</li> </ul>"},{"location":"examples/relationships/#relationship-basics","title":"Relationship Basics","text":"<p>Dynamite supports two types of relationships:</p> <ul> <li>HasMany - One-to-many relationship (parent has multiple children)</li> <li>BelongsTo - Many-to-one relationship (child belongs to parent)</li> </ul>"},{"location":"examples/relationships/#key-concepts","title":"Key Concepts","text":"<pre><code>import { HasMany, BelongsTo, NonAttribute } from \"@arcaelas/dynamite\";\n\n// Parent model (User has many Orders)\nclass User extends Table&lt;User&gt; {\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n}\n\n// Child model (Order belongs to User)\nclass Order extends Table&lt;Order&gt; {\n  declare user_id: string; // Foreign key\n\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n</code></pre> <p>Important: - Use <code>NonAttribute&lt;&gt;</code> wrapper for relationship fields (they're not stored in DB) - <code>HasMany&lt;T&gt;</code> resolves to <code>T[]</code> (array of related records) - <code>BelongsTo&lt;T&gt;</code> resolves to <code>T | null</code> (single related record or null) - Foreign key field must exist on the child model</p>"},{"location":"examples/relationships/#one-to-many-hasmany","title":"One-to-Many (HasMany)","text":"<p>Define a one-to-many relationship where a parent model has multiple related children.</p>"},{"location":"examples/relationships/#basic-hasmany-example","title":"Basic HasMany Example","text":"<pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  HasMany,\n  CreationOptional,\n  NonAttribute\n} from \"@arcaelas/dynamite\";\n\n// User model (parent)\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare email: string;\n\n  // One-to-many: User has many Posts\n  @HasMany(() =&gt; Post, \"user_id\")\n  declare posts: NonAttribute&lt;HasMany&lt;Post&gt;&gt;;\n}\n\n// Post model (child)\nclass Post extends Table&lt;Post&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare user_id: string; // Foreign key\n  declare title: string;\n  declare content: string;\n}\n</code></pre>"},{"location":"examples/relationships/#loading-hasmany-relationships","title":"Loading HasMany Relationships","text":"<pre><code>// Load users with their posts\nconst users_with_posts = await User.where({}, {\n  include: {\n    posts: {}\n  }\n});\n\nusers_with_posts.forEach(user =&gt; {\n  console.log(`${user.name} has ${user.posts.length} posts`);\n  user.posts.forEach(post =&gt; {\n    console.log(`  - ${post.title}`);\n  });\n});\n\n// Load specific user with posts\nconst user = await User.first({ id: \"user-123\" });\nif (user) {\n  const user_with_posts = await User.where({ id: user.id }, {\n    include: { posts: {} }\n  });\n  console.log(`Posts: ${user_with_posts[0].posts.length}`);\n}\n</code></pre>"},{"location":"examples/relationships/#multiple-hasmany-relationships","title":"Multiple HasMany Relationships","text":"<p>A model can have multiple one-to-many relationships:</p> <pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n\n  // User has many Posts\n  @HasMany(() =&gt; Post, \"user_id\")\n  declare posts: NonAttribute&lt;HasMany&lt;Post&gt;&gt;;\n\n  // User has many Comments\n  @HasMany(() =&gt; Comment, \"user_id\")\n  declare comments: NonAttribute&lt;HasMany&lt;Comment&gt;&gt;;\n\n  // User has many Orders\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n}\n\n// Load user with all relationships\nconst users = await User.where({ id: \"user-123\" }, {\n  include: {\n    posts: {},\n    comments: {},\n    orders: {}\n  }\n});\n\nconst user = users[0];\nconsole.log(`Posts: ${user.posts.length}`);\nconsole.log(`Comments: ${user.comments.length}`);\nconsole.log(`Orders: ${user.orders.length}`);\n</code></pre>"},{"location":"examples/relationships/#many-to-one-belongsto","title":"Many-to-One (BelongsTo)","text":"<p>Define a many-to-one relationship where a child model belongs to a single parent.</p>"},{"location":"examples/relationships/#basic-belongsto-example","title":"Basic BelongsTo Example","text":"<pre><code>// Post model (child)\nclass Post extends Table&lt;Post&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare user_id: string; // Foreign key\n  declare title: string;\n  declare content: string;\n\n  // Many-to-one: Post belongs to User\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n\n// User model (parent)\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare email: string;\n}\n</code></pre>"},{"location":"examples/relationships/#loading-belongsto-relationships","title":"Loading BelongsTo Relationships","text":"<pre><code>// Load posts with their author\nconst posts_with_author = await Post.where({}, {\n  include: {\n    user: {}\n  }\n});\n\nposts_with_author.forEach(post =&gt; {\n  console.log(`${post.title} by ${post.user?.name || 'Unknown'}`);\n});\n\n// Load specific post with author\nconst post = await Post.first({ id: \"post-123\" });\nif (post) {\n  const post_with_author = await Post.where({ id: post.id }, {\n    include: { user: {} }\n  });\n  console.log(`Author: ${post_with_author[0].user?.name}`);\n}\n</code></pre>"},{"location":"examples/relationships/#multiple-belongsto-relationships","title":"Multiple BelongsTo Relationships","text":"<p>A child model can belong to multiple parents:</p> <pre><code>class Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare user_id: string;\n  declare product_id: string;\n  declare quantity: number;\n\n  // Order belongs to User\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  // Order belongs to Product\n  @BelongsTo(() =&gt; Product, \"product_id\")\n  declare product: NonAttribute&lt;BelongsTo&lt;Product&gt;&gt;;\n}\n\n// Load order with both relationships\nconst orders = await Order.where({ id: \"order-123\" }, {\n  include: {\n    user: {},\n    product: {}\n  }\n});\n\nconst order = orders[0];\nconsole.log(`Customer: ${order.user?.name}`);\nconsole.log(`Product: ${order.product?.name}`);\nconsole.log(`Quantity: ${order.quantity}`);\n</code></pre>"},{"location":"examples/relationships/#nested-relationships","title":"Nested Relationships","text":"<p>Load relationships that have their own relationships (nested includes).</p>"},{"location":"examples/relationships/#two-level-nesting","title":"Two-Level Nesting","text":"<pre><code>// User has many Posts, Post has many Comments\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n  declare name: string;\n\n  @HasMany(() =&gt; Post, \"user_id\")\n  declare posts: NonAttribute&lt;HasMany&lt;Post&gt;&gt;;\n}\n\nclass Post extends Table&lt;Post&gt; {\n  @PrimaryKey()\n  declare id: string;\n  declare user_id: string;\n  declare title: string;\n\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  @HasMany(() =&gt; Comment, \"post_id\")\n  declare comments: NonAttribute&lt;HasMany&lt;Comment&gt;&gt;;\n}\n\nclass Comment extends Table&lt;Comment&gt; {\n  @PrimaryKey()\n  declare id: string;\n  declare post_id: string;\n  declare content: string;\n}\n\n// Load users with posts and comments\nconst users = await User.where({}, {\n  include: {\n    posts: {\n      include: {\n        comments: {}\n      }\n    }\n  }\n});\n\nusers.forEach(user =&gt; {\n  console.log(`${user.name}:`);\n  user.posts.forEach(post =&gt; {\n    console.log(`  ${post.title} (${post.comments.length} comments)`);\n    post.comments.forEach(comment =&gt; {\n      console.log(`    - ${comment.content}`);\n    });\n  });\n});\n</code></pre>"},{"location":"examples/relationships/#multi-level-nesting","title":"Multi-Level Nesting","text":"<pre><code>// Order -&gt; OrderItem -&gt; Product\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n  declare user_id: string;\n\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  @HasMany(() =&gt; OrderItem, \"order_id\")\n  declare items: NonAttribute&lt;HasMany&lt;OrderItem&gt;&gt;;\n}\n\nclass OrderItem extends Table&lt;OrderItem&gt; {\n  @PrimaryKey()\n  declare id: string;\n  declare order_id: string;\n  declare product_id: string;\n  declare quantity: number;\n\n  @BelongsTo(() =&gt; Product, \"product_id\")\n  declare product: NonAttribute&lt;BelongsTo&lt;Product&gt;&gt;;\n}\n\nclass Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare id: string;\n  declare name: string;\n  declare price: number;\n}\n\n// Load orders with items and products\nconst orders = await Order.where({}, {\n  include: {\n    user: {},\n    items: {\n      include: {\n        product: {}\n      }\n    }\n  }\n});\n\norders.forEach(order =&gt; {\n  console.log(`Order ${order.id} by ${order.user?.name}`);\n  order.items.forEach(item =&gt; {\n    console.log(`  ${item.quantity}x ${item.product?.name} @ $${item.product?.price}`);\n  });\n});\n</code></pre>"},{"location":"examples/relationships/#filtered-relationships","title":"Filtered Relationships","text":"<p>Apply filters, limits, and ordering to related data.</p>"},{"location":"examples/relationships/#filter-related-records","title":"Filter Related Records","text":"<pre><code>// Load user with only published posts\nconst users = await User.where({ id: \"user-123\" }, {\n  include: {\n    posts: {\n      where: { status: \"published\" }\n    }\n  }\n});\n\nconsole.log(`Published posts: ${users[0].posts.length}`);\n</code></pre>"},{"location":"examples/relationships/#limit-related-records","title":"Limit Related Records","text":"<pre><code>// Load user with 5 most recent posts\nconst users = await User.where({ id: \"user-123\" }, {\n  include: {\n    posts: {\n      limit: 5,\n      order: \"DESC\"\n    }\n  }\n});\n\nconsole.log(`Recent posts: ${users[0].posts.length}`);\n</code></pre>"},{"location":"examples/relationships/#select-specific-attributes","title":"Select Specific Attributes","text":"<pre><code>// Load posts with only user name and email\nconst posts = await Post.where({}, {\n  include: {\n    user: {\n      attributes: [\"id\", \"name\", \"email\"]\n    }\n  }\n});\n\nposts.forEach(post =&gt; {\n  console.log(`${post.title} by ${post.user?.name} (${post.user?.email})`);\n});\n</code></pre>"},{"location":"examples/relationships/#combined-filters","title":"Combined Filters","text":"<pre><code>// Complex relationship query\nconst users = await User.where({ role: \"premium\" }, {\n  include: {\n    orders: {\n      where: { status: \"completed\" },\n      limit: 10,\n      order: \"DESC\",\n      attributes: [\"id\", \"total\", \"created_at\"]\n    },\n    posts: {\n      where: { published: true },\n      limit: 5\n    }\n  }\n});\n\nusers.forEach(user =&gt; {\n  console.log(`${user.name}:`);\n  console.log(`  Recent orders: ${user.orders.length}`);\n  console.log(`  Published posts: ${user.posts.length}`);\n});\n</code></pre>"},{"location":"examples/relationships/#complete-e-commerce-example","title":"Complete E-Commerce Example","text":"<p>Here's a complete e-commerce system demonstrating all relationship patterns:</p> <pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  HasMany,\n  BelongsTo,\n  CreatedAt,\n  UpdatedAt,\n  CreationOptional,\n  NonAttribute,\n  Dynamite\n} from \"@arcaelas/dynamite\";\n\n// Configure DynamoDB\nDynamite.config({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  }\n});\n\n// User model\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare email: string;\n\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n\n  // Relationships\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n\n  @HasMany(() =&gt; Review, \"user_id\")\n  declare reviews: NonAttribute&lt;HasMany&lt;Review&gt;&gt;;\n}\n\n// Product model\nclass Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare description: string;\n  declare price: number;\n\n  @Default(() =&gt; 0)\n  declare stock: CreationOptional&lt;number&gt;;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  // Relationships\n  @HasMany(() =&gt; OrderItem, \"product_id\")\n  declare order_items: NonAttribute&lt;HasMany&lt;OrderItem&gt;&gt;;\n\n  @HasMany(() =&gt; Review, \"product_id\")\n  declare reviews: NonAttribute&lt;HasMany&lt;Review&gt;&gt;;\n}\n\n// Order model\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare user_id: string;\n\n  @Default(() =&gt; \"pending\")\n  declare status: CreationOptional&lt;string&gt;;\n\n  declare total: number;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n\n  // Relationships\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  @HasMany(() =&gt; OrderItem, \"order_id\")\n  declare items: NonAttribute&lt;HasMany&lt;OrderItem&gt;&gt;;\n}\n\n// OrderItem model\nclass OrderItem extends Table&lt;OrderItem&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare order_id: string;\n  declare product_id: string;\n  declare quantity: number;\n  declare price: number;\n\n  // Relationships\n  @BelongsTo(() =&gt; Order, \"order_id\")\n  declare order: NonAttribute&lt;BelongsTo&lt;Order&gt;&gt;;\n\n  @BelongsTo(() =&gt; Product, \"product_id\")\n  declare product: NonAttribute&lt;BelongsTo&lt;Product&gt;&gt;;\n}\n\n// Review model\nclass Review extends Table&lt;Review&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare user_id: string;\n  declare product_id: string;\n  declare rating: number;\n  declare comment: string;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  // Relationships\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  @BelongsTo(() =&gt; Product, \"product_id\")\n  declare product: NonAttribute&lt;BelongsTo&lt;Product&gt;&gt;;\n}\n\n// Main application\nasync function main() {\n  console.log(\"=== E-Commerce Relationships Example ===\\n\");\n\n  // 1. Create users\n  console.log(\"1. Creating users...\");\n  const user1 = await User.create({\n    name: \"John Doe\",\n    email: \"john@example.com\"\n  });\n  const user2 = await User.create({\n    name: \"Jane Smith\",\n    email: \"jane@example.com\"\n  });\n  console.log(`Created: ${user1.name}, ${user2.name}\\n`);\n\n  // 2. Create products\n  console.log(\"2. Creating products...\");\n  const product1 = await Product.create({\n    name: \"Laptop\",\n    description: \"High-performance laptop\",\n    price: 999.99,\n    stock: 10\n  });\n  const product2 = await Product.create({\n    name: \"Mouse\",\n    description: \"Wireless mouse\",\n    price: 29.99,\n    stock: 50\n  });\n  const product3 = await Product.create({\n    name: \"Keyboard\",\n    description: \"Mechanical keyboard\",\n    price: 79.99,\n    stock: 30\n  });\n  console.log(`Created: ${product1.name}, ${product2.name}, ${product3.name}\\n`);\n\n  // 3. Create orders\n  console.log(\"3. Creating orders...\");\n  const order1 = await Order.create({\n    user_id: user1.id,\n    total: 1109.97,\n    status: \"pending\"\n  });\n  const order2 = await Order.create({\n    user_id: user2.id,\n    total: 79.99,\n    status: \"completed\"\n  });\n  console.log(`Created: Order ${order1.id}, Order ${order2.id}\\n`);\n\n  // 4. Create order items\n  console.log(\"4. Creating order items...\");\n  await OrderItem.create({\n    order_id: order1.id,\n    product_id: product1.id,\n    quantity: 1,\n    price: 999.99\n  });\n  await OrderItem.create({\n    order_id: order1.id,\n    product_id: product2.id,\n    quantity: 2,\n    price: 29.99\n  });\n  await OrderItem.create({\n    order_id: order1.id,\n    product_id: product3.id,\n    quantity: 1,\n    price: 79.99\n  });\n  await OrderItem.create({\n    order_id: order2.id,\n    product_id: product3.id,\n    quantity: 1,\n    price: 79.99\n  });\n  console.log(\"Order items created\\n\");\n\n  // 5. Create reviews\n  console.log(\"5. Creating reviews...\");\n  await Review.create({\n    user_id: user1.id,\n    product_id: product1.id,\n    rating: 5,\n    comment: \"Excellent laptop! Very fast and reliable.\"\n  });\n  await Review.create({\n    user_id: user2.id,\n    product_id: product3.id,\n    rating: 4,\n    comment: \"Great keyboard, but a bit loud.\"\n  });\n  console.log(\"Reviews created\\n\");\n\n  // 6. Load user with orders\n  console.log(\"6. Loading user with orders...\");\n  const users_with_orders = await User.where({ id: user1.id }, {\n    include: {\n      orders: {}\n    }\n  });\n  const user_with_orders = users_with_orders[0];\n  console.log(`${user_with_orders.name} has ${user_with_orders.orders.length} order(s)`);\n  user_with_orders.orders.forEach(order =&gt; {\n    console.log(`  Order ${order.id}: $${order.total} (${order.status})`);\n  });\n  console.log();\n\n  // 7. Load order with items and products\n  console.log(\"7. Loading order with items and products...\");\n  const orders_with_items = await Order.where({ id: order1.id }, {\n    include: {\n      user: {},\n      items: {\n        include: {\n          product: {}\n        }\n      }\n    }\n  });\n  const order_with_items = orders_with_items[0];\n  console.log(`Order ${order_with_items.id} by ${order_with_items.user?.name}`);\n  console.log(`Total: $${order_with_items.total}`);\n  console.log(\"Items:\");\n  order_with_items.items.forEach(item =&gt; {\n    console.log(`  ${item.quantity}x ${item.product?.name} @ $${item.price}`);\n  });\n  console.log();\n\n  // 8. Load product with reviews and reviewers\n  console.log(\"8. Loading product with reviews...\");\n  const products_with_reviews = await Product.where({ id: product1.id }, {\n    include: {\n      reviews: {\n        include: {\n          user: {}\n        }\n      }\n    }\n  });\n  const product_with_reviews = products_with_reviews[0];\n  console.log(`${product_with_reviews.name} - Reviews:`);\n  product_with_reviews.reviews.forEach(review =&gt; {\n    console.log(`  ${review.rating}/5 by ${review.user?.name}`);\n    console.log(`  \"${review.comment}\"`);\n  });\n  console.log();\n\n  // 9. Load user with orders, reviews, and related data\n  console.log(\"9. Loading user with all relationships...\");\n  const users_complete = await User.where({ id: user1.id }, {\n    include: {\n      orders: {\n        include: {\n          items: {\n            include: {\n              product: {}\n            }\n          }\n        }\n      },\n      reviews: {\n        include: {\n          product: {}\n        }\n      }\n    }\n  });\n  const user_complete = users_complete[0];\n  console.log(`${user_complete.name}:`);\n  console.log(`  Orders: ${user_complete.orders.length}`);\n  user_complete.orders.forEach(order =&gt; {\n    console.log(`    - Order ${order.id}: ${order.items.length} items, $${order.total}`);\n  });\n  console.log(`  Reviews: ${user_complete.reviews.length}`);\n  user_complete.reviews.forEach(review =&gt; {\n    console.log(`    - ${review.rating}/5 for ${review.product?.name}`);\n  });\n  console.log();\n\n  // 10. Load orders with filters\n  console.log(\"10. Loading completed orders only...\");\n  const all_users_with_completed = await User.where({}, {\n    include: {\n      orders: {\n        where: { status: \"completed\" }\n      }\n    }\n  });\n  all_users_with_completed.forEach(user =&gt; {\n    if (user.orders.length &gt; 0) {\n      console.log(`${user.name}: ${user.orders.length} completed order(s)`);\n    }\n  });\n  console.log();\n\n  console.log(\"=== All relationship operations completed ===\");\n}\n\n// Run the application\nmain().catch(console.error);\n</code></pre>"},{"location":"examples/relationships/#expected-output","title":"Expected Output","text":"<pre><code>=== E-Commerce Relationships Example ===\n\n1. Creating users...\nCreated: John Doe, Jane Smith\n\n2. Creating products...\nCreated: Laptop, Mouse, Keyboard\n\n3. Creating orders...\nCreated: Order 550e8400-..., Order 6ba7b810-...\n\n4. Creating order items...\nOrder items created\n\n5. Creating reviews...\nReviews created\n\n6. Loading user with orders...\nJohn Doe has 1 order(s)\n  Order 550e8400-...: $1109.97 (pending)\n\n7. Loading order with items and products...\nOrder 550e8400-... by John Doe\nTotal: $1109.97\nItems:\n  1x Laptop @ $999.99\n  2x Mouse @ $29.99\n  1x Keyboard @ $79.99\n\n8. Loading product with reviews...\nLaptop - Reviews:\n  5/5 by John Doe\n  \"Excellent laptop! Very fast and reliable.\"\n\n9. Loading user with all relationships...\nJohn Doe:\n  Orders: 1\n    - Order 550e8400-...: 3 items, $1109.97\n  Reviews: 1\n    - 5/5 for Laptop\n\n10. Loading completed orders only...\nJane Smith: 1 completed order(s)\n\n=== All relationship operations completed ===\n</code></pre>"},{"location":"examples/relationships/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"examples/relationships/#self-referential-relationships","title":"Self-Referential Relationships","text":"<p>Models can have relationships with themselves:</p> <pre><code>class Category extends Table&lt;Category&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare name: string;\n  declare parent_id: string | null;\n\n  // Category has many child categories\n  @HasMany(() =&gt; Category, \"parent_id\")\n  declare children: NonAttribute&lt;HasMany&lt;Category&gt;&gt;;\n\n  // Category belongs to parent category\n  @BelongsTo(() =&gt; Category, \"parent_id\")\n  declare parent: NonAttribute&lt;BelongsTo&lt;Category&gt;&gt;;\n}\n\n// Load category tree\nconst categories = await Category.where({ parent_id: null }, {\n  include: {\n    children: {\n      include: {\n        children: {}\n      }\n    }\n  }\n});\n</code></pre>"},{"location":"examples/relationships/#many-to-many-relationships-via-junction-table","title":"Many-to-Many Relationships (via Junction Table)","text":"<p>Implement many-to-many using a junction table:</p> <pre><code>// Student model\nclass Student extends Table&lt;Student&gt; {\n  @PrimaryKey()\n  declare id: string;\n  declare name: string;\n\n  @HasMany(() =&gt; Enrollment, \"student_id\")\n  declare enrollments: NonAttribute&lt;HasMany&lt;Enrollment&gt;&gt;;\n}\n\n// Course model\nclass Course extends Table&lt;Course&gt; {\n  @PrimaryKey()\n  declare id: string;\n  declare name: string;\n\n  @HasMany(() =&gt; Enrollment, \"course_id\")\n  declare enrollments: NonAttribute&lt;HasMany&lt;Enrollment&gt;&gt;;\n}\n\n// Junction table\nclass Enrollment extends Table&lt;Enrollment&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare student_id: string;\n  declare course_id: string;\n  declare grade: string;\n\n  @BelongsTo(() =&gt; Student, \"student_id\")\n  declare student: NonAttribute&lt;BelongsTo&lt;Student&gt;&gt;;\n\n  @BelongsTo(() =&gt; Course, \"course_id\")\n  declare course: NonAttribute&lt;BelongsTo&lt;Course&gt;&gt;;\n}\n\n// Load student with courses\nconst students = await Student.where({ id: \"student-123\" }, {\n  include: {\n    enrollments: {\n      include: {\n        course: {}\n      }\n    }\n  }\n});\n\nconst student = students[0];\nconsole.log(`${student.name}'s courses:`);\nstudent.enrollments.forEach(enrollment =&gt; {\n  console.log(`  ${enrollment.course?.name} - Grade: ${enrollment.grade}`);\n});\n</code></pre>"},{"location":"examples/relationships/#polymorphic-relationships","title":"Polymorphic Relationships","text":"<p>Implement polymorphic relationships using type fields:</p> <pre><code>class Comment extends Table&lt;Comment&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare commentable_type: string; // \"Post\" or \"Video\"\n  declare commentable_id: string;\n  declare content: string;\n\n  // Load polymorphic relationship manually\n  async get_commentable() {\n    if (this.commentable_type === \"Post\") {\n      return await Post.first({ id: this.commentable_id });\n    } else if (this.commentable_type === \"Video\") {\n      return await Video.first({ id: this.commentable_id });\n    }\n    return null;\n  }\n}\n</code></pre>"},{"location":"examples/relationships/#best-practices","title":"Best Practices","text":""},{"location":"examples/relationships/#1-use-nonattribute-for-relationships","title":"1. Use NonAttribute for Relationships","text":"<pre><code>// Good - marked as NonAttribute\n@HasMany(() =&gt; Order, \"user_id\")\ndeclare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n\n// Bad - will try to save to database\n@HasMany(() =&gt; Order, \"user_id\")\ndeclare orders: Order[];\n</code></pre>"},{"location":"examples/relationships/#2-define-foreign-keys-explicitly","title":"2. Define Foreign Keys Explicitly","text":"<pre><code>// Good - explicit foreign key\nclass Order extends Table&lt;Order&gt; {\n  declare user_id: string; // Foreign key field\n\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n\n// Bad - missing foreign key field\nclass Order extends Table&lt;Order&gt; {\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n</code></pre>"},{"location":"examples/relationships/#3-use-arrow-functions-in-decorators","title":"3. Use Arrow Functions in Decorators","text":"<pre><code>// Good - arrow function (avoids circular dependency)\n@HasMany(() =&gt; Order, \"user_id\")\ndeclare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n\n// Bad - direct reference (can cause circular dependency issues)\n@HasMany(Order, \"user_id\")\ndeclare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n</code></pre>"},{"location":"examples/relationships/#4-filter-relationships-for-performance","title":"4. Filter Relationships for Performance","text":"<pre><code>// Good - load only what you need\nconst users = await User.where({}, {\n  include: {\n    orders: {\n      where: { status: \"completed\" },\n      limit: 10,\n      attributes: [\"id\", \"total\"]\n    }\n  }\n});\n\n// Bad - loading all orders with all fields\nconst users = await User.where({}, {\n  include: {\n    orders: {}\n  }\n});\n</code></pre>"},{"location":"examples/relationships/#5-avoid-n1-queries","title":"5. Avoid N+1 Queries","text":"<pre><code>// Good - load relationships in one query\nconst posts = await Post.where({}, {\n  include: {\n    user: {},\n    comments: {}\n  }\n});\n\n// Bad - N+1 queries\nconst posts = await Post.where({});\nfor (const post of posts) {\n  const user = await User.first({ id: post.user_id });\n  const comments = await Comment.where({ post_id: post.id });\n}\n</code></pre>"},{"location":"examples/relationships/#next-steps","title":"Next Steps","text":""},{"location":"examples/relationships/#related-documentation","title":"Related Documentation","text":"<ul> <li>Basic Model Example - Simple CRUD operations</li> <li>Validation Example - Data validation patterns</li> <li>Advanced Queries Example - Complex queries and pagination</li> </ul>"},{"location":"examples/relationships/#api-references","title":"API References","text":"<ul> <li>HasMany Decorator - Complete HasMany documentation</li> <li>BelongsTo Decorator - Complete BelongsTo documentation</li> <li>Relationships Guide - Comprehensive relationships guide</li> </ul>"},{"location":"examples/relationships/#additional-topics","title":"Additional Topics","text":"<ul> <li>Eager Loading - Load all related data upfront</li> <li>Lazy Loading - Load relationships on-demand</li> <li>Relationship Caching - Cache frequently accessed relationships</li> <li>Circular Dependencies - Handle circular model references</li> </ul> <p>Happy coding with Dynamite relationships!</p>"},{"location":"examples/validation/","title":"Data Validation Example","text":"<p>This comprehensive example demonstrates data validation and transformation patterns in Dynamite ORM. Learn how to validate user input, transform data, create custom validators, and build robust models with data integrity.</p>"},{"location":"examples/validation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Basic Validation</li> <li>Data Transformation with Mutate</li> <li>Custom Validators</li> <li>Chaining Validators</li> <li>NotNull Validation</li> <li>Complex Validation Patterns</li> <li>Complete Working Example</li> <li>Expected Output</li> <li>Best Practices</li> <li>Common Validation Patterns</li> </ul>"},{"location":"examples/validation/#basic-validation","title":"Basic Validation","text":"<p>The <code>@Validate()</code> decorator allows you to define validation rules for model fields. Validators return <code>true</code> for valid data or an error message string for invalid data.</p>"},{"location":"examples/validation/#simple-validation","title":"Simple Validation","text":"<pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  Validate,\n  CreationOptional\n} from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Validate name length\n  @Validate((value) =&gt; {\n    const name = value as string;\n    return name.length &gt;= 2 || \"Name must be at least 2 characters\";\n  })\n  declare name: string;\n\n  // Validate email format\n  @Validate((value) =&gt; {\n    const email = value as string;\n    const email_regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return email_regex.test(email) || \"Invalid email format\";\n  })\n  declare email: string;\n\n  // Validate age range\n  @Validate((value) =&gt; {\n    const age = value as number;\n    if (age &lt; 0) return \"Age cannot be negative\";\n    if (age &gt; 150) return \"Age must be realistic\";\n    return true;\n  })\n  declare age: number;\n}\n</code></pre>"},{"location":"examples/validation/#usage","title":"Usage","text":"<pre><code>// Valid data\nconst user1 = await User.create({\n  name: \"John Doe\",\n  email: \"john@example.com\",\n  age: 25\n});\nconsole.log(\"User created successfully\");\n\n// Invalid name (too short)\ntry {\n  await User.create({\n    name: \"J\",\n    email: \"john@example.com\",\n    age: 25\n  });\n} catch (error) {\n  console.error(error.message); // \"Name must be at least 2 characters\"\n}\n\n// Invalid email format\ntry {\n  await User.create({\n    name: \"John Doe\",\n    email: \"invalid-email\",\n    age: 25\n  });\n} catch (error) {\n  console.error(error.message); // \"Invalid email format\"\n}\n\n// Invalid age (negative)\ntry {\n  await User.create({\n    name: \"John Doe\",\n    email: \"john@example.com\",\n    age: -5\n  });\n} catch (error) {\n  console.error(error.message); // \"Age cannot be negative\"\n}\n</code></pre>"},{"location":"examples/validation/#data-transformation-with-mutate","title":"Data Transformation with Mutate","text":"<p>The <code>@Mutate()</code> decorator transforms data before it's validated or stored. Important: Mutate always runs before Validate.</p>"},{"location":"examples/validation/#basic-transformation","title":"Basic Transformation","text":"<pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Transform email to lowercase and trim whitespace\n  @Mutate((value) =&gt; (value as string).toLowerCase().trim())\n  @Validate((value) =&gt; {\n    const email = value as string;\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email) || \"Invalid email\";\n  })\n  declare email: string;\n\n  // Trim and capitalize name\n  @Mutate((value) =&gt; {\n    const name = value as string;\n    return name.trim()\n      .split(' ')\n      .map(word =&gt; word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n  })\n  declare name: string;\n\n  // Round age to integer\n  @Mutate((value) =&gt; Math.round(value as number))\n  @Validate((value) =&gt; (value as number) &gt;= 0 || \"Age must be positive\")\n  declare age: number;\n}\n</code></pre>"},{"location":"examples/validation/#usage_1","title":"Usage","text":"<pre><code>const user = await User.create({\n  name: \"  john DOE  \",\n  email: \"  JOHN@EXAMPLE.COM  \",\n  age: 25.7\n});\n\nconsole.log(user.name);  // \"John Doe\" (transformed)\nconsole.log(user.email); // \"john@example.com\" (transformed)\nconsole.log(user.age);   // 26 (rounded)\n</code></pre>"},{"location":"examples/validation/#custom-validators","title":"Custom Validators","text":"<p>Create reusable validation functions for common patterns:</p>"},{"location":"examples/validation/#email-validator","title":"Email Validator","text":"<pre><code>function validate_email(value: any): boolean | string {\n  const email = value as string;\n  const email_regex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}$/i;\n  return email_regex.test(email) || \"Invalid email format\";\n}\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Mutate((value) =&gt; (value as string).toLowerCase().trim())\n  @Validate(validate_email)\n  declare email: string;\n}\n</code></pre>"},{"location":"examples/validation/#password-strength-validator","title":"Password Strength Validator","text":"<pre><code>function validate_password_strength(value: any): boolean | string {\n  const password = value as string;\n\n  if (password.length &lt; 8) {\n    return \"Password must be at least 8 characters\";\n  }\n\n  if (!/[A-Z]/.test(password)) {\n    return \"Password must contain at least one uppercase letter\";\n  }\n\n  if (!/[a-z]/.test(password)) {\n    return \"Password must contain at least one lowercase letter\";\n  }\n\n  if (!/[0-9]/.test(password)) {\n    return \"Password must contain at least one number\";\n  }\n\n  if (!/[!@#$%^&amp;*]/.test(password)) {\n    return \"Password must contain at least one special character (!@#$%^&amp;*)\";\n  }\n\n  return true;\n}\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Validate(validate_password_strength)\n  declare password: string;\n}\n</code></pre>"},{"location":"examples/validation/#url-validator","title":"URL Validator","text":"<pre><code>function validate_url(value: any): boolean | string {\n  const url = value as string;\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return \"Invalid URL format\";\n  }\n}\n\nclass Profile extends Table&lt;Profile&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Validate(validate_url)\n  declare website: string;\n}\n</code></pre>"},{"location":"examples/validation/#phone-number-validator","title":"Phone Number Validator","text":"<pre><code>function validate_phone_number(value: any): boolean | string {\n  const phone = value as string;\n  const phone_regex = /^\\+?[1-9]\\d{1,14}$/;\n  return phone_regex.test(phone) || \"Invalid phone number format\";\n}\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Mutate((value) =&gt; (value as string).replace(/[\\s\\-\\(\\)]/g, ''))\n  @Validate(validate_phone_number)\n  declare phone: string;\n}\n</code></pre>"},{"location":"examples/validation/#chaining-validators","title":"Chaining Validators","text":"<p>You can apply multiple validators to a single field. Validators execute in order from top to bottom.</p>"},{"location":"examples/validation/#multiple-validation-rules","title":"Multiple Validation Rules","text":"<pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Multiple validators for name\n  @Validate((value) =&gt; (value as string).length &gt;= 2 || \"Name too short (min 2)\")\n  @Validate((value) =&gt; (value as string).length &lt;= 50 || \"Name too long (max 50)\")\n  @Validate((value) =&gt; /^[a-zA-Z\\s]+$/.test(value as string) || \"Name can only contain letters and spaces\")\n  declare name: string;\n\n  // Multiple validators for username\n  @Validate((value) =&gt; (value as string).length &gt;= 3 || \"Username too short (min 3)\")\n  @Validate((value) =&gt; (value as string).length &lt;= 20 || \"Username too long (max 20)\")\n  @Validate((value) =&gt; /^[a-z0-9_]+$/.test(value as string) || \"Username can only contain lowercase letters, numbers, and underscores\")\n  @Validate((value) =&gt; !/^\\d/.test(value as string) || \"Username cannot start with a number\")\n  declare username: string;\n}\n</code></pre>"},{"location":"examples/validation/#chaining-mutate-and-validate","title":"Chaining Mutate and Validate","text":"<pre><code>class Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Transform then validate\n  @Mutate((value) =&gt; (value as string).trim())\n  @Mutate((value) =&gt; (value as string).toLowerCase())\n  @Validate((value) =&gt; (value as string).length &gt;= 3 || \"Product name too short\")\n  @Validate((value) =&gt; (value as string).length &lt;= 100 || \"Product name too long\")\n  declare name: string;\n\n  // Round then validate price\n  @Mutate((value) =&gt; Math.round((value as number) * 100) / 100)\n  @Validate((value) =&gt; (value as number) &gt; 0 || \"Price must be positive\")\n  @Validate((value) =&gt; (value as number) &lt; 1000000 || \"Price too high\")\n  declare price: number;\n\n  // Transform quantity to integer then validate\n  @Mutate((value) =&gt; Math.floor(value as number))\n  @Validate((value) =&gt; (value as number) &gt;= 0 || \"Quantity cannot be negative\")\n  @Validate((value) =&gt; (value as number) &lt;= 10000 || \"Quantity exceeds maximum\")\n  declare quantity: number;\n}\n</code></pre>"},{"location":"examples/validation/#notnull-validation","title":"NotNull Validation","text":"<p>The <code>@NotNull()</code> decorator ensures a field cannot be <code>null</code> or <code>undefined</code>:</p> <pre><code>import { NotNull } from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare email: string;\n\n  @NotNull()\n  @Validate((value) =&gt; (value as string).length &gt;= 2 || \"Name required\")\n  declare name: string;\n\n  // Optional field (no @NotNull)\n  declare bio: string;\n}\n\n// Valid - all required fields provided\nconst user1 = await User.create({\n  id: \"user-1\",\n  email: \"john@example.com\",\n  name: \"John Doe\"\n  // bio is optional\n});\n\n// Invalid - missing required field\ntry {\n  await User.create({\n    id: \"user-2\",\n    name: \"Jane Doe\"\n    // email is required (@NotNull)\n  });\n} catch (error) {\n  console.error(error.message); // \"Field 'email' cannot be null\"\n}\n</code></pre>"},{"location":"examples/validation/#complex-validation-patterns","title":"Complex Validation Patterns","text":""},{"location":"examples/validation/#cross-field-validation","title":"Cross-Field Validation","text":"<p>Validate one field based on another field's value:</p> <pre><code>class Event extends Table&lt;Event&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n\n  @Validate((value) =&gt; {\n    const date = new Date(value as string);\n    return !isNaN(date.getTime()) || \"Invalid date format\";\n  })\n  declare start_date: string;\n\n  @Validate((value) =&gt; {\n    const date = new Date(value as string);\n    return !isNaN(date.getTime()) || \"Invalid date format\";\n  })\n  declare end_date: string;\n\n  // Validate in constructor that end_date is after start_date\n  constructor(data?: any) {\n    super(data);\n\n    if (data &amp;&amp; data.start_date &amp;&amp; data.end_date) {\n      const start = new Date(data.start_date);\n      const end = new Date(data.end_date);\n\n      if (end &lt;= start) {\n        throw new Error(\"End date must be after start date\");\n      }\n    }\n  }\n}\n\n// Valid event\nconst event1 = await Event.create({\n  name: \"Conference\",\n  start_date: \"2024-06-01\",\n  end_date: \"2024-06-03\"\n});\n\n// Invalid - end before start\ntry {\n  await Event.create({\n    name: \"Conference\",\n    start_date: \"2024-06-03\",\n    end_date: \"2024-06-01\"\n  });\n} catch (error) {\n  console.error(error.message); // \"End date must be after start date\"\n}\n</code></pre>"},{"location":"examples/validation/#conditional-validation","title":"Conditional Validation","text":"<p>Validate based on field values or application state:</p> <pre><code>class Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare user_id: string;\n\n  @Validate((value) =&gt; (value as number) &gt; 0 || \"Total must be positive\")\n  declare total: number;\n\n  @Default(() =&gt; \"pending\")\n  declare status: CreationOptional&lt;string&gt;;\n\n  // Validate tracking number only when status is 'shipped'\n  @Validate(function(value) {\n    const status = (this as any).status;\n    if (status === \"shipped\" &amp;&amp; !value) {\n      return \"Tracking number required when status is shipped\";\n    }\n    return true;\n  })\n  declare tracking_number: string | null;\n}\n</code></pre>"},{"location":"examples/validation/#enum-validation","title":"Enum Validation","text":"<p>Validate that a value is one of allowed options:</p> <pre><code>function validate_enum&lt;T&gt;(allowed_values: T[]) {\n  return (value: any): boolean | string =&gt; {\n    if (!allowed_values.includes(value as T)) {\n      return `Value must be one of: ${allowed_values.join(', ')}`;\n    }\n    return true;\n  };\n}\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Validate(validate_enum([\"customer\", \"premium\", \"admin\"]))\n  declare role: string;\n\n  @Validate(validate_enum([\"active\", \"inactive\", \"suspended\"]))\n  declare status: string;\n}\n\n// Valid\nconst user1 = await User.create({\n  id: \"user-1\",\n  role: \"customer\",\n  status: \"active\"\n});\n\n// Invalid role\ntry {\n  await User.create({\n    id: \"user-2\",\n    role: \"superadmin\",\n    status: \"active\"\n  });\n} catch (error) {\n  console.error(error.message);\n  // \"Value must be one of: customer, premium, admin\"\n}\n</code></pre>"},{"location":"examples/validation/#range-validation","title":"Range Validation","text":"<p>Create reusable range validators:</p> <pre><code>function validate_range(min: number, max: number, field_name: string = \"Value\") {\n  return (value: any): boolean | string =&gt; {\n    const num = value as number;\n    if (num &lt; min) return `${field_name} must be at least ${min}`;\n    if (num &gt; max) return `${field_name} must be at most ${max}`;\n    return true;\n  };\n}\n\nclass Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Validate(validate_range(0.01, 999999.99, \"Price\"))\n  declare price: number;\n\n  @Validate(validate_range(0, 10000, \"Quantity\"))\n  declare quantity: number;\n\n  @Validate(validate_range(1, 5, \"Rating\"))\n  declare rating: number;\n}\n</code></pre>"},{"location":"examples/validation/#complete-working-example","title":"Complete Working Example","text":"<p>Here's a complete example demonstrating all validation patterns:</p> <pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  Validate,\n  Mutate,\n  NotNull,\n  CreatedAt,\n  UpdatedAt,\n  CreationOptional,\n  Dynamite\n} from \"@arcaelas/dynamite\";\n\n// Configure DynamoDB\nDynamite.config({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  }\n});\n\n// Custom validators\nfunction validate_email(value: any): boolean | string {\n  const email = value as string;\n  const email_regex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}$/i;\n  return email_regex.test(email) || \"Invalid email format\";\n}\n\nfunction validate_phone(value: any): boolean | string {\n  const phone = value as string;\n  const phone_regex = /^\\+?[1-9]\\d{1,14}$/;\n  return phone_regex.test(phone) || \"Invalid phone number (use E.164 format)\";\n}\n\nfunction validate_password(value: any): boolean | string {\n  const password = value as string;\n\n  if (password.length &lt; 8) return \"Password must be at least 8 characters\";\n  if (!/[A-Z]/.test(password)) return \"Password must contain uppercase letter\";\n  if (!/[a-z]/.test(password)) return \"Password must contain lowercase letter\";\n  if (!/[0-9]/.test(password)) return \"Password must contain number\";\n  if (!/[!@#$%^&amp;*]/.test(password)) return \"Password must contain special character\";\n\n  return true;\n}\n\nfunction validate_range(min: number, max: number, name: string = \"Value\") {\n  return (value: any): boolean | string =&gt; {\n    const num = value as number;\n    if (num &lt; min) return `${name} must be at least ${min}`;\n    if (num &gt; max) return `${name} must be at most ${max}`;\n    return true;\n  };\n}\n\nfunction validate_enum&lt;T&gt;(values: T[]) {\n  return (value: any): boolean | string =&gt; {\n    if (!values.includes(value as T)) {\n      return `Must be one of: ${values.join(', ')}`;\n    }\n    return true;\n  };\n}\n\n// User model with comprehensive validation\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Name validation and transformation\n  @NotNull()\n  @Mutate((value) =&gt; (value as string).trim())\n  @Validate((value) =&gt; (value as string).length &gt;= 2 || \"Name too short (min 2)\")\n  @Validate((value) =&gt; (value as string).length &lt;= 50 || \"Name too long (max 50)\")\n  @Validate((value) =&gt; /^[a-zA-Z\\s]+$/.test(value as string) || \"Name: letters and spaces only\")\n  declare name: string;\n\n  // Email validation and transformation\n  @NotNull()\n  @Mutate((value) =&gt; (value as string).toLowerCase().trim())\n  @Validate(validate_email)\n  declare email: string;\n\n  // Password validation\n  @NotNull()\n  @Validate(validate_password)\n  declare password: string;\n\n  // Phone validation and transformation\n  @Mutate((value) =&gt; (value as string).replace(/[\\s\\-\\(\\)]/g, ''))\n  @Validate(validate_phone)\n  declare phone: string;\n\n  // Age validation\n  @Validate(validate_range(13, 120, \"Age\"))\n  declare age: number;\n\n  // Role validation with enum\n  @Default(() =&gt; \"customer\")\n  @Validate(validate_enum([\"customer\", \"premium\", \"admin\"]))\n  declare role: CreationOptional&lt;string&gt;;\n\n  // Status validation with enum\n  @Default(() =&gt; \"active\")\n  @Validate(validate_enum([\"active\", \"inactive\", \"suspended\"]))\n  declare status: CreationOptional&lt;string&gt;;\n\n  // Bio with length validation\n  @Default(() =&gt; \"\")\n  @Validate((value) =&gt; (value as string).length &lt;= 500 || \"Bio too long (max 500)\")\n  declare bio: CreationOptional&lt;string&gt;;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n}\n\n// Main application\nasync function main() {\n  console.log(\"=== Data Validation Example ===\\n\");\n\n  // 1. Valid user creation\n  console.log(\"1. Creating valid user...\");\n  try {\n    const user1 = await User.create({\n      name: \"John Doe\",\n      email: \"john@example.com\",\n      password: \"SecurePass123!\",\n      phone: \"+14155552671\",\n      age: 25\n    });\n    console.log(`\u2713 Created: ${user1.name} (${user1.email})`);\n    console.log(`  Phone: ${user1.phone}`);\n    console.log(`  Role: ${user1.role}\\n`);\n  } catch (error: any) {\n    console.error(`\u2717 Error: ${error.message}\\n`);\n  }\n\n  // 2. Invalid name (too short)\n  console.log(\"2. Testing invalid name (too short)...\");\n  try {\n    await User.create({\n      name: \"J\",\n      email: \"john@example.com\",\n      password: \"SecurePass123!\",\n      phone: \"+14155552671\",\n      age: 25\n    });\n    console.log(\"\u2713 User created\\n\");\n  } catch (error: any) {\n    console.error(`\u2717 Validation failed: ${error.message}\\n`);\n  }\n\n  // 3. Invalid email format\n  console.log(\"3. Testing invalid email format...\");\n  try {\n    await User.create({\n      name: \"Jane Smith\",\n      email: \"invalid-email\",\n      password: \"SecurePass123!\",\n      phone: \"+14155552671\",\n      age: 30\n    });\n    console.log(\"\u2713 User created\\n\");\n  } catch (error: any) {\n    console.error(`\u2717 Validation failed: ${error.message}\\n`);\n  }\n\n  // 4. Invalid password (no special character)\n  console.log(\"4. Testing weak password...\");\n  try {\n    await User.create({\n      name: \"Bob Johnson\",\n      email: \"bob@example.com\",\n      password: \"weakpass123\",\n      phone: \"+14155552671\",\n      age: 28\n    });\n    console.log(\"\u2713 User created\\n\");\n  } catch (error: any) {\n    console.error(`\u2717 Validation failed: ${error.message}\\n`);\n  }\n\n  // 5. Invalid phone number\n  console.log(\"5. Testing invalid phone number...\");\n  try {\n    await User.create({\n      name: \"Alice Williams\",\n      email: \"alice@example.com\",\n      password: \"SecurePass123!\",\n      phone: \"123\",\n      age: 22\n    });\n    console.log(\"\u2713 User created\\n\");\n  } catch (error: any) {\n    console.error(`\u2717 Validation failed: ${error.message}\\n`);\n  }\n\n  // 6. Invalid age (too young)\n  console.log(\"6. Testing invalid age (too young)...\");\n  try {\n    await User.create({\n      name: \"Charlie Brown\",\n      email: \"charlie@example.com\",\n      password: \"SecurePass123!\",\n      phone: \"+14155552671\",\n      age: 10\n    });\n    console.log(\"\u2713 User created\\n\");\n  } catch (error: any) {\n    console.error(`\u2717 Validation failed: ${error.message}\\n`);\n  }\n\n  // 7. Invalid role\n  console.log(\"7. Testing invalid role...\");\n  try {\n    await User.create({\n      name: \"David Lee\",\n      email: \"david@example.com\",\n      password: \"SecurePass123!\",\n      phone: \"+14155552671\",\n      age: 35,\n      role: \"superadmin\" as any\n    });\n    console.log(\"\u2713 User created\\n\");\n  } catch (error: any) {\n    console.error(`\u2717 Validation failed: ${error.message}\\n`);\n  }\n\n  // 8. Data transformation\n  console.log(\"8. Testing data transformation...\");\n  try {\n    const user2 = await User.create({\n      name: \"  emma WATSON  \",\n      email: \"  EMMA@EXAMPLE.COM  \",\n      password: \"SecurePass123!\",\n      phone: \"(415) 555-2671\",\n      age: 27\n    });\n    console.log(`\u2713 Created: ${user2.name}`);\n    console.log(`  Email (transformed): ${user2.email}`);\n    console.log(`  Phone (transformed): ${user2.phone}\\n`);\n  } catch (error: any) {\n    console.error(`\u2717 Error: ${error.message}\\n`);\n  }\n\n  // 9. Multiple validation errors\n  console.log(\"9. Testing multiple validation issues...\");\n  try {\n    await User.create({\n      name: \"A\",\n      email: \"bad-email\",\n      password: \"weak\",\n      phone: \"abc\",\n      age: 200\n    });\n    console.log(\"\u2713 User created\\n\");\n  } catch (error: any) {\n    console.error(`\u2717 First validation error: ${error.message}\\n`);\n  }\n\n  // 10. Valid user with all optional fields\n  console.log(\"10. Creating user with all optional fields...\");\n  try {\n    const user3 = await User.create({\n      name: \"Frank Miller\",\n      email: \"frank@example.com\",\n      password: \"SecurePass123!\",\n      phone: \"+14155552671\",\n      age: 40,\n      role: \"admin\",\n      status: \"active\",\n      bio: \"Experienced administrator with 10+ years in tech.\"\n    });\n    console.log(`\u2713 Created: ${user3.name}`);\n    console.log(`  Role: ${user3.role}`);\n    console.log(`  Status: ${user3.status}`);\n    console.log(`  Bio: ${user3.bio}\\n`);\n  } catch (error: any) {\n    console.error(`\u2717 Error: ${error.message}\\n`);\n  }\n\n  console.log(\"=== Validation tests completed ===\");\n}\n\n// Run the application\nmain().catch(console.error);\n</code></pre>"},{"location":"examples/validation/#expected-output","title":"Expected Output","text":"<pre><code>=== Data Validation Example ===\n\n1. Creating valid user...\n\u2713 Created: John Doe (john@example.com)\n  Phone: +14155552671\n  Role: customer\n\n2. Testing invalid name (too short)...\n\u2717 Validation failed: Name too short (min 2)\n\n3. Testing invalid email format...\n\u2717 Validation failed: Invalid email format\n\n4. Testing weak password...\n\u2717 Validation failed: Password must contain special character\n\n5. Testing invalid phone number...\n\u2717 Validation failed: Invalid phone number (use E.164 format)\n\n6. Testing invalid age (too young)...\n\u2717 Validation failed: Age must be at least 13\n\n7. Testing invalid role...\n\u2717 Validation failed: Must be one of: customer, premium, admin\n\n8. Testing data transformation...\n\u2713 Created: Emma Watson\n  Email (transformed): emma@example.com\n  Phone (transformed): +14155552671\n\n9. Testing multiple validation issues...\n\u2717 First validation error: Name too short (min 2)\n\n10. Creating user with all optional fields...\n\u2713 Created: Frank Miller\n  Role: admin\n  Status: active\n  Bio: Experienced administrator with 10+ years in tech.\n\n=== Validation tests completed ===\n</code></pre>"},{"location":"examples/validation/#best-practices","title":"Best Practices","text":""},{"location":"examples/validation/#1-validate-early-and-fail-fast","title":"1. Validate Early and Fail Fast","text":"<pre><code>// Good - validate immediately on creation\n@Validate((value) =&gt; (value as string).length &gt; 0 || \"Name required\")\ndeclare name: string;\n\n// Bad - validating in business logic later\nasync function create_user(name: string) {\n  if (name.length === 0) throw new Error(\"Name required\");\n  // ...\n}\n</code></pre>"},{"location":"examples/validation/#2-use-mutate-before-validate","title":"2. Use Mutate Before Validate","text":"<pre><code>// Good - transform then validate\n@Mutate((value) =&gt; (value as string).trim().toLowerCase())\n@Validate((value) =&gt; /^[a-z0-9]+$/.test(value as string) || \"Invalid format\")\ndeclare username: string;\n\n// Bad - validating before transformation\n@Validate((value) =&gt; /^[a-z0-9]+$/.test(value as string) || \"Invalid format\")\n@Mutate((value) =&gt; (value as string).trim().toLowerCase())\ndeclare username: string;\n</code></pre>"},{"location":"examples/validation/#3-create-reusable-validators","title":"3. Create Reusable Validators","text":"<pre><code>// Good - reusable validator\nconst validate_email = (value: any) =&gt;\n  /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value as string) || \"Invalid email\";\n\nclass User extends Table&lt;User&gt; {\n  @Validate(validate_email)\n  declare email: string;\n}\n\nclass Contact extends Table&lt;Contact&gt; {\n  @Validate(validate_email)\n  declare email: string;\n}\n\n// Bad - duplicating validation logic\nclass User extends Table&lt;User&gt; {\n  @Validate((value) =&gt; /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value as string) || \"Invalid email\")\n  declare email: string;\n}\n</code></pre>"},{"location":"examples/validation/#4-provide-clear-error-messages","title":"4. Provide Clear Error Messages","text":"<pre><code>// Good - specific error messages\n@Validate((value) =&gt; (value as string).length &gt;= 8 || \"Password must be at least 8 characters\")\n@Validate((value) =&gt; /[A-Z]/.test(value as string) || \"Password must contain uppercase letter\")\n@Validate((value) =&gt; /[0-9]/.test(value as string) || \"Password must contain number\")\ndeclare password: string;\n\n// Bad - vague error messages\n@Validate((value) =&gt; (value as string).length &gt;= 8 || \"Invalid password\")\n@Validate((value) =&gt; /[A-Z]/.test(value as string) || \"Invalid password\")\ndeclare password: string;\n</code></pre>"},{"location":"examples/validation/#5-use-notnull-for-required-fields","title":"5. Use NotNull for Required Fields","text":"<pre><code>// Good - explicitly mark required fields\n@NotNull()\n@Validate(validate_email)\ndeclare email: string;\n\n// Bad - implicit requirement through validation only\n@Validate((value) =&gt; value ? validate_email(value) : \"Email required\")\ndeclare email: string;\n</code></pre>"},{"location":"examples/validation/#common-validation-patterns","title":"Common Validation Patterns","text":""},{"location":"examples/validation/#credit-card-validation","title":"Credit Card Validation","text":"<pre><code>function validate_credit_card(value: any): boolean | string {\n  const card = (value as string).replace(/\\s/g, '');\n\n  if (!/^\\d{13,19}$/.test(card)) {\n    return \"Credit card must be 13-19 digits\";\n  }\n\n  // Luhn algorithm\n  let sum = 0;\n  let double = false;\n  for (let i = card.length - 1; i &gt;= 0; i--) {\n    let digit = parseInt(card[i]);\n    if (double) {\n      digit *= 2;\n      if (digit &gt; 9) digit -= 9;\n    }\n    sum += digit;\n    double = !double;\n  }\n\n  return sum % 10 === 0 || \"Invalid credit card number\";\n}\n\nclass Payment extends Table&lt;Payment&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Mutate((value) =&gt; (value as string).replace(/\\s/g, ''))\n  @Validate(validate_credit_card)\n  declare card_number: string;\n}\n</code></pre>"},{"location":"examples/validation/#username-validation","title":"Username Validation","text":"<pre><code>function validate_username(value: any): boolean | string {\n  const username = value as string;\n\n  if (username.length &lt; 3) return \"Username too short (min 3)\";\n  if (username.length &gt; 20) return \"Username too long (max 20)\";\n  if (!/^[a-z0-9_]+$/.test(username)) {\n    return \"Username: lowercase, numbers, underscore only\";\n  }\n  if (/^\\d/.test(username)) {\n    return \"Username cannot start with number\";\n  }\n  if (username.startsWith('_') || username.endsWith('_')) {\n    return \"Username cannot start/end with underscore\";\n  }\n\n  return true;\n}\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Mutate((value) =&gt; (value as string).toLowerCase().trim())\n  @Validate(validate_username)\n  declare username: string;\n}\n</code></pre>"},{"location":"examples/validation/#date-validation","title":"Date Validation","text":"<pre><code>function validate_future_date(value: any): boolean | string {\n  const date = new Date(value as string);\n  if (isNaN(date.getTime())) return \"Invalid date format\";\n  if (date &lt;= new Date()) return \"Date must be in the future\";\n  return true;\n}\n\nfunction validate_past_date(value: any): boolean | string {\n  const date = new Date(value as string);\n  if (isNaN(date.getTime())) return \"Invalid date format\";\n  if (date &gt;= new Date()) return \"Date must be in the past\";\n  return true;\n}\n\nclass Event extends Table&lt;Event&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Validate(validate_future_date)\n  declare event_date: string;\n}\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Validate(validate_past_date)\n  declare birth_date: string;\n}\n</code></pre>"},{"location":"examples/validation/#next-steps","title":"Next Steps","text":""},{"location":"examples/validation/#related-documentation","title":"Related Documentation","text":"<ul> <li>Basic Model Example - Simple CRUD operations</li> <li>Relationships Example - One-to-many and many-to-one relationships</li> <li>Advanced Queries Example - Complex queries and filtering</li> </ul>"},{"location":"examples/validation/#api-references","title":"API References","text":"<ul> <li>Decorators Guide - All available decorators</li> <li>Table API - Complete Table class documentation</li> <li>Best Practices - Development best practices</li> </ul>"},{"location":"examples/validation/#additional-topics","title":"Additional Topics","text":"<ul> <li>Custom Error Handling - Build custom validation error classes</li> <li>Async Validators - Validate against external APIs or databases</li> <li>Field Dependencies - Validate based on multiple field values</li> <li>Dynamic Validation - Change validation rules at runtime</li> </ul> <p>Happy validating with Dynamite!</p>"},{"location":"guides/best-practices/","title":"Best Practices Guide","text":"<p>This guide provides production-ready guidance for building scalable, maintainable applications with Dynamite ORM.</p>"},{"location":"guides/best-practices/#1-model-design","title":"1. Model Design","text":""},{"location":"guides/best-practices/#naming-conventions","title":"Naming Conventions","text":"<p>Use clear, descriptive names that reflect your domain:</p> <pre><code>// \u2705 Good - Clear entity names\n@Table({ name: 'users' })\nclass User extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  @Attribute()\n  email!: string;\n}\n\n@Table({ name: 'order_items' })\nclass OrderItem extends Model {\n  @PrimaryKey()\n  item_id!: string;\n}\n\n// \u274c Avoid - Generic or unclear names\n@Table({ name: 'data' })\nclass Data extends Model { }\n\n@Table({ name: 'temp' })\nclass Temp extends Model { }\n</code></pre>"},{"location":"guides/best-practices/#file-structure","title":"File Structure","text":"<p>Organize models by domain context:</p> <pre><code>src/\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 user/\n\u2502   \u2502   \u251c\u2500\u2500 user.model.ts\n\u2502   \u2502   \u251c\u2500\u2500 user_profile.model.ts\n\u2502   \u2502   \u2514\u2500\u2500 user_preferences.model.ts\n\u2502   \u251c\u2500\u2500 order/\n\u2502   \u2502   \u251c\u2500\u2500 order.model.ts\n\u2502   \u2502   \u251c\u2500\u2500 order_item.model.ts\n\u2502   \u2502   \u2514\u2500\u2500 order_history.model.ts\n\u2502   \u2514\u2500\u2500 index.ts\n</code></pre>"},{"location":"guides/best-practices/#model-organization","title":"Model Organization","text":"<p>Keep models focused and cohesive:</p> <pre><code>// \u2705 Good - Focused model with related attributes\n@Table({ name: 'products' })\nclass Product extends Model {\n  @PrimaryKey()\n  product_id!: string;\n\n  @Attribute()\n  name!: string;\n\n  @Attribute()\n  price!: number;\n\n  @Attribute()\n  category!: string;\n\n  @Attribute()\n  inventory_count!: number;\n\n  @Attribute()\n  created_at!: number;\n\n  @Attribute()\n  updated_at!: number;\n}\n\n// \u274c Avoid - Mixing unrelated concerns\n@Table({ name: 'products' })\nclass Product extends Model {\n  @PrimaryKey()\n  product_id!: string;\n\n  @Attribute()\n  name!: string;\n\n  // Don't embed full user data in product\n  @Attribute()\n  created_by_user!: {\n    user_id: string;\n    email: string;\n    full_name: string;\n    profile_image: string;\n  };\n}\n</code></pre>"},{"location":"guides/best-practices/#2-primary-key-strategy","title":"2. Primary Key Strategy","text":""},{"location":"guides/best-practices/#uuid-vs-sequential-ids","title":"UUID vs Sequential IDs","text":"<p>Use UUIDs for distributed systems:</p> <pre><code>import { v4 as uuid } from 'uuid';\n\n@Table({ name: 'users' })\nclass User extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  static async Create(data: CreateUserData): Promise&lt;User&gt; {\n    const user = new User();\n    user.user_id = uuid(); // Globally unique\n    user.email = data.email;\n    user.created_at = Date.now();\n    await user.Save();\n    return user;\n  }\n}\n\n// \u2705 Benefits: No coordination needed, globally unique\n// \u274c Drawback: Cannot sort by creation time\n</code></pre> <p>Use ULID for sortable IDs:</p> <pre><code>import { ulid } from 'ulid';\n\n@Table({ name: 'events' })\nclass Event extends Model {\n  @PrimaryKey()\n  event_id!: string; // ULID is lexicographically sortable\n\n  static async Create(data: CreateEventData): Promise&lt;Event&gt; {\n    const event = new Event();\n    event.event_id = ulid(); // Timestamp-based, sortable\n    event.type = data.type;\n    await event.Save();\n    return event;\n  }\n}\n\n// \u2705 Benefits: Sortable by time, globally unique\n// \u2705 Better for range queries\n</code></pre>"},{"location":"guides/best-practices/#composite-keys","title":"Composite Keys","text":"<p>Use composite keys for hierarchical data:</p> <pre><code>@Table({ name: 'comments' })\nclass Comment extends Model {\n  @PrimaryKey()\n  post_id!: string; // Partition key\n\n  @SortKey()\n  comment_id!: string; // Sort key\n\n  @Attribute()\n  user_id!: string;\n\n  @Attribute()\n  content!: string;\n\n  @Attribute()\n  created_at!: number;\n\n  // \u2705 Efficient: Get all comments for a post\n  static async GetByPost(post_id: string): Promise&lt;Comment[]&gt; {\n    return Comment.Query({ post_id });\n  }\n}\n\n// \u274c Avoid - Simple key when composite is better\n@Table({ name: 'comments' })\nclass Comment extends Model {\n  @PrimaryKey()\n  comment_id!: string; // Cannot efficiently query by post\n\n  @Attribute()\n  post_id!: string; // Would need a scan or GSI\n}\n</code></pre>"},{"location":"guides/best-practices/#3-index-strategy","title":"3. Index Strategy","text":""},{"location":"guides/best-practices/#global-secondary-indexes-gsi","title":"Global Secondary Indexes (GSI)","text":"<p>Create GSIs for alternative query patterns:</p> <pre><code>@Table({ name: 'orders' })\nclass Order extends Model {\n  @PrimaryKey()\n  order_id!: string;\n\n  @Attribute()\n  @Index({ name: 'user_orders_index', type: 'gsi' })\n  user_id!: string;\n\n  @Attribute()\n  @Index({ name: 'user_orders_index', type: 'gsi', sort_key: true })\n  created_at!: number;\n\n  @Attribute()\n  status!: 'pending' | 'completed' | 'cancelled';\n\n  // \u2705 Efficient query using GSI\n  static async GetUserOrders(user_id: string, limit = 20): Promise&lt;Order[]&gt; {\n    return Order.Query({\n      user_id,\n      index: 'user_orders_index',\n      limit,\n      scan_forward: false // Most recent first\n    });\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#local-secondary-indexes-lsi","title":"Local Secondary Indexes (LSI)","text":"<p>Use LSI for alternative sort keys with same partition key:</p> <pre><code>@Table({ name: 'products' })\nclass Product extends Model {\n  @PrimaryKey()\n  category!: string; // Partition key\n\n  @SortKey()\n  product_id!: string; // Default sort key\n\n  @Attribute()\n  @Index({ name: 'category_price_index', type: 'lsi', sort_key: true })\n  price!: number;\n\n  @Attribute()\n  name!: string;\n\n  // Query by category and sort by price\n  static async GetByPriceRange(\n    category: string,\n    min_price: number,\n    max_price: number\n  ): Promise&lt;Product[]&gt; {\n    return Product.Query({\n      category,\n      price: { between: [min_price, max_price] },\n      index: 'category_price_index'\n    });\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#avoiding-hot-partitions","title":"Avoiding Hot Partitions","text":"<p>Distribute writes across partitions:</p> <pre><code>// \u274c Avoid - Single hot partition\n@Table({ name: 'metrics' })\nclass Metric extends Model {\n  @PrimaryKey()\n  metric_type!: string; // Only a few values = hot partition\n\n  @SortKey()\n  timestamp!: number;\n}\n\n// \u2705 Good - Distributed writes\n@Table({ name: 'metrics' })\nclass Metric extends Model {\n  @PrimaryKey()\n  partition_key!: string; // metric_type#shard_0-99\n\n  @SortKey()\n  timestamp!: number;\n\n  static async Create(metric_type: string, data: MetricData): Promise&lt;Metric&gt; {\n    const metric = new Metric();\n    const shard = Math.floor(Math.random() * 100);\n    metric.partition_key = `${metric_type}#${shard}`;\n    metric.timestamp = Date.now();\n    metric.value = data.value;\n    await metric.Save();\n    return metric;\n  }\n\n  static async GetRecent(metric_type: string, minutes = 5): Promise&lt;Metric[]&gt; {\n    const since = Date.now() - (minutes * 60 * 1000);\n    const shards = Array.from({ length: 100 }, (_, i) =&gt; i);\n\n    // Query all shards in parallel\n    const results = await Promise.all(\n      shards.map(shard =&gt;\n        Metric.Query({\n          partition_key: `${metric_type}#${shard}`,\n          timestamp: { gte: since }\n        })\n      )\n    );\n\n    return results.flat().sort((a, b) =&gt; b.timestamp - a.timestamp);\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#4-query-optimization","title":"4. Query Optimization","text":""},{"location":"guides/best-practices/#efficient-queries","title":"Efficient Queries","text":"<p>Use Query instead of Scan whenever possible:</p> <pre><code>// \u2705 Efficient - Query with partition key\nconst user_orders = await Order.Query({ user_id: 'user_123' });\n\n// \u2705 Efficient - Query with range condition\nconst recent_orders = await Order.Query({\n  user_id: 'user_123',\n  created_at: { gte: Date.now() - 86400000 } // Last 24 hours\n});\n\n// \u274c Slow - Scan entire table\nconst pending_orders = await Order.Scan({ status: 'pending' });\n\n// \u2705 Better - GSI for status queries\n@Table({ name: 'orders' })\nclass Order extends Model {\n  @Attribute()\n  @Index({ name: 'status_index', type: 'gsi' })\n  status!: string;\n}\n\nconst pending_orders = await Order.Query({\n  status: 'pending',\n  index: 'status_index'\n});\n</code></pre>"},{"location":"guides/best-practices/#pagination","title":"Pagination","text":"<p>Implement efficient pagination:</p> <pre><code>interface PaginatedResponse&lt;T&gt; {\n  items: T[];\n  next_token?: string;\n  has_more: boolean;\n}\n\nclass Order extends Model {\n  static async GetUserOrdersPaginated(\n    user_id: string,\n    limit = 20,\n    next_token?: string\n  ): Promise&lt;PaginatedResponse&lt;Order&gt;&gt; {\n    const result = await Order.Query({\n      user_id,\n      limit,\n      exclusive_start_key: next_token ? JSON.parse(\n        Buffer.from(next_token, 'base64').toString()\n      ) : undefined\n    });\n\n    return {\n      items: result,\n      next_token: result.last_evaluated_key ? Buffer.from(\n        JSON.stringify(result.last_evaluated_key)\n      ).toString('base64') : undefined,\n      has_more: !!result.last_evaluated_key\n    };\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#projection","title":"Projection","text":"<p>Fetch only needed attributes:</p> <pre><code>// \u2705 Efficient - Fetch only needed fields\nconst users = await User.Query({\n  status: 'active',\n  index: 'status_index',\n  projection: ['user_id', 'email', 'name']\n});\n\n// \u274c Wasteful - Fetching unnecessary data\nconst users = await User.Query({\n  status: 'active',\n  index: 'status_index'\n  // Fetches all attributes including large profile_data\n});\n</code></pre>"},{"location":"guides/best-practices/#5-data-modeling","title":"5. Data Modeling","text":""},{"location":"guides/best-practices/#single-table-design","title":"Single-Table Design","text":"<p>Model related entities in one table:</p> <pre><code>// Single table for related entities\n@Table({ name: 'app_data' })\nclass Entity extends Model {\n  @PrimaryKey()\n  pk!: string;\n\n  @SortKey()\n  sk!: string;\n\n  @Attribute()\n  entity_type!: string;\n\n  @Attribute()\n  @Index({ name: 'gsi1', type: 'gsi' })\n  gsi1_pk?: string;\n\n  @Attribute()\n  @Index({ name: 'gsi1', type: 'gsi', sort_key: true })\n  gsi1_sk?: string;\n}\n\n// User entity\nclass User extends Entity {\n  static async Create(user_id: string, data: UserData): Promise&lt;User&gt; {\n    const user = new User();\n    user.pk = `USER#${user_id}`;\n    user.sk = `METADATA`;\n    user.entity_type = 'user';\n    user.email = data.email;\n    user.gsi1_pk = `EMAIL#${data.email}`;\n    user.gsi1_sk = `USER#${user_id}`;\n    await user.Save();\n    return user;\n  }\n\n  static async FindByEmail(email: string): Promise&lt;User | null&gt; {\n    const results = await Entity.Query({\n      gsi1_pk: `EMAIL#${email}`,\n      index: 'gsi1',\n      limit: 1\n    });\n    return results[0] as User || null;\n  }\n}\n\n// Order entity\nclass Order extends Entity {\n  static async Create(user_id: string, order_data: OrderData): Promise&lt;Order&gt; {\n    const order_id = ulid();\n    const order = new Order();\n    order.pk = `USER#${user_id}`;\n    order.sk = `ORDER#${order_id}`;\n    order.entity_type = 'order';\n    order.gsi1_pk = `ORDER#${order_id}`;\n    order.gsi1_sk = `METADATA`;\n    Object.assign(order, order_data);\n    await order.Save();\n    return order;\n  }\n\n  static async GetUserOrders(user_id: string): Promise&lt;Order[]&gt; {\n    return Entity.Query({\n      pk: `USER#${user_id}`,\n      sk: { begins_with: 'ORDER#' }\n    }) as Promise&lt;Order[]&gt;;\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#denormalization","title":"Denormalization","text":"<p>Duplicate data for read performance:</p> <pre><code>// \u2705 Good - Denormalize for read efficiency\n@Table({ name: 'orders' })\nclass Order extends Model {\n  @PrimaryKey()\n  order_id!: string;\n\n  @Attribute()\n  user_id!: string;\n\n  // Denormalized user data\n  @Attribute()\n  user_email!: string;\n\n  @Attribute()\n  user_name!: string;\n\n  @Attribute()\n  items!: Array&lt;{\n    product_id: string;\n    product_name: string; // Denormalized\n    price: number; // Snapshot at order time\n    quantity: number;\n  }&gt;;\n\n  // \u2705 Single read to get all order display data\n  static async GetOrderSummary(order_id: string): Promise&lt;Order&gt; {\n    return Order.FindByPk(order_id);\n  }\n}\n\n// \u274c Avoid - Normalized requiring multiple queries\n@Table({ name: 'orders' })\nclass Order extends Model {\n  @PrimaryKey()\n  order_id!: string;\n\n  @Attribute()\n  user_id!: string; // Need separate query for user data\n\n  @Attribute()\n  item_ids!: string[]; // Need separate queries for each item\n}\n</code></pre>"},{"location":"guides/best-practices/#6-validation-strategy","title":"6. Validation Strategy","text":""},{"location":"guides/best-practices/#model-level-validation","title":"Model-Level Validation","text":"<p>Implement validation in model methods:</p> <pre><code>@Table({ name: 'users' })\nclass User extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  @Attribute()\n  email!: string;\n\n  @Attribute()\n  age?: number;\n\n  private static ValidateEmail(email: string): void {\n    const email_regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!email_regex.test(email)) {\n      throw new Error('Invalid email format');\n    }\n  }\n\n  private static ValidateAge(age?: number): void {\n    if (age !== undefined &amp;&amp; (age &lt; 0 || age &gt; 150)) {\n      throw new Error('Age must be between 0 and 150');\n    }\n  }\n\n  static async Create(data: CreateUserData): Promise&lt;User&gt; {\n    // Validate before saving\n    this.ValidateEmail(data.email);\n    this.ValidateAge(data.age);\n\n    const user = new User();\n    user.user_id = uuid();\n    user.email = data.email;\n    user.age = data.age;\n    user.created_at = Date.now();\n\n    await user.Save();\n    return user;\n  }\n\n  async Update(updates: Partial&lt;CreateUserData&gt;): Promise&lt;void&gt; {\n    if (updates.email) {\n      User.ValidateEmail(updates.email);\n      this.email = updates.email;\n    }\n\n    if (updates.age !== undefined) {\n      User.ValidateAge(updates.age);\n      this.age = updates.age;\n    }\n\n    this.updated_at = Date.now();\n    await this.Save();\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#custom-validators","title":"Custom Validators","text":"<p>Create reusable validation functions:</p> <pre><code>// validators.ts\nexport class Validators {\n  static Email(value: string): boolean {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\n  }\n\n  static PhoneNumber(value: string): boolean {\n    return /^\\+?[1-9]\\d{1,14}$/.test(value);\n  }\n\n  static URL(value: string): boolean {\n    try {\n      new URL(value);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  static Range(value: number, min: number, max: number): boolean {\n    return value &gt;= min &amp;&amp; value &lt;= max;\n  }\n\n  static StringLength(value: string, min: number, max: number): boolean {\n    return value.length &gt;= min &amp;&amp; value.length &lt;= max;\n  }\n}\n\n// Usage\n@Table({ name: 'profiles' })\nclass Profile extends Model {\n  @PrimaryKey()\n  profile_id!: string;\n\n  @Attribute()\n  website?: string;\n\n  @Attribute()\n  bio?: string;\n\n  static async Create(data: CreateProfileData): Promise&lt;Profile&gt; {\n    if (data.website &amp;&amp; !Validators.URL(data.website)) {\n      throw new Error('Invalid website URL');\n    }\n\n    if (data.bio &amp;&amp; !Validators.StringLength(data.bio, 0, 500)) {\n      throw new Error('Bio must be 500 characters or less');\n    }\n\n    const profile = new Profile();\n    profile.profile_id = uuid();\n    Object.assign(profile, data);\n    await profile.Save();\n    return profile;\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#7-error-handling","title":"7. Error Handling","text":""},{"location":"guides/best-practices/#try-catch-patterns","title":"Try-Catch Patterns","text":"<p>Handle errors gracefully:</p> <pre><code>class User extends Model {\n  // \u2705 Good - Specific error handling\n  static async FindByEmail(email: string): Promise&lt;User | null&gt; {\n    try {\n      const results = await User.Query({\n        email,\n        index: 'email_index',\n        limit: 1\n      });\n      return results[0] || null;\n    } catch (error) {\n      if (error instanceof ConditionalCheckFailedException) {\n        // Expected condition failure\n        return null;\n      }\n\n      if (error instanceof ProvisionedThroughputExceededException) {\n        // Retry with exponential backoff\n        await this.Delay(1000);\n        return this.FindByEmail(email);\n      }\n\n      // Log unexpected errors\n      console.error('Error finding user by email:', error);\n      throw new Error('Failed to find user');\n    }\n  }\n\n  // \u2705 Good - Graceful degradation\n  static async GetUserWithOrders(user_id: string): Promise&lt;UserWithOrders&gt; {\n    try {\n      const [user, orders] = await Promise.all([\n        User.FindByPk(user_id),\n        Order.Query({ user_id })\n      ]);\n\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      return {\n        ...user,\n        orders: orders || [] // Fallback to empty array if orders fail\n      };\n    } catch (error) {\n      // Log but don't expose internal details\n      console.error('Error fetching user with orders:', error);\n      throw new Error('Unable to retrieve user data');\n    }\n  }\n\n  private static async Delay(ms: number): Promise&lt;void&gt; {\n    return new Promise(resolve =&gt; setTimeout(resolve, ms));\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#transaction-error-handling","title":"Transaction Error Handling","text":"<p>Handle transaction failures:</p> <pre><code>class TransferService {\n  static async TransferBalance(\n    from_user_id: string,\n    to_user_id: string,\n    amount: number\n  ): Promise&lt;void&gt; {\n    const max_retries = 3;\n    let attempt = 0;\n\n    while (attempt &lt; max_retries) {\n      try {\n        const from_user = await User.FindByPk(from_user_id);\n        const to_user = await User.FindByPk(to_user_id);\n\n        if (!from_user || !to_user) {\n          throw new Error('User not found');\n        }\n\n        if (from_user.balance &lt; amount) {\n          throw new Error('Insufficient balance');\n        }\n\n        // Update balances\n        from_user.balance -= amount;\n        to_user.balance += amount;\n\n        // Save both (implement transaction in your ORM)\n        await Promise.all([\n          from_user.Save(),\n          to_user.Save()\n        ]);\n\n        return; // Success\n      } catch (error) {\n        attempt++;\n\n        if (error instanceof ConditionalCheckFailedException &amp;&amp; attempt &lt; max_retries) {\n          // Optimistic locking failure - retry\n          await this.Delay(100 * Math.pow(2, attempt));\n          continue;\n        }\n\n        // Other errors or max retries exceeded\n        throw error;\n      }\n    }\n\n    throw new Error('Transaction failed after maximum retries');\n  }\n\n  private static async Delay(ms: number): Promise&lt;void&gt; {\n    return new Promise(resolve =&gt; setTimeout(resolve, ms));\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#8-testing","title":"8. Testing","text":""},{"location":"guides/best-practices/#unit-tests","title":"Unit Tests","text":"<p>Test model logic in isolation:</p> <pre><code>// user.test.ts\nimport { describe, it, expect, beforeEach, afterEach } from '@jest/globals';\nimport { User } from './user.model';\n\ndescribe('User Model', () =&gt; {\n  beforeEach(async () =&gt; {\n    // Setup test data\n  });\n\n  afterEach(async () =&gt; {\n    // Cleanup\n  });\n\n  describe('Create', () =&gt; {\n    it('should create user with valid data', async () =&gt; {\n      const user = await User.Create({\n        email: 'test@example.com',\n        name: 'Test User'\n      });\n\n      expect(user.user_id).toBeDefined();\n      expect(user.email).toBe('test@example.com');\n      expect(user.name).toBe('Test User');\n      expect(user.created_at).toBeGreaterThan(0);\n    });\n\n    it('should throw error with invalid email', async () =&gt; {\n      await expect(\n        User.Create({\n          email: 'invalid-email',\n          name: 'Test User'\n        })\n      ).rejects.toThrow('Invalid email format');\n    });\n\n    it('should throw error with duplicate email', async () =&gt; {\n      await User.Create({\n        email: 'test@example.com',\n        name: 'User 1'\n      });\n\n      await expect(\n        User.Create({\n          email: 'test@example.com',\n          name: 'User 2'\n        })\n      ).rejects.toThrow('Email already exists');\n    });\n  });\n\n  describe('FindByEmail', () =&gt; {\n    it('should find user by email', async () =&gt; {\n      const created_user = await User.Create({\n        email: 'find@example.com',\n        name: 'Find Me'\n      });\n\n      const found_user = await User.FindByEmail('find@example.com');\n\n      expect(found_user).toBeDefined();\n      expect(found_user?.user_id).toBe(created_user.user_id);\n      expect(found_user?.email).toBe('find@example.com');\n    });\n\n    it('should return null for non-existent email', async () =&gt; {\n      const user = await User.FindByEmail('nonexistent@example.com');\n      expect(user).toBeNull();\n    });\n  });\n\n  describe('Update', () =&gt; {\n    it('should update user attributes', async () =&gt; {\n      const user = await User.Create({\n        email: 'update@example.com',\n        name: 'Original Name'\n      });\n\n      await user.Update({ name: 'Updated Name' });\n\n      const updated_user = await User.FindByPk(user.user_id);\n      expect(updated_user?.name).toBe('Updated Name');\n      expect(updated_user?.email).toBe('update@example.com');\n    });\n  });\n});\n</code></pre>"},{"location":"guides/best-practices/#integration-tests-with-dynamodb-local","title":"Integration Tests with DynamoDB Local","text":"<p>Test against local DynamoDB:</p> <pre><code>// test-setup.ts\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport { spawn, ChildProcess } from 'child_process';\n\nexport class DynamoDBLocal {\n  private process?: ChildProcess;\n\n  async Start(): Promise&lt;void&gt; {\n    return new Promise((resolve, reject) =&gt; {\n      this.process = spawn('java', [\n        '-Djava.library.path=./DynamoDBLocal_lib',\n        '-jar',\n        'DynamoDBLocal.jar',\n        '-inMemory',\n        '-port',\n        '8000'\n      ]);\n\n      this.process.stdout?.on('data', (data) =&gt; {\n        if (data.toString().includes('Started')) {\n          resolve();\n        }\n      });\n\n      this.process.on('error', reject);\n\n      setTimeout(() =&gt; resolve(), 2000);\n    });\n  }\n\n  async Stop(): Promise&lt;void&gt; {\n    if (this.process) {\n      this.process.kill();\n    }\n  }\n}\n\n// integration.test.ts\nimport { describe, it, expect, beforeAll, afterAll } from '@jest/globals';\nimport { DynamoDBLocal } from './test-setup';\nimport { Dynamite } from 'dynamite-orm';\n\nconst dynamodb_local = new DynamoDBLocal();\n\nbeforeAll(async () =&gt; {\n  await dynamodb_local.Start();\n\n  // Configure Dynamite to use local endpoint\n  Dynamite.Configure({\n    region: 'local',\n    endpoint: 'http://localhost:8000',\n    credentials: {\n      accessKeyId: 'fake',\n      secretAccessKey: 'fake'\n    }\n  });\n\n  // Create tables\n  await User.CreateTable();\n  await Order.CreateTable();\n}, 30000);\n\nafterAll(async () =&gt; {\n  await dynamodb_local.Stop();\n});\n\ndescribe('Integration Tests', () =&gt; {\n  it('should perform complex query operations', async () =&gt; {\n    const user = await User.Create({\n      email: 'integration@example.com',\n      name: 'Integration Test'\n    });\n\n    const orders = await Promise.all([\n      Order.Create({ user_id: user.user_id, total: 100 }),\n      Order.Create({ user_id: user.user_id, total: 200 }),\n      Order.Create({ user_id: user.user_id, total: 300 })\n    ]);\n\n    const user_orders = await Order.Query({ user_id: user.user_id });\n\n    expect(user_orders).toHaveLength(3);\n    expect(user_orders.map(o =&gt; o.total).sort()).toEqual([100, 200, 300]);\n  });\n});\n</code></pre>"},{"location":"guides/best-practices/#9-type-safety","title":"9. Type Safety","text":""},{"location":"guides/best-practices/#leveraging-typescript","title":"Leveraging TypeScript","text":"<p>Use TypeScript features for type safety:</p> <pre><code>// Define strict types\ninterface CreateUserData {\n  email: string;\n  name: string;\n  age?: number;\n}\n\ninterface UpdateUserData {\n  name?: string;\n  age?: number;\n}\n\n// Use branded types for IDs\ntype UserId = string &amp; { readonly brand: unique symbol };\ntype OrderId = string &amp; { readonly brand: unique symbol };\n\n@Table({ name: 'users' })\nclass User extends Model {\n  @PrimaryKey()\n  user_id!: UserId;\n\n  @Attribute()\n  email!: string;\n\n  @Attribute()\n  name!: string;\n\n  @Attribute()\n  age?: number;\n\n  // Type-safe creation\n  static async Create(data: CreateUserData): Promise&lt;User&gt; {\n    const user = new User();\n    user.user_id = uuid() as UserId;\n    user.email = data.email;\n    user.name = data.name;\n    user.age = data.age;\n    await user.Save();\n    return user;\n  }\n\n  // Type-safe updates\n  async Update(data: UpdateUserData): Promise&lt;void&gt; {\n    if (data.name !== undefined) this.name = data.name;\n    if (data.age !== undefined) this.age = data.age;\n    await this.Save();\n  }\n}\n\n// Use discriminated unions for polymorphic data\ntype Event =\n  | { type: 'user_created'; user_id: UserId; email: string }\n  | { type: 'order_placed'; order_id: OrderId; total: number }\n  | { type: 'payment_completed'; order_id: OrderId; amount: number };\n\n@Table({ name: 'events' })\nclass EventLog extends Model {\n  @PrimaryKey()\n  event_id!: string;\n\n  @Attribute()\n  event_data!: Event;\n\n  @Attribute()\n  created_at!: number;\n\n  static async Log(event: Event): Promise&lt;EventLog&gt; {\n    const log = new EventLog();\n    log.event_id = ulid();\n    log.event_data = event;\n    log.created_at = Date.now();\n    await log.Save();\n    return log;\n  }\n\n  // Type-safe event processing\n  static ProcessEvent(event: Event): void {\n    switch (event.type) {\n      case 'user_created':\n        console.log(`User created: ${event.email}`);\n        break;\n      case 'order_placed':\n        console.log(`Order placed: ${event.total}`);\n        break;\n      case 'payment_completed':\n        console.log(`Payment completed: ${event.amount}`);\n        break;\n    }\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#10-security","title":"10. Security","text":""},{"location":"guides/best-practices/#iam-policies","title":"IAM Policies","text":"<p>Implement least privilege access:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"dynamodb:GetItem\",\n        \"dynamodb:Query\"\n      ],\n      \"Resource\": [\n        \"arn:aws:dynamodb:region:account:table/users\",\n        \"arn:aws:dynamodb:region:account:table/users/index/*\"\n      ]\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"dynamodb:PutItem\",\n        \"dynamodb:UpdateItem\"\n      ],\n      \"Resource\": \"arn:aws:dynamodb:region:account:table/orders\",\n      \"Condition\": {\n        \"ForAllValues:StringEquals\": {\n          \"dynamodb:LeadingKeys\": [\"${aws:userid}\"]\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/best-practices/#data-encryption","title":"Data Encryption","text":"<p>Encrypt sensitive data:</p> <pre><code>import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';\n\nclass EncryptionService {\n  private readonly algorithm = 'aes-256-gcm';\n  private readonly key: Buffer;\n\n  constructor(encryption_key: string) {\n    this.key = Buffer.from(encryption_key, 'hex');\n  }\n\n  Encrypt(plaintext: string): string {\n    const iv = randomBytes(16);\n    const cipher = createCipheriv(this.algorithm, this.key, iv);\n\n    let encrypted = cipher.update(plaintext, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n\n    const auth_tag = cipher.getAuthTag();\n\n    return `${iv.toString('hex')}:${auth_tag.toString('hex')}:${encrypted}`;\n  }\n\n  Decrypt(ciphertext: string): string {\n    const [iv_hex, auth_tag_hex, encrypted] = ciphertext.split(':');\n    const iv = Buffer.from(iv_hex, 'hex');\n    const auth_tag = Buffer.from(auth_tag_hex, 'hex');\n\n    const decipher = createDecipheriv(this.algorithm, this.key, iv);\n    decipher.setAuthTag(auth_tag);\n\n    let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n\n    return decrypted;\n  }\n}\n\n// Usage\n@Table({ name: 'users' })\nclass User extends Model {\n  private static encryption = new EncryptionService(process.env.ENCRYPTION_KEY!);\n\n  @PrimaryKey()\n  user_id!: string;\n\n  @Attribute()\n  email!: string;\n\n  @Attribute()\n  encrypted_ssn?: string;\n\n  SetSSN(ssn: string): void {\n    this.encrypted_ssn = User.encryption.Encrypt(ssn);\n  }\n\n  GetSSN(): string | undefined {\n    return this.encrypted_ssn\n      ? User.encryption.Decrypt(this.encrypted_ssn)\n      : undefined;\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#input-sanitization","title":"Input Sanitization","text":"<p>Sanitize user input:</p> <pre><code>class Sanitizer {\n  static String(value: string, max_length = 1000): string {\n    return value\n      .trim()\n      .slice(0, max_length)\n      .replace(/[&lt;&gt;]/g, ''); // Remove potential HTML tags\n  }\n\n  static Number(value: unknown): number {\n    const num = Number(value);\n    if (isNaN(num) || !isFinite(num)) {\n      throw new Error('Invalid number');\n    }\n    return num;\n  }\n\n  static Boolean(value: unknown): boolean {\n    return value === true || value === 'true' || value === 1;\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#11-performance","title":"11. Performance","text":""},{"location":"guides/best-practices/#batch-operations","title":"Batch Operations","text":"<p>Use batch operations for multiple items:</p> <pre><code>class User extends Model {\n  // \u2705 Good - Batch get\n  static async GetMultiple(user_ids: string[]): Promise&lt;User[]&gt; {\n    return User.BatchGet(user_ids.map(id =&gt; ({ user_id: id })));\n  }\n\n  // \u2705 Good - Batch write\n  static async CreateMultiple(users_data: CreateUserData[]): Promise&lt;User[]&gt; {\n    const users = users_data.map(data =&gt; {\n      const user = new User();\n      user.user_id = uuid();\n      Object.assign(user, data);\n      return user;\n    });\n\n    await User.BatchWrite(users);\n    return users;\n  }\n\n  // \u274c Avoid - Multiple individual requests\n  static async GetMultipleSlow(user_ids: string[]): Promise&lt;User[]&gt; {\n    return Promise.all(user_ids.map(id =&gt; User.FindByPk(id)));\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#connection-pooling","title":"Connection Pooling","text":"<p>Reuse DynamoDB client instances:</p> <pre><code>// \u2705 Good - Single client instance\nclass DatabaseConfig {\n  private static client?: DynamoDBClient;\n\n  static GetClient(): DynamoDBClient {\n    if (!this.client) {\n      this.client = new DynamoDBClient({\n        region: process.env.AWS_REGION,\n        maxAttempts: 3,\n        requestHandler: {\n          connectionTimeout: 3000,\n          socketTimeout: 3000\n        }\n      });\n    }\n    return this.client;\n  }\n}\n\n// \u274c Avoid - Creating new client each time\nasync function QueryUsers(): Promise&lt;User[]&gt; {\n  const client = new DynamoDBClient({ region: 'us-east-1' });\n  // ... use client\n}\n</code></pre>"},{"location":"guides/best-practices/#12-migrations","title":"12. Migrations","text":""},{"location":"guides/best-practices/#schema-changes","title":"Schema Changes","text":"<p>Handle backward-compatible changes:</p> <pre><code>// Version 1: Original schema\n@Table({ name: 'users' })\nclass User extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  @Attribute()\n  name!: string;\n}\n\n// Version 2: Add optional field (backward compatible)\n@Table({ name: 'users' })\nclass User extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  @Attribute()\n  name!: string;\n\n  @Attribute()\n  email?: string; // Optional - existing records work\n}\n\n// Version 3: Split name field (requires migration)\n@Table({ name: 'users' })\nclass User extends Model {\n  @PrimaryKey()\n  user_id!: string;\n\n  @Attribute()\n  first_name!: string;\n\n  @Attribute()\n  last_name!: string;\n\n  @Attribute()\n  email?: string;\n\n  // Support old format during migration\n  @Attribute()\n  name?: string; // Deprecated\n\n  get full_name(): string {\n    if (this.first_name &amp;&amp; this.last_name) {\n      return `${this.first_name} ${this.last_name}`;\n    }\n    return this.name || '';\n  }\n}\n\n// Migration script\nasync function MigrateUserNames(): Promise&lt;void&gt; {\n  let last_key: any = undefined;\n\n  do {\n    const result = await User.Scan({\n      filter: { name: { exists: true } },\n      limit: 25,\n      exclusive_start_key: last_key\n    });\n\n    for (const user of result) {\n      if (user.name &amp;&amp; !user.first_name) {\n        const [first_name, ...rest] = user.name.split(' ');\n        user.first_name = first_name;\n        user.last_name = rest.join(' ');\n        delete user.name;\n        await user.Save();\n      }\n    }\n\n    last_key = result.last_evaluated_key;\n  } while (last_key);\n}\n</code></pre>"},{"location":"guides/best-practices/#13-monitoring","title":"13. Monitoring","text":""},{"location":"guides/best-practices/#cloudwatch-metrics","title":"CloudWatch Metrics","text":"<p>Monitor key metrics:</p> <pre><code>import { CloudWatchClient, PutMetricDataCommand } from '@aws-sdk/client-cloudwatch';\n\nclass MetricsService {\n  private cloudwatch: CloudWatchClient;\n\n  constructor() {\n    this.cloudwatch = new CloudWatchClient({ region: process.env.AWS_REGION });\n  }\n\n  async RecordQueryDuration(table_name: string, duration_ms: number): Promise&lt;void&gt; {\n    await this.cloudwatch.send(new PutMetricDataCommand({\n      Namespace: 'DynamiteORM',\n      MetricData: [{\n        MetricName: 'QueryDuration',\n        Value: duration_ms,\n        Unit: 'Milliseconds',\n        Dimensions: [{\n          Name: 'TableName',\n          Value: table_name\n        }],\n        Timestamp: new Date()\n      }]\n    }));\n  }\n\n  async RecordError(table_name: string, error_type: string): Promise&lt;void&gt; {\n    await this.cloudwatch.send(new PutMetricDataCommand({\n      Namespace: 'DynamiteORM',\n      MetricData: [{\n        MetricName: 'Errors',\n        Value: 1,\n        Unit: 'Count',\n        Dimensions: [\n          { Name: 'TableName', Value: table_name },\n          { Name: 'ErrorType', Value: error_type }\n        ],\n        Timestamp: new Date()\n      }]\n    }));\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#logging","title":"Logging","text":"<p>Implement structured logging:</p> <pre><code>class Logger {\n  static Info(message: string, metadata?: Record&lt;string, any&gt;): void {\n    console.log(JSON.stringify({\n      level: 'info',\n      message,\n      timestamp: new Date().toISOString(),\n      ...metadata\n    }));\n  }\n\n  static Error(message: string, error: Error, metadata?: Record&lt;string, any&gt;): void {\n    console.error(JSON.stringify({\n      level: 'error',\n      message,\n      error: {\n        name: error.name,\n        message: error.message,\n        stack: error.stack\n      },\n      timestamp: new Date().toISOString(),\n      ...metadata\n    }));\n  }\n\n  static Query(table: string, operation: string, duration_ms: number): void {\n    this.Info('DynamoDB Query', {\n      table,\n      operation,\n      duration_ms\n    });\n  }\n}\n\n// Usage\nclass User extends Model {\n  static async FindByPk(user_id: string): Promise&lt;User | null&gt; {\n    const start = Date.now();\n\n    try {\n      const user = await super.FindByPk(user_id);\n      const duration = Date.now() - start;\n\n      Logger.Query('users', 'GetItem', duration);\n\n      return user;\n    } catch (error) {\n      Logger.Error('Failed to find user', error as Error, { user_id });\n      throw error;\n    }\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#14-code-organization","title":"14. Code Organization","text":""},{"location":"guides/best-practices/#repository-pattern","title":"Repository Pattern","text":"<p>Separate data access logic:</p> <pre><code>// repositories/user.repository.ts\nexport class UserRepository {\n  async FindById(user_id: string): Promise&lt;User | null&gt; {\n    return User.FindByPk(user_id);\n  }\n\n  async FindByEmail(email: string): Promise&lt;User | null&gt; {\n    const results = await User.Query({\n      email,\n      index: 'email_index',\n      limit: 1\n    });\n    return results[0] || null;\n  }\n\n  async Create(data: CreateUserData): Promise&lt;User&gt; {\n    const user = new User();\n    user.user_id = uuid();\n    Object.assign(user, data);\n    user.created_at = Date.now();\n    await user.Save();\n    return user;\n  }\n\n  async Update(user_id: string, updates: UpdateUserData): Promise&lt;User&gt; {\n    const user = await this.FindById(user_id);\n    if (!user) throw new Error('User not found');\n\n    Object.assign(user, updates);\n    user.updated_at = Date.now();\n    await user.Save();\n    return user;\n  }\n\n  async Delete(user_id: string): Promise&lt;void&gt; {\n    const user = await this.FindById(user_id);\n    if (user) await user.Delete();\n  }\n}\n\n// services/user.service.ts\nexport class UserService {\n  constructor(private user_repo: UserRepository) {}\n\n  async RegisterUser(data: CreateUserData): Promise&lt;User&gt; {\n    const existing = await this.user_repo.FindByEmail(data.email);\n    if (existing) throw new Error('Email already exists');\n\n    return this.user_repo.Create(data);\n  }\n\n  async GetUserProfile(user_id: string): Promise&lt;UserProfile&gt; {\n    const user = await this.user_repo.FindById(user_id);\n    if (!user) throw new Error('User not found');\n\n    return {\n      user_id: user.user_id,\n      email: user.email,\n      name: user.name,\n      created_at: user.created_at\n    };\n  }\n}\n\n// controllers/user.controller.ts\nexport class UserController {\n  constructor(private user_service: UserService) {}\n\n  async Register(req: Request, res: Response): Promise&lt;void&gt; {\n    try {\n      const user = await this.user_service.RegisterUser(req.body);\n      res.status(201).json({ user_id: user.user_id });\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  }\n}\n</code></pre>"},{"location":"guides/best-practices/#separating-concerns","title":"Separating Concerns","text":"<p>Organize by feature:</p> <pre><code>src/\n\u251c\u2500\u2500 models/\n\u2502   \u2514\u2500\u2500 user.model.ts\n\u251c\u2500\u2500 repositories/\n\u2502   \u2514\u2500\u2500 user.repository.ts\n\u251c\u2500\u2500 services/\n\u2502   \u2514\u2500\u2500 user.service.ts\n\u251c\u2500\u2500 controllers/\n\u2502   \u2514\u2500\u2500 user.controller.ts\n\u251c\u2500\u2500 validators/\n\u2502   \u2514\u2500\u2500 user.validators.ts\n\u2514\u2500\u2500 types/\n    \u2514\u2500\u2500 user.types.ts\n</code></pre>"},{"location":"guides/best-practices/#summary","title":"Summary","text":"<p>Following these best practices will help you build scalable, maintainable applications with Dynamite ORM:</p> <ol> <li>Model Design: Use clear naming, organize by domain, keep models focused</li> <li>Primary Keys: Choose appropriate ID strategy (UUID, ULID, composite)</li> <li>Indexes: Create GSI/LSI for query patterns, avoid hot partitions</li> <li>Queries: Prefer Query over Scan, implement pagination, use projections</li> <li>Data Modeling: Apply single-table design, denormalize for reads</li> <li>Validation: Validate at model level, create reusable validators</li> <li>Error Handling: Handle errors gracefully, implement retries</li> <li>Testing: Write unit and integration tests</li> <li>Type Safety: Leverage TypeScript features</li> <li>Security: Apply least privilege, encrypt sensitive data</li> <li>Performance: Use batch operations, reuse connections</li> <li>Migrations: Handle schema changes carefully</li> <li>Monitoring: Track metrics and logs</li> <li>Organization: Separate concerns with repository pattern</li> </ol>"},{"location":"guides/core-concepts/","title":"Core Concepts","text":"<p>This guide explains the fundamental concepts of Dynamite ORM and how they work together to provide a powerful, type-safe interface for DynamoDB.</p>"},{"location":"guides/core-concepts/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Table Class</li> <li>Decorators Overview</li> <li>Primary Keys</li> <li>Indexes</li> <li>Query Builder</li> <li>Query Operators</li> <li>Type System</li> <li>Data Flow</li> </ol>"},{"location":"guides/core-concepts/#table-class","title":"Table Class","text":"<p>The <code>Table</code> class is the base class for all your DynamoDB models. It provides both static methods for database operations and instance methods for working with individual records.</p>"},{"location":"guides/core-concepts/#static-vs-instance-methods","title":"Static vs Instance Methods","text":"<p>Static methods operate on the database directly:</p> <pre><code>// Static methods - work with the database\nconst user = await User.create({ name: \"John\" });\nconst users = await User.where({ active: true });\nconst count = await User.update({ status: \"active\" }, { role: \"admin\" });\nawait User.delete({ id: \"user-123\" });\n</code></pre> <p>Instance methods work with individual model instances:</p> <pre><code>// Instance methods - work with the model instance\nconst user = new User({ name: \"John\" });\nawait user.save();           // Save to database\n\nuser.name = \"Jane\";\nawait user.update({ name: \"Jane\" }); // Update fields\n\nawait user.destroy();        // Delete from database\n</code></pre>"},{"location":"guides/core-concepts/#basic-usage","title":"Basic Usage","text":"<pre><code>import { Table, PrimaryKey, Default, CreationOptional } from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare email: string;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n}\n\n// Create\nconst user = await User.create({\n  name: \"John Doe\",\n  email: \"john@example.com\"\n  // id and active are optional (CreationOptional)\n});\n\n// Read\nconst allUsers = await User.where({});\nconst activeUsers = await User.where({ active: true });\n\n// Update\nuser.name = \"Jane Doe\";\nawait user.save();\n\n// Delete\nawait user.destroy();\n</code></pre>"},{"location":"guides/core-concepts/#decorators-overview","title":"Decorators Overview","text":"<p>Decorators are special functions that annotate class properties with metadata. Dynamite uses decorators to define table structure, validation rules, and relationships.</p>"},{"location":"guides/core-concepts/#core-decorators","title":"Core Decorators","text":"Decorator Purpose Example <code>@PrimaryKey()</code> Defines the partition key <code>@PrimaryKey() declare id: string;</code> <code>@Index()</code> Alias for PrimaryKey <code>@Index() declare userId: string;</code> <code>@IndexSort()</code> Defines the sort key <code>@IndexSort() declare timestamp: string;</code> <code>@Name(\"custom\")</code> Custom column/table name <code>@Name(\"user_email\") declare email: string;</code>"},{"location":"guides/core-concepts/#data-decorators","title":"Data Decorators","text":"Decorator Purpose Example <code>@Default(value)</code> Default value <code>@Default(() =&gt; Date.now()) declare createdAt: number;</code> <code>@Mutate(fn)</code> Transform before save <code>@Mutate(v =&gt; v.toLowerCase()) declare email: string;</code> <code>@Validate(fn)</code> Validate before save <code>@Validate(v =&gt; v.length &gt; 0) declare name: string;</code> <code>@NotNull()</code> Require non-null value <code>@NotNull() declare email: string;</code>"},{"location":"guides/core-concepts/#timestamp-decorators","title":"Timestamp Decorators","text":"Decorator Purpose Example <code>@CreatedAt()</code> Auto-set on creation <code>@CreatedAt() declare createdAt: string;</code> <code>@UpdatedAt()</code> Auto-set on update <code>@UpdatedAt() declare updatedAt: string;</code>"},{"location":"guides/core-concepts/#relationship-decorators","title":"Relationship Decorators","text":"Decorator Purpose Example <code>@HasMany(Model, fk)</code> One-to-many <code>@HasMany(() =&gt; Order, \"userId\") declare orders: any;</code> <code>@BelongsTo(Model, lk)</code> Many-to-one <code>@BelongsTo(() =&gt; User, \"userId\") declare user: any;</code>"},{"location":"guides/core-concepts/#complete-example","title":"Complete Example","text":"<pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  Mutate,\n  Validate,\n  NotNull,\n  CreatedAt,\n  UpdatedAt,\n  HasMany,\n  CreationOptional,\n  NonAttribute\n} from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  @Mutate(v =&gt; v.trim())\n  @Mutate(v =&gt; v.toLowerCase())\n  @Validate(v =&gt; /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v) || \"Invalid email\")\n  declare email: string;\n\n  @Validate(v =&gt; v.length &gt;= 2 || \"Name too short\")\n  @Validate(v =&gt; v.length &lt;= 50 || \"Name too long\")\n  declare name: string;\n\n  @Default(() =&gt; 18)\n  @Validate(v =&gt; v &gt;= 0 || \"Age must be positive\")\n  declare age: CreationOptional&lt;number&gt;;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n\n  @HasMany(() =&gt; Order, \"userId\")\n  declare orders: NonAttribute&lt;Order[]&gt;;\n}\n</code></pre>"},{"location":"guides/core-concepts/#primary-keys","title":"Primary Keys","text":"<p>Primary keys in DynamoDB consist of a partition key (required) and optionally a sort key. Dynamite uses the <code>@PrimaryKey</code> decorator to define the partition key.</p>"},{"location":"guides/core-concepts/#simple-primary-key","title":"Simple Primary Key","text":"<pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare name: string;\n}\n\n// Query by primary key\nconst user = await User.first({ id: \"user-123\" });\n</code></pre>"},{"location":"guides/core-concepts/#composite-primary-key-partition-sort-key","title":"Composite Primary Key (Partition + Sort Key)","text":"<pre><code>class Order extends Table&lt;Order&gt; {\n  @PrimaryKey()        // Partition key\n  declare userId: string;\n\n  @IndexSort()         // Sort key\n  declare timestamp: string;\n\n  declare total: number;\n  declare status: string;\n}\n\n// Query by partition key\nconst userOrders = await Order.where({ userId: \"user-123\" });\n\n// Query by partition + sort key\nconst recentOrders = await Order.where({\n  userId: \"user-123\",\n  timestamp: \"2023-12-01\"\n});\n</code></pre>"},{"location":"guides/core-concepts/#auto-generated-primary-keys","title":"Auto-Generated Primary Keys","text":"<pre><code>class Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare price: number;\n}\n\n// id is automatically generated\nconst product = await Product.create({\n  name: \"Widget\",\n  price: 9.99\n});\n\nconsole.log(product.id); // \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre>"},{"location":"guides/core-concepts/#indexes","title":"Indexes","text":"<p>DynamoDB supports Global Secondary Indexes (GSI) and Local Secondary Indexes (LSI) for efficient querying. Dynamite provides <code>@Index</code> and <code>@IndexSort</code> decorators.</p>"},{"location":"guides/core-concepts/#global-secondary-index-gsi","title":"Global Secondary Index (GSI)","text":"<pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Index()             // GSI partition key\n  declare email: string;\n\n  declare name: string;\n  declare role: string;\n}\n\n// Query by email (GSI)\nconst user = await User.first({ email: \"john@example.com\" });\n</code></pre>"},{"location":"guides/core-concepts/#local-secondary-index-lsi","title":"Local Secondary Index (LSI)","text":"<pre><code>class Message extends Table&lt;Message&gt; {\n  @PrimaryKey()        // Partition key\n  declare chatId: string;\n\n  @IndexSort()         // Sort key (LSI)\n  declare timestamp: string;\n\n  declare userId: string;\n  declare content: string;\n}\n\n// Query chat messages sorted by timestamp\nconst messages = await Message.where(\n  { chatId: \"chat-123\" },\n  { order: \"DESC\", limit: 50 }\n);\n</code></pre>"},{"location":"guides/core-concepts/#multiple-indexes","title":"Multiple Indexes","text":"<pre><code>class Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Index()             // GSI on category\n  declare category: string;\n\n  @IndexSort()         // Sort by price\n  declare price: number;\n\n  declare name: string;\n  declare stock: number;\n}\n\n// Query products by category, sorted by price\nconst electronics = await Product.where(\n  { category: \"electronics\" },\n  { order: \"ASC\", limit: 10 }\n);\n</code></pre>"},{"location":"guides/core-concepts/#query-builder","title":"Query Builder","text":"<p>The query builder provides a fluent interface for constructing database queries. The main method is <code>where()</code>, which has multiple overloads for different use cases.</p>"},{"location":"guides/core-concepts/#basic-queries","title":"Basic Queries","text":"<pre><code>// Get all records\nconst allUsers = await User.where({});\n\n// Filter by field (equality)\nconst activeUsers = await User.where({ active: true });\n\n// Multiple filters (AND condition)\nconst premiumUsers = await User.where({\n  active: true,\n  role: \"premium\"\n});\n</code></pre>"},{"location":"guides/core-concepts/#field-value-queries","title":"Field-Value Queries","text":"<pre><code>// Single field query\nconst adults = await User.where(\"age\", 18);\n\n// Array of values (IN operator)\nconst specificAges = await User.where(\"age\", [25, 30, 35]);\n</code></pre>"},{"location":"guides/core-concepts/#query-options","title":"Query Options","text":"<pre><code>// Pagination\nconst users = await User.where({}, {\n  limit: 10,\n  skip: 20\n});\n\n// Sorting\nconst users = await User.where({}, {\n  order: \"DESC\"\n});\n\n// Select specific fields\nconst users = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\"]\n});\n\n// Combined options\nconst users = await User.where(\n  { active: true },\n  {\n    attributes: [\"id\", \"name\"],\n    limit: 50,\n    order: \"ASC\"\n  }\n);\n</code></pre>"},{"location":"guides/core-concepts/#first-and-last","title":"First and Last","text":"<pre><code>// Get first matching record\nconst firstUser = await User.first({ active: true });\n\n// Get last matching record\nconst lastUser = await User.last({ active: true });\n\n// First with options\nconst newestUser = await User.first({}, { order: \"DESC\" });\n\n// Last with options\nconst oldestUser = await User.last({}, { order: \"ASC\" });\n</code></pre>"},{"location":"guides/core-concepts/#including-relationships","title":"Including Relationships","text":"<pre><code>// Load with related data\nconst usersWithOrders = await User.where({}, {\n  include: {\n    orders: {}\n  }\n});\n\n// Nested relationships\nconst usersWithOrderItems = await User.where({}, {\n  include: {\n    orders: {\n      include: {\n        items: {}\n      }\n    }\n  }\n});\n\n// Filtered relationships\nconst usersWithActiveOrders = await User.where({}, {\n  include: {\n    orders: {\n      where: { status: \"active\" },\n      limit: 5\n    }\n  }\n});\n</code></pre>"},{"location":"guides/core-concepts/#query-operators","title":"Query Operators","text":"<p>Query operators allow you to perform advanced filtering beyond simple equality checks.</p>"},{"location":"guides/core-concepts/#comparison-operators","title":"Comparison Operators","text":"<pre><code>// Equal (default)\nconst users = await User.where(\"age\", \"=\", 25);\nconst users = await User.where(\"age\", 25); // Same as above\n\n// Not equal\nconst nonAdmins = await User.where(\"role\", \"!=\", \"admin\");\n\n// Less than\nconst minors = await User.where(\"age\", \"&lt;\", 18);\n\n// Less than or equal\nconst seniors = await User.where(\"age\", \"&lt;=\", 65);\n\n// Greater than\nconst highScores = await User.where(\"score\", \"&gt;\", 100);\n\n// Greater than or equal\nconst adults = await User.where(\"age\", \"&gt;=\", 18);\n</code></pre>"},{"location":"guides/core-concepts/#array-operators","title":"Array Operators","text":"<pre><code>// IN - value in array\nconst specificRoles = await User.where(\"role\", \"in\", [\"admin\", \"premium\", \"vip\"]);\n\n// NOT IN - value not in array\nconst regularUsers = await User.where(\"role\", \"not-in\", [\"admin\", \"moderator\"]);\n</code></pre>"},{"location":"guides/core-concepts/#string-operators","title":"String Operators","text":"<pre><code>// CONTAINS - string contains substring\nconst gmailUsers = await User.where(\"email\", \"contains\", \"gmail\");\n\n// BEGINS WITH - string starts with prefix\nconst johnUsers = await User.where(\"name\", \"begins-with\", \"John\");\n</code></pre>"},{"location":"guides/core-concepts/#complete-examples","title":"Complete Examples","text":"<pre><code>// Complex query with operators\nconst premiumActiveUsers = await User.where(\n  { role: \"premium\", active: true },\n  { limit: 100, order: \"DESC\" }\n);\n\n// Range query\nconst youngAdults = await User.where(\"age\", \"&gt;=\", 18)\n  .then(users =&gt; users.filter(u =&gt; u.age &lt; 30));\n\n// Pattern matching\nconst testEmails = await User.where(\"email\", \"contains\", \"@test.com\");\n\n// Multiple conditions\nconst results = await User.where({\n  active: true,\n  role: \"customer\"\n});\n\nconst filteredResults = results.filter(user =&gt;\n  user.age &gt;= 18 &amp;&amp; user.age &lt;= 65\n);\n</code></pre>"},{"location":"guides/core-concepts/#type-system","title":"Type System","text":"<p>Dynamite's type system ensures type safety throughout your application. It provides special types for optional fields, computed properties, and relationships.</p>"},{"location":"guides/core-concepts/#creationoptional","title":"CreationOptional","text":"<p>Marks fields as optional during creation but required in instances. Always use for auto-generated fields.</p> <pre><code>import { Table, PrimaryKey, Default, CreatedAt, UpdatedAt, CreationOptional } from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  // Auto-generated ID - always CreationOptional\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Required fields\n  declare name: string;\n  declare email: string;\n\n  // Default value - always CreationOptional\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  // Auto-set timestamps - always CreationOptional\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n}\n\n// TypeScript knows what's required\nconst user = await User.create({\n  name: \"John\",\n  email: \"john@test.com\"\n  // id, role, createdAt, updatedAt are optional\n});\n\n// But all fields exist after creation\nconsole.log(user.id);        // string (not undefined)\nconsole.log(user.role);      // \"customer\"\nconsole.log(user.createdAt); // \"2023-12-01T10:30:00.000Z\"\n</code></pre>"},{"location":"guides/core-concepts/#nonattribute","title":"NonAttribute","text":"<p>Excludes fields from database operations. Used for computed properties and virtual fields.</p> <pre><code>import { Table, PrimaryKey, NonAttribute } from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare firstName: string;\n  declare lastName: string;\n  declare birthDate: string;\n\n  // Computed properties (not stored in database)\n  declare fullName: NonAttribute&lt;string&gt;;\n  declare age: NonAttribute&lt;number&gt;;\n\n  constructor(data?: any) {\n    super(data);\n\n    // Define computed properties\n    Object.defineProperty(this, 'fullName', {\n      get: () =&gt; `${this.firstName} ${this.lastName}`,\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'age', {\n      get: () =&gt; {\n        const today = new Date();\n        const birth = new Date(this.birthDate);\n        return today.getFullYear() - birth.getFullYear();\n      },\n      enumerable: true\n    });\n  }\n}\n\nconst user = await User.create({\n  id: \"user-1\",\n  firstName: \"John\",\n  lastName: \"Doe\",\n  birthDate: \"1990-01-01\"\n});\n\nconsole.log(user.fullName); // \"John Doe\" (computed, not stored)\nconsole.log(user.age);      // 34 (computed, not stored)\n</code></pre>"},{"location":"guides/core-concepts/#inferattributes","title":"InferAttributes","text":"<p>Utility type that extracts all database-persisted attributes, excluding functions, relationships, and non-attributes.</p> <pre><code>import { Table, InferAttributes } from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  declare id: string;\n  declare name: string;\n  declare email: string;\n}\n\n// Extract actual attributes\ntype UserAttrs = InferAttributes&lt;User&gt;;\n// Result: { id: string; name: string; email: string; }\n\n// Use in function parameters\nasync function updateUser(\n  id: string,\n  updates: Partial&lt;InferAttributes&lt;User&gt;&gt;\n): Promise&lt;User&gt; {\n  return await User.update(updates, { id });\n}\n</code></pre>"},{"location":"guides/core-concepts/#relationship-types","title":"Relationship Types","text":"<pre><code>import {\n  Table,\n  PrimaryKey,\n  HasMany,\n  BelongsTo,\n  NonAttribute\n} from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare name: string;\n\n  // One-to-many relationship\n  @HasMany(() =&gt; Order, \"userId\")\n  declare orders: NonAttribute&lt;Order[]&gt;;\n}\n\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare userId: string;\n  declare total: number;\n\n  // Many-to-one relationship\n  @BelongsTo(() =&gt; User, \"userId\")\n  declare user: NonAttribute&lt;User | null&gt;;\n}\n\n// Load with relationships\nconst users = await User.where({}, {\n  include: { orders: {} }\n});\n\n// TypeScript knows the types\nusers[0].orders.forEach(order =&gt; {\n  console.log(order.total); // number\n});\n</code></pre>"},{"location":"guides/core-concepts/#complete-type-example","title":"Complete Type Example","text":"<pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  HasMany,\n  CreationOptional,\n  NonAttribute,\n  InferAttributes\n} from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  // Auto-generated (CreationOptional)\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Required\n  declare firstName: string;\n  declare lastName: string;\n  declare email: string;\n\n  // Default value (CreationOptional)\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  // Auto-set timestamps (CreationOptional)\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n\n  // Computed (NonAttribute)\n  declare fullName: NonAttribute&lt;string&gt;;\n\n  // Relationship (NonAttribute)\n  @HasMany(() =&gt; Order, \"userId\")\n  declare orders: NonAttribute&lt;Order[]&gt;;\n\n  constructor(data?: any) {\n    super(data);\n\n    Object.defineProperty(this, 'fullName', {\n      get: () =&gt; `${this.firstName} ${this.lastName}`,\n      enumerable: true\n    });\n  }\n}\n\n// Type inference in action\ntype Creation = {\n  firstName: string;    // Required\n  lastName: string;     // Required\n  email: string;        // Required\n  id?: string;          // Optional (CreationOptional)\n  role?: string;        // Optional (CreationOptional)\n  createdAt?: string;   // Optional (CreationOptional)\n  updatedAt?: string;   // Optional (CreationOptional)\n  // fullName not included (NonAttribute)\n  // orders not included (NonAttribute)\n};\n\ntype Instance = {\n  id: string;           // Required after creation\n  firstName: string;\n  lastName: string;\n  email: string;\n  role: string;         // Required after creation\n  createdAt: string;    // Required after creation\n  updatedAt: string;    // Required after creation\n  fullName: string;     // Available but not stored\n  orders: Order[];      // Available when included\n};\n</code></pre>"},{"location":"guides/core-concepts/#data-flow","title":"Data Flow","text":"<p>Understanding how data flows through Dynamite helps you use it effectively. Here's a comprehensive diagram:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                          DATA FLOW DIAGRAM                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n1. MODEL DEFINITION\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 class User extends Table&lt;User&gt; {                       \u2502\n   \u2502   @PrimaryKey() @Default(() =&gt; uuid())                 \u2502\n   \u2502   declare id: CreationOptional&lt;string&gt;;                \u2502\n   \u2502                                                         \u2502\n   \u2502   @Mutate(v =&gt; v.toLowerCase())                        \u2502\n   \u2502   @Validate(v =&gt; isEmail(v))                           \u2502\n   \u2502   declare email: string;                               \u2502\n   \u2502 }                                                       \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n2. DECORATOR REGISTRATION (at class definition time)\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 Metadata Store (WRAPPER)                               \u2502\n   \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n   \u2502 \u2502 User: {                                          \u2502   \u2502\n   \u2502 \u2502   name: \"User\",                                  \u2502   \u2502\n   \u2502 \u2502   columns: Map {                                 \u2502   \u2502\n   \u2502 \u2502     \"id\" =&gt; {                                    \u2502   \u2502\n   \u2502 \u2502       primaryKey: true,                          \u2502   \u2502\n   \u2502 \u2502       default: () =&gt; uuid()                      \u2502   \u2502\n   \u2502 \u2502     },                                           \u2502   \u2502\n   \u2502 \u2502     \"email\" =&gt; {                                 \u2502   \u2502\n   \u2502 \u2502       mutate: [v =&gt; v.toLowerCase()],            \u2502   \u2502\n   \u2502 \u2502       validate: [v =&gt; isEmail(v)]                \u2502   \u2502\n   \u2502 \u2502     }                                            \u2502   \u2502\n   \u2502 \u2502   }                                              \u2502   \u2502\n   \u2502 \u2502 }                                                \u2502   \u2502\n   \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n3. CREATE OPERATION\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 await User.create({                                    \u2502\n   \u2502   email: \"JOHN@EXAMPLE.COM\"                            \u2502\n   \u2502 })                                                     \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n4. CONSTRUCTOR PROCESSING\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 new User(data)                                         \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 Apply @Default decorators                              \u2502\n   \u2502   id = uuid() \u2192 \"550e8400-...\"                         \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 Apply @Mutate decorators                               \u2502\n   \u2502   email = \"john@example.com\" (lowercased)              \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 Apply @Validate decorators                             \u2502\n   \u2502   email passes isEmail() check \u2713                       \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 Apply @CreatedAt / @UpdatedAt                          \u2502\n   \u2502   createdAt = \"2023-12-01T10:30:00.000Z\"               \u2502\n   \u2502   updatedAt = \"2023-12-01T10:30:00.000Z\"               \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n5. SERIALIZATION\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 instance.toJSON()                                      \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 Extract attributes (exclude NonAttribute fields)       \u2502\n   \u2502   {                                                    \u2502\n   \u2502     id: \"550e8400-...\",                                \u2502\n   \u2502     email: \"john@example.com\",                         \u2502\n   \u2502     createdAt: \"2023-12-01T10:30:00.000Z\",             \u2502\n   \u2502     updatedAt: \"2023-12-01T10:30:00.000Z\"              \u2502\n   \u2502   }                                                    \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n6. PERSISTENCE\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 DynamoDB PutItem                                       \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 marshall(data) \u2192 DynamoDB format                       \u2502\n   \u2502   {                                                    \u2502\n   \u2502     id: { S: \"550e8400-...\" },                         \u2502\n   \u2502     email: { S: \"john@example.com\" },                  \u2502\n   \u2502     createdAt: { S: \"2023-12-01T10:30:00.000Z\" },      \u2502\n   \u2502     updatedAt: { S: \"2023-12-01T10:30:00.000Z\" }       \u2502\n   \u2502   }                                                    \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nQUERY FLOW\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 await User.where({ email: \"john@example.com\" })        \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 Build DynamoDB Query                                   \u2502\n   \u2502   FilterExpression: \"#email = :email\"                  \u2502\n   \u2502   ExpressionAttributeNames: { \"#email\": \"email\" }      \u2502\n   \u2502   ExpressionAttributeValues: { \":email\": \"john...\" }   \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 DynamoDB Scan/Query                                    \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 Retrieve items from database                           \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 Deserialization                                        \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 unmarshall(items) \u2192 Plain objects                      \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 new User(data) for each item                           \u2502\n   \u2502   \u2193                                                    \u2502\n   \u2502 Apply computed properties (NonAttribute)               \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 Return User[] with full type safety                    \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nRELATIONSHIP LOADING\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 await User.where({}, { include: { orders: {} } })      \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2193\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 1. Load users from User table                          \u2502\n   \u2502 2. For each user:                                      \u2502\n   \u2502    - Extract userId                                    \u2502\n   \u2502    - Query Order.where({ userId })                     \u2502\n   \u2502    - Attach orders to user.orders                      \u2502\n   \u2502 3. Return users with orders populated                  \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"guides/core-concepts/#key-points","title":"Key Points","text":"<ol> <li>Decorator Registration: Happens once at class definition time</li> <li>Default Values: Applied in constructor before validation</li> <li>Mutations: Applied before validation, transforms data</li> <li>Validation: Runs after mutations, can throw errors</li> <li>Timestamps: Auto-set on create/update operations</li> <li>Serialization: Excludes NonAttribute fields before persistence</li> <li>Relationships: Loaded lazily through separate queries</li> <li>Type Safety: Maintained throughout entire flow</li> </ol>"},{"location":"guides/core-concepts/#summary","title":"Summary","text":"<p>This guide covered the core concepts of Dynamite:</p> <ul> <li>Table Class: Base class with static and instance methods</li> <li>Decorators: Metadata annotations for structure and behavior</li> <li>Primary Keys: Partition and sort keys using @PrimaryKey and @IndexSort</li> <li>Indexes: GSI and LSI for efficient querying</li> <li>Query Builder: Fluent interface with where(), first(), last()</li> <li>Query Operators: =, !=, &lt;, &gt;, &lt;=, &gt;=, in, not-in, contains, begins-with</li> <li>Type System: CreationOptional, NonAttribute, InferAttributes for type safety</li> <li>Data Flow: How data moves through decorators to the database</li> </ul> <p>For more advanced topics, see: - Relationships Guide - Advanced Queries - API Reference</p>"},{"location":"guides/decorators/","title":"Gu\u00eda Completa de Decoradores en Dynamite","text":"<p>Esta gu\u00eda proporciona documentaci\u00f3n exhaustiva sobre todos los decoradores disponibles en Dynamite ORM, incluyendo ejemplos pr\u00e1cticos, patrones comunes y mejores pr\u00e1cticas.</p>"},{"location":"guides/decorators/#tabla-de-contenidos","title":"Tabla de Contenidos","text":"<ol> <li>Introducci\u00f3n a los Decoradores</li> <li>@PrimaryKey - Claves Primarias</li> <li>@Index - Configuraci\u00f3n de GSI</li> <li>@IndexSort - Configuraci\u00f3n de LSI</li> <li>@Default - Valores por Defecto</li> <li>@Validate - Funciones de Validaci\u00f3n</li> <li>@Mutate - Transformaci\u00f3n de Datos</li> <li>@NotNull - Campos Requeridos</li> <li>@CreatedAt - Timestamp de Creaci\u00f3n</li> <li>@UpdatedAt - Timestamp de Actualizaci\u00f3n</li> <li>@Name - Nombres Personalizados</li> <li>@HasMany - Relaciones Uno a Muchos</li> <li>@BelongsTo - Relaciones Muchos a Uno</li> <li>Combinando M\u00faltiples Decoradores</li> <li>Patrones de Decoradores Personalizados</li> <li>Mejores Pr\u00e1cticas</li> </ol>"},{"location":"guides/decorators/#introduccion-a-los-decoradores","title":"Introducci\u00f3n a los Decoradores","text":"<p>Los decoradores en Dynamite son funciones especiales que a\u00f1aden metadatos y comportamiento a las clases y propiedades. Permiten definir esquemas de base de datos de manera declarativa y type-safe.</p>"},{"location":"guides/decorators/#conceptos-basicos","title":"Conceptos B\u00e1sicos","text":"<pre><code>import { Table, PrimaryKey, Default, CreationOptional } from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  // Decorador de clave primaria\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Campo simple sin decoradores\n  declare name: string;\n\n  // Campo con valor por defecto\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n}\n</code></pre>"},{"location":"guides/decorators/#tipos-de-decoradores","title":"Tipos de Decoradores","text":"<p>Decoradores de Clave: - <code>@PrimaryKey()</code> - Define la clave primaria - <code>@Index()</code> - Define partition key (GSI) - <code>@IndexSort()</code> - Define sort key (LSI)</p> <p>Decoradores de Datos: - <code>@Default()</code> - Establece valores por defecto - <code>@Mutate()</code> - Transforma valores antes de guardar - <code>@Validate()</code> - Valida valores antes de guardar - <code>@NotNull()</code> - Marca campos como requeridos</p> <p>Decoradores de Timestamp: - <code>@CreatedAt()</code> - Auto-timestamp en creaci\u00f3n - <code>@UpdatedAt()</code> - Auto-timestamp en actualizaci\u00f3n</p> <p>Decoradores de Relaciones: - <code>@HasMany()</code> - Relaci\u00f3n uno a muchos - <code>@BelongsTo()</code> - Relaci\u00f3n muchos a uno</p> <p>Decoradores de Configuraci\u00f3n: - <code>@Name()</code> - Nombres personalizados para tablas/columnas</p>"},{"location":"guides/decorators/#primarykey-claves-primarias","title":"@PrimaryKey - Claves Primarias","text":"<p>El decorador <code>@PrimaryKey</code> define la clave primaria de la tabla. Internamente aplica <code>@Index</code> y <code>@IndexSort</code> autom\u00e1ticamente.</p>"},{"location":"guides/decorators/#sintaxis","title":"Sintaxis","text":"<pre><code>@PrimaryKey(name?: string): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#clave-primaria-simple","title":"Clave Primaria Simple","text":"<pre><code>import { Table, PrimaryKey, CreationOptional, Default } from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare email: string;\n}\n\n// Uso\nconst user = await User.create({\n  name: \"John Doe\",\n  email: \"john@example.com\"\n  // id es opcional (CreationOptional) y se genera autom\u00e1ticamente\n});\n\nconsole.log(user.id); // \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\"\n</code></pre>"},{"location":"guides/decorators/#clave-primaria-con-valor-estatico","title":"Clave Primaria con Valor Est\u00e1tico","text":"<pre><code>class Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare sku: string;\n\n  declare name: string;\n  declare price: number;\n}\n\n// Uso\nconst product = await Product.create({\n  sku: \"PROD-001\",\n  name: \"Widget\",\n  price: 29.99\n});\n</code></pre>"},{"location":"guides/decorators/#clave-primaria-compuesta-partition-sort","title":"Clave Primaria Compuesta (Partition + Sort)","text":"<p>Aunque <code>@PrimaryKey</code> aplica ambos decoradores, puedes definir claves compuestas manualmente:</p> <pre><code>class Order extends Table&lt;Order&gt; {\n  @Index()\n  declare user_id: string;\n\n  @IndexSort()\n  declare order_date: string;\n\n  declare total: number;\n  declare status: string;\n}\n\n// Uso\nconst order = await Order.create({\n  user_id: \"user-123\",\n  order_date: new Date().toISOString(),\n  total: 99.99,\n  status: \"pending\"\n});\n\n// Consultas por partition key\nconst user_orders = await Order.where({ user_id: \"user-123\" });\n\n// Consultas con sort key\nconst recent_orders = await Order.where({ user_id: \"user-123\" }, {\n  order: \"DESC\",\n  limit: 10\n});\n</code></pre>"},{"location":"guides/decorators/#caracteristicas-importantes","title":"Caracter\u00edsticas Importantes","text":"<pre><code>class Account extends Table&lt;Account&gt; {\n  @PrimaryKey()\n  declare account_id: string;\n  // Autom\u00e1ticamente:\n  // - Marcado como @Index (partition key)\n  // - Marcado como @IndexSort (sort key)\n  // - nullable = false (no puede ser nulo)\n  // - primaryKey = true en metadatos\n}\n</code></pre>"},{"location":"guides/decorators/#index-configuracion-de-gsi","title":"@Index - Configuraci\u00f3n de GSI","text":"<p>El decorador <code>@Index</code> marca una propiedad como Partition Key (clave de partici\u00f3n). Es fundamental para consultas eficientes en DynamoDB.</p>"},{"location":"guides/decorators/#sintaxis_1","title":"Sintaxis","text":"<pre><code>@Index(): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#indice-simple","title":"\u00cdndice Simple","text":"<pre><code>class Customer extends Table&lt;Customer&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @Index()\n  declare email: string;\n\n  declare name: string;\n  declare phone: string;\n}\n\n// Consultas por email (partition key)\nconst customers = await Customer.where({ email: \"john@example.com\" });\n</code></pre>"},{"location":"guides/decorators/#global-secondary-index-gsi","title":"Global Secondary Index (GSI)","text":"<pre><code>class Article extends Table&lt;Article&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @Index()\n  declare category: string;\n\n  @Index()\n  declare author_id: string;\n\n  declare title: string;\n  declare content: string;\n  declare published_at: string;\n}\n\n// Consultas por categor\u00eda\nconst tech_articles = await Article.where({ category: \"technology\" });\n\n// Consultas por autor\nconst author_articles = await Article.where({ author_id: \"author-123\" });\n</code></pre>"},{"location":"guides/decorators/#validaciones-del-decorador","title":"Validaciones del Decorador","text":"<pre><code>class InvalidModel extends Table&lt;InvalidModel&gt; {\n  @Index()\n  declare field1: string;\n\n  @Index() // Error: Solo puede haber un @Index por tabla\n  declare field2: string;\n  // Lanza: \"La tabla invalid_models ya tiene definida una PartitionKey\"\n}\n</code></pre>"},{"location":"guides/decorators/#indexsort-configuracion-de-lsi","title":"@IndexSort - Configuraci\u00f3n de LSI","text":"<p>El decorador <code>@IndexSort</code> marca una propiedad como Sort Key (clave de ordenaci\u00f3n). Requiere que exista una Partition Key definida.</p>"},{"location":"guides/decorators/#sintaxis_2","title":"Sintaxis","text":"<pre><code>@IndexSort(): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#sort-key-basico","title":"Sort Key B\u00e1sico","text":"<pre><code>class Message extends Table&lt;Message&gt; {\n  @Index()\n  declare conversation_id: string;\n\n  @IndexSort()\n  declare timestamp: string;\n\n  declare sender_id: string;\n  declare content: string;\n}\n\n// Crear mensajes\nawait Message.create({\n  conversation_id: \"conv-123\",\n  timestamp: \"2025-01-15T10:30:00Z\",\n  sender_id: \"user-1\",\n  content: \"Hello!\"\n});\n\n// Consultas ordenadas por timestamp\nconst messages = await Message.where({ conversation_id: \"conv-123\" }, {\n  order: \"ASC\" // Orden ascendente por timestamp\n});\n\n// Mensajes m\u00e1s recientes\nconst recent = await Message.where({ conversation_id: \"conv-123\" }, {\n  order: \"DESC\",\n  limit: 20\n});\n</code></pre>"},{"location":"guides/decorators/#rango-de-consultas-con-sort-key","title":"Rango de Consultas con Sort Key","text":"<pre><code>class Event extends Table&lt;Event&gt; {\n  @Index()\n  declare venue_id: string;\n\n  @IndexSort()\n  declare event_date: string;\n\n  declare name: string;\n  declare capacity: number;\n}\n\n// Eventos en un rango de fechas\nconst upcoming = await Event.where(\"event_date\", \"&gt;=\", \"2025-01-01\");\nconst past = await Event.where(\"event_date\", \"&lt;\", \"2025-01-01\");\n</code></pre>"},{"location":"guides/decorators/#local-secondary-index-lsi","title":"Local Secondary Index (LSI)","text":"<pre><code>class Transaction extends Table&lt;Transaction&gt; {\n  @Index()\n  declare account_id: string;\n\n  @IndexSort()\n  declare transaction_date: string;\n\n  declare amount: number;\n  declare type: string;\n  declare description: string;\n}\n\n// Transacciones de una cuenta ordenadas por fecha\nconst transactions = await Transaction.where({ account_id: \"acc-123\" }, {\n  order: \"DESC\",\n  limit: 50\n});\n\n// \u00daltimas transacciones\nconst last_transaction = await Transaction.last({ account_id: \"acc-123\" });\n</code></pre>"},{"location":"guides/decorators/#validaciones","title":"Validaciones","text":"<pre><code>class InvalidSort extends Table&lt;InvalidSort&gt; {\n  @IndexSort() // Error: Se requiere @Index primero\n  declare date: string;\n  // Lanza: \"No se puede definir una SortKey sin una PartitionKey\"\n}\n\nclass DuplicateSort extends Table&lt;DuplicateSort&gt; {\n  @Index()\n  declare id: string;\n\n  @IndexSort()\n  declare date1: string;\n\n  @IndexSort() // Error: Solo un @IndexSort permitido\n  declare date2: string;\n  // Lanza: \"La tabla ya tiene una SortKey definida\"\n}\n</code></pre>"},{"location":"guides/decorators/#default-valores-por-defecto","title":"@Default - Valores por Defecto","text":"<p>El decorador <code>@Default</code> establece valores por defecto est\u00e1ticos o din\u00e1micos para propiedades.</p>"},{"location":"guides/decorators/#sintaxis_3","title":"Sintaxis","text":"<pre><code>@Default(value: any | (() =&gt; any)): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#valores-estaticos","title":"Valores Est\u00e1ticos","text":"<pre><code>class Settings extends Table&lt;Settings&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @Default(\"dark\")\n  declare theme: CreationOptional&lt;string&gt;;\n\n  @Default(true)\n  declare notifications: CreationOptional&lt;boolean&gt;;\n\n  @Default(100)\n  declare volume: CreationOptional&lt;number&gt;;\n\n  @Default([])\n  declare tags: CreationOptional&lt;string[]&gt;;\n}\n\n// Uso\nconst settings = await Settings.create({}); // Todos los campos opcionales\nconsole.log(settings.theme); // \"dark\"\nconsole.log(settings.notifications); // true\nconsole.log(settings.volume); // 100\nconsole.log(settings.tags); // []\n</code></pre>"},{"location":"guides/decorators/#valores-dinamicos-funciones","title":"Valores Din\u00e1micos (Funciones)","text":"<pre><code>class Document extends Table&lt;Document&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; new Date().toISOString())\n  declare created: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; `DOC-${Date.now()}`)\n  declare code: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; Math.floor(Math.random() * 1000000))\n  declare reference_number: CreationOptional&lt;number&gt;;\n}\n\n// Cada instancia obtiene valores \u00fanicos\nconst doc1 = await Document.create({});\nconst doc2 = await Document.create({});\n\nconsole.log(doc1.id !== doc2.id); // true\nconsole.log(doc1.code !== doc2.code); // true\n</code></pre>"},{"location":"guides/decorators/#valores-por-defecto-complejos","title":"Valores por Defecto Complejos","text":"<pre><code>class UserProfile extends Table&lt;UserProfile&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; ({\n    theme: \"light\",\n    language: \"en\",\n    timezone: \"UTC\"\n  }))\n  declare preferences: CreationOptional&lt;Record&lt;string, string&gt;&gt;;\n\n  @Default(() =&gt; ({\n    email: true,\n    sms: false,\n    push: true\n  }))\n  declare notifications: CreationOptional&lt;Record&lt;string, boolean&gt;&gt;;\n\n  @Default(() =&gt; [])\n  declare recent_searches: CreationOptional&lt;string[]&gt;;\n}\n\n// Uso\nconst profile = await UserProfile.create({});\nconsole.log(profile.preferences); // { theme: \"light\", language: \"en\", ... }\nconsole.log(profile.notifications); // { email: true, sms: false, push: true }\n</code></pre>"},{"location":"guides/decorators/#combinando-con-creationoptional","title":"Combinando con CreationOptional","text":"<pre><code>import { CreationOptional } from \"@arcaelas/dynamite\";\n\nclass Task extends Table&lt;Task&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare title: string; // Requerido\n\n  @Default(() =&gt; \"pending\")\n  declare status: CreationOptional&lt;string&gt;; // Opcional\n\n  @Default(() =&gt; false)\n  declare completed: CreationOptional&lt;boolean&gt;; // Opcional\n\n  @Default(() =&gt; new Date().toISOString())\n  declare due_date: CreationOptional&lt;string&gt;; // Opcional\n}\n\n// Solo title es requerido\nconst task = await Task.create({ title: \"Complete project\" });\nconsole.log(task.status); // \"pending\"\nconsole.log(task.completed); // false\n</code></pre>"},{"location":"guides/decorators/#validate-funciones-de-validacion","title":"@Validate - Funciones de Validaci\u00f3n","text":"<p>El decorador <code>@Validate</code> permite definir funciones de validaci\u00f3n personalizadas que se ejecutan antes de guardar datos.</p>"},{"location":"guides/decorators/#sintaxis_4","title":"Sintaxis","text":"<pre><code>@Validate(validator: (value: unknown) =&gt; true | string): PropertyDecorator\n@Validate(validators: Array&lt;(value: unknown) =&gt; true | string&gt;): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#validacion-simple","title":"Validaci\u00f3n Simple","text":"<pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Validate((value) =&gt; {\n    const email = value as string;\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email) || \"Email inv\u00e1lido\";\n  })\n  declare email: string;\n\n  @Validate((value) =&gt; {\n    const age = value as number;\n    return age &gt;= 18 || \"Debe ser mayor de edad\";\n  })\n  declare age: number;\n}\n\n// V\u00e1lido\nconst user1 = await User.create({\n  id: \"user-1\",\n  email: \"john@example.com\",\n  age: 25\n});\n\n// Inv\u00e1lido - lanza error\ntry {\n  await User.create({\n    id: \"user-2\",\n    email: \"invalid-email\",\n    age: 25\n  });\n} catch (error) {\n  console.error(error.message); // \"Email inv\u00e1lido\"\n}\n</code></pre>"},{"location":"guides/decorators/#multiples-validadores","title":"M\u00faltiples Validadores","text":"<pre><code>class Password extends Table&lt;Password&gt; {\n  @PrimaryKey()\n  declare user_id: string;\n\n  @Validate([\n    (v) =&gt; (v as string).length &gt;= 8 || \"M\u00ednimo 8 caracteres\",\n    (v) =&gt; /[A-Z]/.test(v as string) || \"Debe contener may\u00fascula\",\n    (v) =&gt; /[a-z]/.test(v as string) || \"Debe contener min\u00fascula\",\n    (v) =&gt; /[0-9]/.test(v as string) || \"Debe contener n\u00famero\",\n    (v) =&gt; /[^A-Za-z0-9]/.test(v as string) || \"Debe contener s\u00edmbolo\"\n  ])\n  declare password: string;\n}\n\n// Todas las validaciones deben pasar\ntry {\n  await Password.create({\n    user_id: \"user-1\",\n    password: \"weak\"\n  });\n} catch (error) {\n  console.error(error.message); // \"M\u00ednimo 8 caracteres\"\n}\n\n// V\u00e1lido\nawait Password.create({\n  user_id: \"user-1\",\n  password: \"Str0ng!Pass\"\n});\n</code></pre>"},{"location":"guides/decorators/#validaciones-complejas","title":"Validaciones Complejas","text":"<pre><code>class Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  declare sku: string;\n\n  @Validate((value) =&gt; {\n    const price = value as number;\n    if (price &lt; 0) return \"El precio no puede ser negativo\";\n    if (price &gt; 999999.99) return \"El precio es demasiado alto\";\n    if (!/^\\d+(\\.\\d{1,2})?$/.test(price.toString())) {\n      return \"El precio debe tener m\u00e1ximo 2 decimales\";\n    }\n    return true;\n  })\n  declare price: number;\n\n  @Validate((value) =&gt; {\n    const stock = value as number;\n    return Number.isInteger(stock) &amp;&amp; stock &gt;= 0 || \"Stock debe ser entero positivo\";\n  })\n  declare stock: number;\n\n  @Validate((value) =&gt; {\n    const url = value as string;\n    try {\n      new URL(url);\n      return true;\n    } catch {\n      return \"URL inv\u00e1lida\";\n    }\n  })\n  declare image_url: string;\n}\n</code></pre>"},{"location":"guides/decorators/#validaciones-con-contexto","title":"Validaciones con Contexto","text":"<pre><code>class DateRange extends Table&lt;DateRange&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare start_date: string;\n\n  @Validate(function(value) {\n    const end = new Date(value as string);\n    const start = new Date(this.start_date);\n    return end &gt; start || \"La fecha final debe ser posterior a la inicial\";\n  })\n  declare end_date: string;\n}\n</code></pre>"},{"location":"guides/decorators/#mutate-transformacion-de-datos","title":"@Mutate - Transformaci\u00f3n de Datos","text":"<p>El decorador <code>@Mutate</code> transforma valores antes de guardarlos en la base de datos.</p>"},{"location":"guides/decorators/#sintaxis_5","title":"Sintaxis","text":"<pre><code>@Mutate(transformer: (value: any) =&gt; any): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#transformaciones-basicas","title":"Transformaciones B\u00e1sicas","text":"<pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Mutate((v) =&gt; (v as string).toLowerCase().trim())\n  declare email: string;\n\n  @Mutate((v) =&gt; (v as string).trim())\n  @Mutate((v) =&gt; v.charAt(0).toUpperCase() + v.slice(1).toLowerCase())\n  declare name: string;\n\n  @Mutate((v) =&gt; (v as string).replace(/\\D/g, \"\"))\n  declare phone: string;\n}\n\n// Uso\nconst user = await User.create({\n  id: \"user-1\",\n  email: \"  JOHN@EXAMPLE.COM  \",\n  name: \"  jOhN dOe  \",\n  phone: \"+1 (555) 123-4567\"\n});\n\nconsole.log(user.email); // \"john@example.com\"\nconsole.log(user.name); // \"John doe\"\nconsole.log(user.phone); // \"15551234567\"\n</code></pre>"},{"location":"guides/decorators/#transformaciones-multiples","title":"Transformaciones M\u00faltiples","text":"<p>Las mutaciones se ejecutan en orden de declaraci\u00f3n:</p> <pre><code>class Article extends Table&lt;Article&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @Mutate((v) =&gt; (v as string).trim())\n  @Mutate((v) =&gt; (v as string).replace(/\\s+/g, \" \"))\n  @Mutate((v) =&gt; (v as string).substring(0, 200))\n  declare title: string;\n\n  @Mutate((v) =&gt; (v as string).trim())\n  @Mutate((v) =&gt; (v as string).replace(/&lt;[^&gt;]*&gt;/g, \"\"))\n  @Mutate((v) =&gt; (v as string).substring(0, 5000))\n  declare content: string;\n}\n</code></pre>"},{"location":"guides/decorators/#transformaciones-numericas","title":"Transformaciones Num\u00e9ricas","text":"<pre><code>class Financial extends Table&lt;Financial&gt; {\n  @PrimaryKey()\n  declare transaction_id: string;\n\n  @Mutate((v) =&gt; Math.round((v as number) * 100) / 100)\n  declare amount: number;\n\n  @Mutate((v) =&gt; Math.max(0, Math.min(100, v as number)))\n  declare percentage: number;\n\n  @Mutate((v) =&gt; Math.abs(v as number))\n  declare quantity: number;\n}\n\n// Uso\nconst transaction = await Financial.create({\n  transaction_id: \"txn-1\",\n  amount: 123.456789,\n  percentage: 150,\n  quantity: -10\n});\n\nconsole.log(transaction.amount); // 123.46\nconsole.log(transaction.percentage); // 100\nconsole.log(transaction.quantity); // 10\n</code></pre>"},{"location":"guides/decorators/#transformaciones-de-objetos","title":"Transformaciones de Objetos","text":"<pre><code>class Settings extends Table&lt;Settings&gt; {\n  @PrimaryKey()\n  declare user_id: string;\n\n  @Mutate((v) =&gt; {\n    const config = v as Record&lt;string, any&gt;;\n    return Object.keys(config).reduce((acc, key) =&gt; {\n      acc[key.toLowerCase()] = config[key];\n      return acc;\n    }, {} as Record&lt;string, any&gt;);\n  })\n  declare preferences: Record&lt;string, any&gt;;\n\n  @Mutate((v) =&gt; Array.from(new Set(v as string[])))\n  declare tags: string[];\n}\n</code></pre>"},{"location":"guides/decorators/#notnull-campos-requeridos","title":"@NotNull - Campos Requeridos","text":"<p>El decorador <code>@NotNull</code> marca campos como requeridos, validando que no sean nulos, undefined o strings vac\u00edos.</p>"},{"location":"guides/decorators/#sintaxis_6","title":"Sintaxis","text":"<pre><code>@NotNull(): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#campos-obligatorios","title":"Campos Obligatorios","text":"<pre><code>class Customer extends Table&lt;Customer&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare name: string;\n\n  @NotNull()\n  declare email: string;\n\n  @NotNull()\n  declare phone: string;\n\n  declare address: string; // Opcional\n}\n\n// V\u00e1lido\nconst customer1 = await Customer.create({\n  name: \"John Doe\",\n  email: \"john@example.com\",\n  phone: \"555-1234\"\n});\n\n// Inv\u00e1lido - lanza error\ntry {\n  await Customer.create({\n    name: \"\",\n    email: \"john@example.com\",\n    phone: \"555-1234\"\n  });\n} catch (error) {\n  console.error(\"Validaci\u00f3n fallida\"); // name est\u00e1 vac\u00edo\n}\n</code></pre>"},{"location":"guides/decorators/#combinando-con-validate","title":"Combinando con @Validate","text":"<pre><code>class Registration extends Table&lt;Registration&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  @Mutate((v) =&gt; (v as string).toLowerCase().trim())\n  @Validate((v) =&gt; /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v as string) || \"Email inv\u00e1lido\")\n  declare email: string;\n\n  @NotNull()\n  @Validate((v) =&gt; (v as string).length &gt;= 8 || \"M\u00ednimo 8 caracteres\")\n  declare password: string;\n}\n</code></pre>"},{"location":"guides/decorators/#validacion-en-arrays-y-objetos","title":"Validaci\u00f3n en Arrays y Objetos","text":"<pre><code>class Project extends Table&lt;Project&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare title: string;\n\n  @NotNull()\n  @Validate((v) =&gt; Array.isArray(v) &amp;&amp; v.length &gt; 0 || \"Debe tener al menos un miembro\")\n  declare team_members: string[];\n\n  @NotNull()\n  @Validate((v) =&gt; {\n    const config = v as Record&lt;string, any&gt;;\n    return Object.keys(config).length &gt; 0 || \"Configuraci\u00f3n no puede estar vac\u00eda\";\n  })\n  declare config: Record&lt;string, any&gt;;\n}\n</code></pre>"},{"location":"guides/decorators/#createdat-timestamp-de-creacion","title":"@CreatedAt - Timestamp de Creaci\u00f3n","text":"<p>El decorador <code>@CreatedAt</code> establece autom\u00e1ticamente la fecha y hora de creaci\u00f3n en formato ISO 8601.</p>"},{"location":"guides/decorators/#sintaxis_7","title":"Sintaxis","text":"<pre><code>@CreatedAt(): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#uso-basico","title":"Uso B\u00e1sico","text":"<pre><code>class Post extends Table&lt;Post&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare title: string;\n  declare content: string;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n}\n\n// La fecha se establece autom\u00e1ticamente\nconst post = await Post.create({\n  title: \"Mi primer post\",\n  content: \"Contenido del post\"\n});\n\nconsole.log(post.created_at); // \"2025-01-15T10:30:00.123Z\"\n</code></pre>"},{"location":"guides/decorators/#auditoria-completa","title":"Auditor\u00eda Completa","text":"<pre><code>class AuditLog extends Table&lt;AuditLog&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare user_id: string;\n  declare action: string;\n  declare resource: string;\n\n  @CreatedAt()\n  declare timestamp: CreationOptional&lt;string&gt;;\n\n  declare ip_address: string;\n  declare user_agent: string;\n}\n\n// Registro de auditor\u00eda con timestamp autom\u00e1tico\nconst log = await AuditLog.create({\n  user_id: \"user-123\",\n  action: \"DELETE\",\n  resource: \"document-456\",\n  ip_address: \"192.168.1.1\",\n  user_agent: \"Mozilla/5.0...\"\n});\n</code></pre>"},{"location":"guides/decorators/#consultas-por-fecha","title":"Consultas por Fecha","text":"<pre><code>class Event extends Table&lt;Event&gt; {\n  @Index()\n  declare category: string;\n\n  @IndexSort()\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n  declare description: string;\n}\n\n// Eventos recientes por categor\u00eda\nconst recent_events = await Event.where({ category: \"news\" }, {\n  order: \"DESC\",\n  limit: 20\n});\n\n// Eventos en un rango de fechas\nconst events = await Event.where(\"created_at\", \"&gt;=\", \"2025-01-01T00:00:00Z\");\n</code></pre>"},{"location":"guides/decorators/#updatedat-timestamp-de-actualizacion","title":"@UpdatedAt - Timestamp de Actualizaci\u00f3n","text":"<p>El decorador <code>@UpdatedAt</code> actualiza autom\u00e1ticamente la fecha y hora cada vez que se guarda el registro.</p>"},{"location":"guides/decorators/#sintaxis_8","title":"Sintaxis","text":"<pre><code>@UpdatedAt(): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#uso-basico_1","title":"Uso B\u00e1sico","text":"<pre><code>class Document extends Table&lt;Document&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare title: string;\n  declare content: string;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n}\n\n// Creaci\u00f3n\nconst doc = await Document.create({\n  title: \"Documento\",\n  content: \"Contenido inicial\"\n});\n\nconsole.log(doc.created_at); // \"2025-01-15T10:00:00Z\"\nconsole.log(doc.updated_at); // \"2025-01-15T10:00:00Z\"\n\n// Actualizaci\u00f3n\ndoc.content = \"Contenido actualizado\";\nawait doc.save();\n\nconsole.log(doc.created_at); // \"2025-01-15T10:00:00Z\" (sin cambios)\nconsole.log(doc.updated_at); // \"2025-01-15T10:15:00Z\" (actualizado)\n</code></pre>"},{"location":"guides/decorators/#sistema-de-versiones","title":"Sistema de Versiones","text":"<pre><code>class Article extends Table&lt;Article&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare title: string;\n  declare content: string;\n  declare author_id: string;\n\n  @Default(() =&gt; 1)\n  declare version: CreationOptional&lt;number&gt;;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n\n  declare last_edited_by: string;\n}\n\n// Actualizaci\u00f3n con versi\u00f3n\nconst article = await Article.first({ id: \"article-123\" });\nif (article) {\n  article.content = \"Nuevo contenido\";\n  article.version = article.version + 1;\n  article.last_edited_by = \"user-456\";\n  await article.save();\n  // updated_at se actualiza autom\u00e1ticamente\n}\n</code></pre>"},{"location":"guides/decorators/#tracking-de-cambios","title":"Tracking de Cambios","text":"<pre><code>class UserProfile extends Table&lt;UserProfile&gt; {\n  @PrimaryKey()\n  declare user_id: string;\n\n  declare name: string;\n  declare email: string;\n  declare phone: string;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare last_modified: CreationOptional&lt;string&gt;;\n\n  declare modification_count: number;\n}\n\n// Incrementar contador en cada modificaci\u00f3n\nconst profile = await UserProfile.first({ user_id: \"user-123\" });\nif (profile) {\n  profile.name = \"Nuevo Nombre\";\n  profile.modification_count = (profile.modification_count || 0) + 1;\n  await profile.save();\n  // last_modified se actualiza autom\u00e1ticamente\n}\n</code></pre>"},{"location":"guides/decorators/#name-nombres-personalizados","title":"@Name - Nombres Personalizados","text":"<p>El decorador <code>@Name</code> permite personalizar los nombres de tablas y columnas en la base de datos.</p>"},{"location":"guides/decorators/#sintaxis_9","title":"Sintaxis","text":"<pre><code>@Name(name: string): ClassDecorator &amp; PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#nombre-de-tabla-personalizado","title":"Nombre de Tabla Personalizado","text":"<pre><code>@Name(\"custom_users_table\")\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare name: string;\n  declare email: string;\n}\n\n// La tabla se crea con el nombre \"custom_users_table\"\n</code></pre>"},{"location":"guides/decorators/#nombres-de-columnas-personalizados","title":"Nombres de Columnas Personalizados","text":"<pre><code>class Customer extends Table&lt;Customer&gt; {\n  @PrimaryKey()\n  @Name(\"customer_id\")\n  declare id: string;\n\n  @Name(\"full_name\")\n  declare name: string;\n\n  @Name(\"email_address\")\n  declare email: string;\n\n  @Name(\"phone_number\")\n  declare phone: string;\n}\n\n// En DynamoDB: { customer_id, full_name, email_address, phone_number }\n</code></pre>"},{"location":"guides/decorators/#compatibilidad-con-sistemas-legados","title":"Compatibilidad con Sistemas Legados","text":"<pre><code>@Name(\"legacy_orders\")\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  @Name(\"ORDER_ID\")\n  declare id: string;\n\n  @Name(\"CUSTOMER_ID\")\n  declare customer_id: string;\n\n  @Name(\"ORDER_DATE\")\n  declare order_date: string;\n\n  @Name(\"TOTAL_AMOUNT\")\n  declare total: number;\n\n  @Name(\"ORDER_STATUS\")\n  declare status: string;\n}\n</code></pre>"},{"location":"guides/decorators/#hasmany-relaciones-uno-a-muchos","title":"@HasMany - Relaciones Uno a Muchos","text":"<p>El decorador <code>@HasMany</code> define relaciones donde un modelo tiene m\u00faltiples instancias de otro modelo.</p>"},{"location":"guides/decorators/#sintaxis_10","title":"Sintaxis","text":"<pre><code>@HasMany(targetModel: () =&gt; Model, foreignKey: string, localKey?: string): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#relacion-basica","title":"Relaci\u00f3n B\u00e1sica","text":"<pre><code>import { HasMany, NonAttribute } from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare name: string;\n  declare email: string;\n\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n}\n\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare user_id: string;\n\n  declare total: number;\n  declare status: string;\n}\n\n// Cargar usuario con \u00f3rdenes\nconst users = await User.where({ id: \"user-123\" }, {\n  include: {\n    orders: {}\n  }\n});\n\nconsole.log(users[0].orders); // Order[]\n</code></pre>"},{"location":"guides/decorators/#relaciones-filtradas","title":"Relaciones Filtradas","text":"<pre><code>// Obtener usuario con \u00f3rdenes completadas\nconst users = await User.where({ id: \"user-123\" }, {\n  include: {\n    orders: {\n      where: { status: \"completed\" },\n      limit: 10,\n      order: \"DESC\"\n    }\n  }\n});\n</code></pre>"},{"location":"guides/decorators/#relaciones-anidadas","title":"Relaciones Anidadas","text":"<pre><code>class User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare name: string;\n\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n}\n\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare user_id: string;\n  declare total: number;\n\n  @HasMany(() =&gt; OrderItem, \"order_id\")\n  declare items: NonAttribute&lt;HasMany&lt;OrderItem&gt;&gt;;\n}\n\nclass OrderItem extends Table&lt;OrderItem&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare order_id: string;\n  declare product_id: string;\n  declare quantity: number;\n  declare price: number;\n}\n\n// Cargar usuarios con \u00f3rdenes e items\nconst users = await User.where({}, {\n  include: {\n    orders: {\n      include: {\n        items: {}\n      }\n    }\n  }\n});\n</code></pre>"},{"location":"guides/decorators/#belongsto-relaciones-muchos-a-uno","title":"@BelongsTo - Relaciones Muchos a Uno","text":"<p>El decorador <code>@BelongsTo</code> define relaciones donde un modelo pertenece a otro modelo.</p>"},{"location":"guides/decorators/#sintaxis_11","title":"Sintaxis","text":"<pre><code>@BelongsTo(targetModel: () =&gt; Model, localKey: string, foreignKey?: string): PropertyDecorator\n</code></pre>"},{"location":"guides/decorators/#relacion-basica_1","title":"Relaci\u00f3n B\u00e1sica","text":"<pre><code>import { BelongsTo, NonAttribute } from \"@arcaelas/dynamite\";\n\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare user_id: string;\n\n  declare total: number;\n  declare status: string;\n\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare name: string;\n  declare email: string;\n}\n\n// Cargar orden con usuario\nconst orders = await Order.where({ id: \"order-123\" }, {\n  include: {\n    user: {}\n  }\n});\n\nconsole.log(orders[0].user?.name); // \"John Doe\"\n</code></pre>"},{"location":"guides/decorators/#multiples-relaciones","title":"M\u00faltiples Relaciones","text":"<pre><code>class OrderItem extends Table&lt;OrderItem&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  declare order_id: string;\n  declare product_id: string;\n  declare quantity: number;\n\n  @BelongsTo(() =&gt; Order, \"order_id\")\n  declare order: NonAttribute&lt;BelongsTo&lt;Order&gt;&gt;;\n\n  @BelongsTo(() =&gt; Product, \"product_id\")\n  declare product: NonAttribute&lt;BelongsTo&lt;Product&gt;&gt;;\n}\n\n// Cargar item con orden y producto\nconst items = await OrderItem.where({ id: \"item-123\" }, {\n  include: {\n    order: {},\n    product: {}\n  }\n});\n</code></pre>"},{"location":"guides/decorators/#combinando-multiples-decoradores","title":"Combinando M\u00faltiples Decoradores","text":""},{"location":"guides/decorators/#modelo-completo-con-todos-los-decoradores","title":"Modelo Completo con Todos los Decoradores","text":"<pre><code>import {\n  Table,\n  PrimaryKey,\n  Index,\n  IndexSort,\n  Default,\n  Validate,\n  Mutate,\n  NotNull,\n  CreatedAt,\n  UpdatedAt,\n  Name,\n  HasMany,\n  BelongsTo,\n  CreationOptional,\n  NonAttribute\n} from \"@arcaelas/dynamite\";\n\n@Name(\"users\")\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  @Mutate((v) =&gt; (v as string).toLowerCase().trim())\n  @Validate((v) =&gt; /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v as string) || \"Email inv\u00e1lido\")\n  @Name(\"email_address\")\n  declare email: string;\n\n  @NotNull()\n  @Mutate((v) =&gt; (v as string).trim())\n  @Validate([\n    (v) =&gt; (v as string).length &gt;= 2 || \"Nombre muy corto\",\n    (v) =&gt; (v as string).length &lt;= 50 || \"Nombre muy largo\"\n  ])\n  declare name: string;\n\n  @Default(() =&gt; 18)\n  @Validate((v) =&gt; (v as number) &gt;= 0 &amp;&amp; (v as number) &lt;= 150 || \"Edad inv\u00e1lida\")\n  declare age: CreationOptional&lt;number&gt;;\n\n  @Default(() =&gt; \"customer\")\n  @Validate((v) =&gt; [\"customer\", \"admin\", \"moderator\"].includes(v as string) || \"Rol inv\u00e1lido\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n\n  @HasMany(() =&gt; Review, \"user_id\")\n  declare reviews: NonAttribute&lt;HasMany&lt;Review&gt;&gt;;\n\n  // Propiedad computada\n  declare display_name: NonAttribute&lt;string&gt;;\n\n  constructor(data?: any) {\n    super(data);\n    Object.defineProperty(this, 'display_name', {\n      get: () =&gt; `${this.name} (${this.role})`,\n      enumerable: true\n    });\n  }\n}\n</code></pre>"},{"location":"guides/decorators/#patrones-de-decoradores-personalizados","title":"Patrones de Decoradores Personalizados","text":""},{"location":"guides/decorators/#crear-decoradores-compuestos","title":"Crear Decoradores Compuestos","text":"<pre><code>function EmailField(): PropertyDecorator {\n  return (target: any, prop: string | symbol) =&gt; {\n    NotNull()(target, prop);\n    Mutate((v) =&gt; (v as string).toLowerCase().trim())(target, prop);\n    Validate((v) =&gt; /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(v as string) || \"Email inv\u00e1lido\")(target, prop);\n  };\n}\n\nfunction SlugField(): PropertyDecorator {\n  return (target: any, prop: string | symbol) =&gt; {\n    Mutate((v) =&gt; (v as string).toLowerCase())(target, prop);\n    Mutate((v) =&gt; (v as string).replace(/[^a-z0-9]+/g, \"-\"))(target, prop);\n    Mutate((v) =&gt; (v as string).replace(/^-+|-+$/g, \"\"))(target, prop);\n    Validate((v) =&gt; (v as string).length &gt; 0 || \"Slug no puede estar vac\u00edo\")(target, prop);\n  };\n}\n\nclass Article extends Table&lt;Article&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @EmailField()\n  declare author_email: string;\n\n  @SlugField()\n  declare slug: string;\n}\n</code></pre>"},{"location":"guides/decorators/#mejores-practicas","title":"Mejores Pr\u00e1cticas","text":""},{"location":"guides/decorators/#1-usar-creationoptional-apropiadamente","title":"1. Usar CreationOptional Apropiadamente","text":"<pre><code>class User extends Table&lt;User&gt; {\n  // Siempre CreationOptional con @Default\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Siempre CreationOptional con @CreatedAt/@UpdatedAt\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  // Campos requeridos sin CreationOptional\n  @NotNull()\n  declare email: string;\n}\n</code></pre>"},{"location":"guides/decorators/#2-orden-de-decoradores","title":"2. Orden de Decoradores","text":"<pre><code>class User extends Table&lt;User&gt; {\n  // Orden recomendado: Clave \u2192 Validaci\u00f3n \u2192 Transformaci\u00f3n \u2192 Defaults \u2192 Timestamps\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  @Validate((v) =&gt; /^[^\\s@]+@/.test(v as string) || \"Inv\u00e1lido\")\n  @Mutate((v) =&gt; (v as string).toLowerCase())\n  @Name(\"email_address\")\n  declare email: string;\n}\n</code></pre>"},{"location":"guides/decorators/#3-validaciones-descriptivas","title":"3. Validaciones Descriptivas","text":"<pre><code>// Mal\n@Validate((v) =&gt; (v as number) &gt; 0)\ndeclare price: number;\n\n// Bien\n@Validate((v) =&gt; (v as number) &gt; 0 || \"El precio debe ser mayor a 0\")\ndeclare price: number;\n</code></pre>"},{"location":"guides/decorators/#4-relaciones-con-nonattribute","title":"4. Relaciones con NonAttribute","text":"<pre><code>class User extends Table&lt;User&gt; {\n  // Siempre marcar relaciones como NonAttribute\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n}\n</code></pre> <p>Esta gu\u00eda cubre todos los decoradores disponibles en Dynamite con ejemplos pr\u00e1cticos y patrones recomendados para construir modelos robustos y type-safe.</p>"},{"location":"guides/getting-started/","title":"Getting Started with Dynamite","text":"<p>Welcome to Dynamite! This guide will walk you through everything you need to know to start building applications with this modern, decorator-first ORM for DynamoDB.</p>"},{"location":"guides/getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have: - Node.js 16+ installed - Basic TypeScript knowledge - AWS account (or DynamoDB Local for development)</p>"},{"location":"guides/getting-started/#installation","title":"Installation","text":"<pre><code>npm install @arcaelas/dynamite\n\n# Peer dependencies (if not already installed)\nnpm install @aws-sdk/client-dynamodb @aws-sdk/lib-dynamodb\n</code></pre>"},{"location":"guides/getting-started/#configuration","title":"Configuration","text":"<p>First, configure your DynamoDB connection:</p> <pre><code>import { Dynamite } from \"@arcaelas/dynamite\";\n\n// For local development\nDynamite.config({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  }\n});\n\n// For AWS production\nDynamite.config({\n  region: \"us-east-1\",\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!\n  }\n});\n</code></pre>"},{"location":"guides/getting-started/#step-1-your-first-model","title":"Step 1: Your First Model","text":"<p>Let's create a simple User model. In Dynamite, models are classes that extend <code>Table</code> and use decorators to define their structure.</p> <pre><code>import { Table, PrimaryKey, Default, CreationOptional } from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  // Primary key with auto-generated UUID\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Required field during creation\n  declare name: string;\n\n  // Optional field with default value\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n}\n</code></pre> <p>Key concepts: - <code>@PrimaryKey()</code> marks the primary key (partition key in DynamoDB) - <code>@Default()</code> provides automatic default values - <code>CreationOptional&lt;T&gt;</code> makes fields optional during creation but required in instances - <code>declare</code> is TypeScript syntax for class properties</p>"},{"location":"guides/getting-started/#step-2-creating-records","title":"Step 2: Creating Records","text":"<p>There are multiple ways to create records in Dynamite:</p>"},{"location":"guides/getting-started/#using-create-method","title":"Using <code>create()</code> method","text":"<pre><code>// Create with required fields only\nconst user1 = await User.create({\n  name: \"John Doe\"\n  // id and role are optional (auto-generated/defaulted)\n});\n\nconsole.log(user1.id);   // \"550e8400-e29b-41d4-a716-446655440000\"\nconsole.log(user1.name); // \"John Doe\"\nconsole.log(user1.role); // \"customer\"\n\n// Create with all fields\nconst user2 = await User.create({\n  id: \"custom-id\",\n  name: \"Jane Smith\",\n  role: \"admin\"\n});\n</code></pre>"},{"location":"guides/getting-started/#creating-multiple-records","title":"Creating multiple records","text":"<pre><code>const users = await Promise.all([\n  User.create({ name: \"Alice\" }),\n  User.create({ name: \"Bob\" }),\n  User.create({ name: \"Charlie\" })\n]);\n\nconsole.log(`Created ${users.length} users`);\n</code></pre>"},{"location":"guides/getting-started/#step-3-reading-records","title":"Step 3: Reading Records","text":"<p>Dynamite provides several methods to query your data:</p>"},{"location":"guides/getting-started/#get-all-records","title":"Get all records","text":"<pre><code>const all_users = await User.where({});\nconsole.log(`Total users: ${all_users.length}`);\n</code></pre>"},{"location":"guides/getting-started/#filter-by-fields","title":"Filter by fields","text":"<pre><code>// Filter by exact match\nconst admins = await User.where({ role: \"admin\" });\n\n// Filter by multiple conditions\nconst admin_johns = await User.where({\n  name: \"John Doe\",\n  role: \"admin\"\n});\n</code></pre>"},{"location":"guides/getting-started/#get-first-or-last-record","title":"Get first or last record","text":"<pre><code>// Get first user\nconst first_user = await User.first({});\n\n// Get first admin\nconst first_admin = await User.first({ role: \"admin\" });\n\n// Get last user\nconst last_user = await User.last({});\n</code></pre>"},{"location":"guides/getting-started/#advanced-queries-with-operators","title":"Advanced queries with operators","text":"<pre><code>// Greater than or equal\nconst premium_users = await User.where(\"id\", \"&gt;=\", \"user-100\");\n\n// String contains\nconst gmail_users = await User.where(\"name\", \"contains\", \"gmail\");\n\n// In array\nconst special_roles = await User.where(\"role\", \"in\", [\"admin\", \"premium\", \"vip\"]);\n\n// Not equal\nconst non_customers = await User.where(\"role\", \"!=\", \"customer\");\n</code></pre>"},{"location":"guides/getting-started/#query-with-options","title":"Query with options","text":"<pre><code>// Limit results\nconst first_10_users = await User.where({}, { limit: 10 });\n\n// Pagination (skip and limit)\nconst page_2_users = await User.where({}, {\n  limit: 10,\n  skip: 10\n});\n\n// Sort order\nconst sorted_users = await User.where({}, { order: \"DESC\" });\n\n// Select specific attributes\nconst user_names = await User.where({}, {\n  attributes: [\"id\", \"name\"]\n});\n</code></pre>"},{"location":"guides/getting-started/#step-4-updating-records","title":"Step 4: Updating Records","text":"<p>You can update records using instance methods or static methods:</p>"},{"location":"guides/getting-started/#using-instance-save-method","title":"Using instance <code>save()</code> method","text":"<pre><code>// Get a user\nconst user = await User.first({ name: \"John Doe\" });\n\nif (user) {\n  // Modify properties\n  user.name = \"John Smith\";\n  user.role = \"premium\";\n\n  // Save changes\n  await user.save();\n\n  console.log(\"User updated successfully\");\n}\n</code></pre>"},{"location":"guides/getting-started/#using-instance-update-method","title":"Using instance <code>update()</code> method","text":"<pre><code>const user = await User.first({ name: \"John Doe\" });\n\nif (user) {\n  // Update multiple fields at once\n  await user.update({\n    name: \"John Smith\",\n    role: \"premium\"\n  });\n}\n</code></pre>"},{"location":"guides/getting-started/#using-static-update-method","title":"Using static <code>update()</code> method","text":"<pre><code>// Update by ID\nawait User.update(\"user-123\", {\n  name: \"John Smith\",\n  role: \"premium\"\n});\n</code></pre>"},{"location":"guides/getting-started/#batch-updates","title":"Batch updates","text":"<pre><code>const users = await User.where({ role: \"customer\" });\n\n// Update all customers to premium\nawait Promise.all(users.map(user =&gt; {\n  user.role = \"premium\";\n  return user.save();\n}));\n</code></pre>"},{"location":"guides/getting-started/#step-5-deleting-records","title":"Step 5: Deleting Records","text":"<p>Delete records using instance or static methods:</p>"},{"location":"guides/getting-started/#using-instance-destroy-method","title":"Using instance <code>destroy()</code> method","text":"<pre><code>const user = await User.first({ name: \"John Doe\" });\n\nif (user) {\n  await user.destroy();\n  console.log(\"User deleted\");\n}\n</code></pre>"},{"location":"guides/getting-started/#using-static-delete-method","title":"Using static <code>delete()</code> method","text":"<pre><code>// Delete by ID\nawait User.delete(\"user-123\");\n</code></pre>"},{"location":"guides/getting-started/#batch-delete","title":"Batch delete","text":"<pre><code>const inactive_users = await User.where({ active: false });\n\n// Delete all inactive users\nawait Promise.all(inactive_users.map(user =&gt; user.destroy()));\n</code></pre>"},{"location":"guides/getting-started/#step-6-adding-timestamps","title":"Step 6: Adding Timestamps","text":"<p>Timestamps track when records are created and updated. Use <code>@CreatedAt</code> and <code>@UpdatedAt</code> decorators:</p> <pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  CreationOptional\n} from \"@arcaelas/dynamite\";\n\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  declare name: string;\n\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  // Auto-set on creation\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  // Auto-update on save\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n}\n\n// Usage\nconst user = await User.create({ name: \"John Doe\" });\n\nconsole.log(user.created_at); // \"2024-01-15T10:30:00.000Z\"\nconsole.log(user.updated_at); // \"2024-01-15T10:30:00.000Z\"\n\n// Update user\nuser.name = \"John Smith\";\nawait user.save();\n\nconsole.log(user.updated_at); // \"2024-01-15T10:35:00.000Z\" (updated!)\n</code></pre>"},{"location":"guides/getting-started/#step-7-complete-working-example","title":"Step 7: Complete Working Example","text":"<p>Here's a complete example tying everything together - a simple task management system:</p> <pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  Validate,\n  Mutate,\n  NotNull,\n  CreationOptional,\n  NonAttribute,\n  Dynamite\n} from \"@arcaelas/dynamite\";\n\n// Configure DynamoDB connection\nDynamite.config({\n  region: \"us-east-1\",\n  endpoint: \"http://localhost:8000\",\n  credentials: {\n    accessKeyId: \"test\",\n    secretAccessKey: \"test\"\n  }\n});\n\n// Define Task model\nclass Task extends Table&lt;Task&gt; {\n  // Auto-generated ID\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  // Required title with validation\n  @NotNull()\n  @Mutate((value) =&gt; (value as string).trim())\n  @Validate((value) =&gt; (value as string).length &gt;= 3 || \"Title must be at least 3 characters\")\n  declare title: string;\n\n  // Optional description\n  @Default(() =&gt; \"\")\n  declare description: CreationOptional&lt;string&gt;;\n\n  // Status with default value\n  @Default(() =&gt; \"pending\")\n  @Validate((value) =&gt; [\"pending\", \"in_progress\", \"completed\"].includes(value as string) || \"Invalid status\")\n  declare status: CreationOptional&lt;string&gt;;\n\n  // Priority with validation\n  @Default(() =&gt; 1)\n  @Validate((value) =&gt; (value as number) &gt;= 1 &amp;&amp; (value as number) &lt;= 5 || \"Priority must be between 1 and 5\")\n  declare priority: CreationOptional&lt;number&gt;;\n\n  // Timestamps\n  @CreatedAt()\n  declare created_at: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updated_at: CreationOptional&lt;string&gt;;\n\n  // Computed property (not stored in database)\n  declare display_title: NonAttribute&lt;string&gt;;\n\n  constructor(data?: any) {\n    super(data);\n\n    // Define computed property\n    Object.defineProperty(this, 'display_title', {\n      get: () =&gt; `[${this.status.toUpperCase()}] ${this.title}`,\n      enumerable: true\n    });\n  }\n}\n\n// Main application\nasync function main() {\n  console.log(\"=== Task Management System ===\\n\");\n\n  // 1. Create tasks\n  console.log(\"1. Creating tasks...\");\n  const task1 = await Task.create({\n    title: \"Write documentation\",\n    description: \"Complete the getting started guide\",\n    priority: 3\n  });\n  console.log(`Created: ${task1.display_title}`);\n\n  const task2 = await Task.create({\n    title: \"Fix bug in API\",\n    priority: 5\n  });\n  console.log(`Created: ${task2.display_title}`);\n\n  const task3 = await Task.create({\n    title: \"Review pull request\",\n    priority: 2\n  });\n  console.log(`Created: ${task3.display_title}\\n`);\n\n  // 2. Get all tasks\n  console.log(\"2. Listing all tasks...\");\n  const all_tasks = await Task.where({});\n  all_tasks.forEach(task =&gt; {\n    console.log(`  - ${task.title} (Priority: ${task.priority})`);\n  });\n  console.log();\n\n  // 3. Filter tasks by status\n  console.log(\"3. Filtering pending tasks...\");\n  const pending_tasks = await Task.where({ status: \"pending\" });\n  console.log(`Found ${pending_tasks.length} pending tasks\\n`);\n\n  // 4. Query high priority tasks\n  console.log(\"4. Finding high priority tasks (priority &gt;= 4)...\");\n  const high_priority = await Task.where(\"priority\", \"&gt;=\", 4);\n  high_priority.forEach(task =&gt; {\n    console.log(`  - ${task.display_title} (Priority: ${task.priority})`);\n  });\n  console.log();\n\n  // 5. Update a task\n  console.log(\"5. Updating task status...\");\n  const task_to_update = await Task.first({ title: \"Write documentation\" });\n  if (task_to_update) {\n    task_to_update.status = \"in_progress\";\n    await task_to_update.save();\n    console.log(`Updated: ${task_to_update.display_title}\\n`);\n  }\n\n  // 6. Get tasks with specific attributes\n  console.log(\"6. Getting task summaries (id and title only)...\");\n  const summaries = await Task.where({}, {\n    attributes: [\"id\", \"title\", \"status\"]\n  });\n  summaries.forEach(task =&gt; {\n    console.log(`  - ${task.title}: ${task.status}`);\n  });\n  console.log();\n\n  // 7. Get tasks ordered by priority\n  console.log(\"7. Listing tasks by priority (descending)...\");\n  const ordered_tasks = await Task.where({}, { order: \"DESC\" });\n  ordered_tasks.forEach(task =&gt; {\n    console.log(`  - [P${task.priority}] ${task.title}`);\n  });\n  console.log();\n\n  // 8. Mark tasks as completed\n  console.log(\"8. Marking all pending tasks as completed...\");\n  const pending = await Task.where({ status: \"pending\" });\n  await Promise.all(pending.map(task =&gt; {\n    task.status = \"completed\";\n    return task.save();\n  }));\n  console.log(`Completed ${pending.length} tasks\\n`);\n\n  // 9. Get completed tasks\n  console.log(\"9. Listing completed tasks...\");\n  const completed = await Task.where({ status: \"completed\" });\n  completed.forEach(task =&gt; {\n    console.log(`  - ${task.title} (Created: ${new Date(task.created_at).toLocaleDateString()})`);\n  });\n  console.log();\n\n  // 10. Delete a task\n  console.log(\"10. Deleting a task...\");\n  const task_to_delete = await Task.first({ title: \"Review pull request\" });\n  if (task_to_delete) {\n    await task_to_delete.destroy();\n    console.log(`Deleted: ${task_to_delete.title}\\n`);\n  }\n\n  // Final count\n  const final_count = await Task.where({});\n  console.log(`=== Final task count: ${final_count.length} ===`);\n}\n\n// Run the application\nmain().catch(console.error);\n</code></pre> <p>Expected output: <pre><code>=== Task Management System ===\n\n1. Creating tasks...\nCreated: [PENDING] Write documentation\nCreated: [PENDING] Fix bug in API\nCreated: [PENDING] Review pull request\n\n2. Listing all tasks...\n  - Write documentation (Priority: 3)\n  - Fix bug in API (Priority: 5)\n  - Review pull request (Priority: 2)\n\n3. Filtering pending tasks...\nFound 3 pending tasks\n\n4. Finding high priority tasks (priority &gt;= 4)...\n  - [PENDING] Fix bug in API (Priority: 5)\n\n5. Updating task status...\nUpdated: [IN_PROGRESS] Write documentation\n\n6. Getting task summaries (id and title only)...\n  - Write documentation: in_progress\n  - Fix bug in API: pending\n  - Review pull request: pending\n\n7. Listing tasks by priority (descending)...\n  - [P5] Fix bug in API\n  - [P3] Write documentation\n  - [P2] Review pull request\n\n8. Marking all pending tasks as completed...\nCompleted 2 tasks\n\n9. Listing completed tasks...\n  - Fix bug in API (Created: 1/15/2024)\n  - Review pull request (Created: 1/15/2024)\n\n10. Deleting a task...\nDeleted: Review pull request\n\n=== Final task count: 2 ===\n</code></pre></p>"},{"location":"guides/getting-started/#understanding-the-example","title":"Understanding the Example","text":"<p>Let's break down the key parts:</p>"},{"location":"guides/getting-started/#model-definition","title":"Model Definition","text":"<p><pre><code>class Task extends Table&lt;Task&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n  // ...\n}\n</code></pre> - Extends <code>Table&lt;Task&gt;</code> for ORM functionality - Decorators define field behavior - <code>CreationOptional</code> makes fields optional during creation</p>"},{"location":"guides/getting-started/#data-validation","title":"Data Validation","text":"<p><pre><code>@Validate((value) =&gt; (value as string).length &gt;= 3 || \"Title must be at least 3 characters\")\ndeclare title: string;\n</code></pre> - Validates data before saving - Returns <code>true</code> or error message string</p>"},{"location":"guides/getting-started/#data-transformation","title":"Data Transformation","text":"<p><pre><code>@Mutate((value) =&gt; (value as string).trim())\ndeclare title: string;\n</code></pre> - Transforms data before storage - Useful for normalization (trim, lowercase, etc.)</p>"},{"location":"guides/getting-started/#computed-properties","title":"Computed Properties","text":"<p><pre><code>declare display_title: NonAttribute&lt;string&gt;;\n\nconstructor(data?: any) {\n  super(data);\n  Object.defineProperty(this, 'display_title', {\n    get: () =&gt; `[${this.status.toUpperCase()}] ${this.title}`,\n    enumerable: true\n  });\n}\n</code></pre> - <code>NonAttribute</code> excludes from database - Computed dynamically from other fields - Not stored, recalculated on access</p>"},{"location":"guides/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore these advanced topics:</p>"},{"location":"guides/getting-started/#core-concepts","title":"Core Concepts","text":"<p>Learn about the fundamental concepts and architecture: - Core Concepts - Deep dive into decorators, models, and relationships</p>"},{"location":"guides/getting-started/#advanced-features","title":"Advanced Features","text":"<ul> <li>Relationships - Define one-to-many and many-to-one relationships</li> <li>Complex Queries - Advanced filtering and query building</li> <li>Data Validation - Custom validators and transformations</li> <li>TypeScript Types - Full type safety with <code>CreationOptional</code> and <code>NonAttribute</code></li> </ul>"},{"location":"guides/getting-started/#best-practices","title":"Best Practices","text":"<ul> <li>Always define a <code>@PrimaryKey()</code></li> <li>Use <code>CreationOptional</code> for fields with <code>@Default</code>, <code>@CreatedAt</code>, <code>@UpdatedAt</code></li> <li>Use <code>NonAttribute</code> for computed properties</li> <li>Validate user input with <code>@Validate</code></li> <li>Transform data with <code>@Mutate</code> before validation</li> <li>Use specific attribute selection to reduce data transfer</li> <li>Handle errors gracefully with try-catch blocks</li> </ul>"},{"location":"guides/getting-started/#additional-resources","title":"Additional Resources","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Examples - More code examples</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"guides/getting-started/#quick-reference","title":"Quick Reference","text":""},{"location":"guides/getting-started/#essential-decorators","title":"Essential Decorators","text":"Decorator Purpose Example <code>@PrimaryKey()</code> Primary key <code>@PrimaryKey() declare id: string</code> <code>@Default(fn)</code> Default value <code>@Default(() =&gt; uuid()) declare id: string</code> <code>@CreatedAt()</code> Auto timestamp on create <code>@CreatedAt() declare created_at: string</code> <code>@UpdatedAt()</code> Auto timestamp on update <code>@UpdatedAt() declare updated_at: string</code> <code>@Validate(fn)</code> Validation <code>@Validate((v) =&gt; v.length &gt; 0) declare name: string</code> <code>@Mutate(fn)</code> Transform data <code>@Mutate((v) =&gt; v.trim()) declare email: string</code> <code>@NotNull()</code> Not null check <code>@NotNull() declare email: string</code>"},{"location":"guides/getting-started/#essential-types","title":"Essential Types","text":"Type Purpose Usage <code>CreationOptional&lt;T&gt;</code> Optional on create Fields with <code>@Default</code>, <code>@CreatedAt</code>, <code>@UpdatedAt</code> <code>NonAttribute&lt;T&gt;</code> Not stored in DB Computed properties, getters, methods"},{"location":"guides/getting-started/#crud-operations","title":"CRUD Operations","text":"<pre><code>// Create\nconst user = await User.create({ name: \"John\" });\n\n// Read\nconst users = await User.where({ active: true });\nconst user = await User.first({ id: \"123\" });\n\n// Update\nuser.name = \"Jane\";\nawait user.save();\n// or\nawait User.update(\"123\", { name: \"Jane\" });\n\n// Delete\nawait user.destroy();\n// or\nawait User.delete(\"123\");\n</code></pre>"},{"location":"guides/getting-started/#getting-help","title":"Getting Help","text":"<p>If you encounter issues: 1. Check the Troubleshooting Guide 2. Review the API Reference 3. Search existing GitHub Issues 4. Create a new issue with a minimal reproducible example</p> <p>Happy coding with Dynamite!</p>"},{"location":"guides/relationships/","title":"Relationships Guide","text":"<p>Esta gu\u00eda completa cubre c\u00f3mo definir, cargar y consultar relaciones entre modelos en Dynamite ORM. Las relaciones permiten estructurar datos complejos y navegar entre entidades relacionadas de forma eficiente.</p>"},{"location":"guides/relationships/#tabla-de-contenidos","title":"Tabla de Contenidos","text":"<ul> <li>Tipos de Relaciones</li> <li>One-to-Many (@HasMany)</li> <li>Many-to-One (@BelongsTo)</li> <li>Definiendo Relaciones</li> <li>Cargando Relaciones</li> <li>Consultas con Relaciones</li> <li>Opciones de Relaciones</li> <li>Dependencias Circulares</li> <li>Consideraciones de Rendimiento</li> <li>Ejemplo Completo E-commerce</li> <li>Mejores Pr\u00e1cticas</li> </ul>"},{"location":"guides/relationships/#tipos-de-relaciones","title":"Tipos de Relaciones","text":"<p>Dynamite soporta dos tipos principales de relaciones:</p>"},{"location":"guides/relationships/#1-one-to-many-hasmany","title":"1. One-to-Many (@HasMany)","text":"<p>Un modelo padre puede tener m\u00faltiples instancias relacionadas. Ejemplo: un Usuario tiene muchos Pedidos.</p> <pre><code>@HasMany(() =&gt; Order, \"user_id\")\ndeclare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n</code></pre>"},{"location":"guides/relationships/#2-many-to-one-belongsto","title":"2. Many-to-One (@BelongsTo)","text":"<p>Un modelo hijo pertenece a un \u00fanico modelo padre. Ejemplo: un Pedido pertenece a un Usuario.</p> <pre><code>@BelongsTo(() =&gt; User, \"user_id\")\ndeclare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n</code></pre>"},{"location":"guides/relationships/#one-to-many-hasmany","title":"One-to-Many (@HasMany)","text":"<p>La relaci\u00f3n One-to-Many permite que un modelo padre tenga m\u00faltiples registros relacionados. Es la relaci\u00f3n m\u00e1s com\u00fan en aplicaciones.</p>"},{"location":"guides/relationships/#ejemplo-basico-usuario-y-posts","title":"Ejemplo B\u00e1sico: Usuario y Posts","text":"<pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  HasMany,\n  BelongsTo,\n  NotNull,\n  CreationOptional,\n  NonAttribute\n} from \"@arcaelas/dynamite\";\n\n// Modelo Usuario (Padre)\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare name: string;\n\n  @NotNull()\n  declare email: string;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n\n  // Relaci\u00f3n: Un usuario tiene muchos posts\n  @HasMany(() =&gt; Post, \"user_id\")\n  declare posts: NonAttribute&lt;HasMany&lt;Post&gt;&gt;;\n\n  // Relaci\u00f3n: Un usuario tiene muchos comentarios\n  @HasMany(() =&gt; Comment, \"user_id\")\n  declare comments: NonAttribute&lt;HasMany&lt;Comment&gt;&gt;;\n}\n\n// Modelo Post (Hijo)\nclass Post extends Table&lt;Post&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare user_id: string;\n\n  @NotNull()\n  declare title: string;\n\n  @NotNull()\n  declare content: string;\n\n  @Default(() =&gt; \"draft\")\n  declare status: CreationOptional&lt;string&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n\n  // Relaci\u00f3n inversa: Un post pertenece a un usuario\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  // Relaci\u00f3n: Un post tiene muchos comentarios\n  @HasMany(() =&gt; Comment, \"post_id\")\n  declare comments: NonAttribute&lt;HasMany&lt;Comment&gt;&gt;;\n}\n\n// Modelo Comment (Hijo de Post y User)\nclass Comment extends Table&lt;Comment&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare post_id: string;\n\n  @NotNull()\n  declare user_id: string;\n\n  @NotNull()\n  declare content: string;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  // Relaciones\n  @BelongsTo(() =&gt; Post, \"post_id\")\n  declare post: NonAttribute&lt;BelongsTo&lt;Post&gt;&gt;;\n\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n</code></pre>"},{"location":"guides/relationships/#uso-de-hasmany","title":"Uso de HasMany","text":"<pre><code>// Crear usuario con posts\nconst user = await User.create({\n  name: \"John Doe\",\n  email: \"john@example.com\"\n});\n\n// Crear posts para el usuario\nawait Post.create({\n  user_id: user.id,\n  title: \"Mi primer post\",\n  content: \"Contenido del post...\",\n  status: \"published\"\n});\n\nawait Post.create({\n  user_id: user.id,\n  title: \"Segundo post\",\n  content: \"M\u00e1s contenido...\",\n  status: \"draft\"\n});\n\n// Cargar usuario con sus posts\nconst usersWithPosts = await User.where({ id: user.id }, {\n  include: {\n    posts: {}\n  }\n});\n\nconst userWithPosts = usersWithPosts[0];\nconsole.log(`${userWithPosts.name} tiene ${userWithPosts.posts.length} posts`);\n\n// Iterar sobre los posts\nuserWithPosts.posts.forEach(post =&gt; {\n  console.log(`- ${post.title} (${post.status})`);\n});\n</code></pre>"},{"location":"guides/relationships/#many-to-one-belongsto","title":"Many-to-One (@BelongsTo)","text":"<p>La relaci\u00f3n Many-to-One es la inversa de One-to-Many. Define que un modelo hijo pertenece a un \u00fanico modelo padre.</p>"},{"location":"guides/relationships/#caracteristicas-de-belongsto","title":"Caracter\u00edsticas de BelongsTo","text":"<ol> <li>Foreign Key Requerida: El modelo hijo debe tener la foreign key</li> <li>Retorna Instancia \u00danica: Devuelve una instancia o null</li> <li>Lazy Loading: Solo se carga cuando se especifica en <code>include</code></li> </ol>"},{"location":"guides/relationships/#ejemplo-basico","title":"Ejemplo B\u00e1sico","text":"<pre><code>class Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare user_id: string;\n\n  @NotNull()\n  declare total: number;\n\n  @Default(() =&gt; \"pending\")\n  declare status: CreationOptional&lt;string&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  // Relaci\u00f3n: Un pedido pertenece a un usuario\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n\n// Uso\nconst orders = await Order.where({}, {\n  include: {\n    user: {\n      attributes: [\"id\", \"name\", \"email\"]\n    }\n  }\n});\n\norders.forEach(order =&gt; {\n  if (order.user) {\n    console.log(`Pedido ${order.id} de ${order.user.name}`);\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#relaciones-multiples-belongsto","title":"Relaciones M\u00faltiples BelongsTo","text":"<p>Un modelo puede tener m\u00faltiples relaciones BelongsTo:</p> <pre><code>class OrderItem extends Table&lt;OrderItem&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare order_id: string;\n\n  @NotNull()\n  declare product_id: string;\n\n  @NotNull()\n  declare quantity: number;\n\n  @NotNull()\n  declare price: number;\n\n  // M\u00faltiples relaciones BelongsTo\n  @BelongsTo(() =&gt; Order, \"order_id\")\n  declare order: NonAttribute&lt;BelongsTo&lt;Order&gt;&gt;;\n\n  @BelongsTo(() =&gt; Product, \"product_id\")\n  declare product: NonAttribute&lt;BelongsTo&lt;Product&gt;&gt;;\n}\n\n// Cargar con ambas relaciones\nconst items = await OrderItem.where({}, {\n  include: {\n    order: {\n      include: {\n        user: {}\n      }\n    },\n    product: {\n      attributes: [\"id\", \"name\", \"price\"]\n    }\n  }\n});\n\nitems.forEach(item =&gt; {\n  console.log(`${item.quantity}x ${item.product?.name} en pedido ${item.order?.id}`);\n  console.log(`Cliente: ${item.order?.user?.name}`);\n});\n</code></pre>"},{"location":"guides/relationships/#definiendo-relaciones","title":"Definiendo Relaciones","text":""},{"location":"guides/relationships/#foreign-keys","title":"Foreign Keys","text":"<p>Las foreign keys son campos que almacenan el ID del modelo relacionado:</p> <pre><code>class Post extends Table&lt;Post&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  // Foreign key hacia User\n  @NotNull()\n  declare user_id: string;\n\n  // Foreign key hacia Category\n  @NotNull()\n  declare category_id: string;\n\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  @BelongsTo(() =&gt; Category, \"category_id\")\n  declare category: NonAttribute&lt;BelongsTo&lt;Category&gt;&gt;;\n}\n</code></pre> <p>Importante: - La foreign key debe existir como campo en el modelo - Debe usar <code>@NotNull()</code> si la relaci\u00f3n es obligatoria - El nombre debe coincidir con el segundo par\u00e1metro del decorador</p>"},{"location":"guides/relationships/#lazy-loading","title":"Lazy Loading","text":"<p>Las relaciones no se cargan autom\u00e1ticamente. Debes especificarlas con <code>include</code>:</p> <pre><code>// SIN relaciones cargadas\nconst users = await User.where({});\nconsole.log(users[0].posts); // undefined\n\n// CON relaciones cargadas\nconst usersWithPosts = await User.where({}, {\n  include: {\n    posts: {}\n  }\n});\nconsole.log(usersWithPosts[0].posts); // Array de posts\n</code></pre>"},{"location":"guides/relationships/#nomenclatura-de-foreign-keys","title":"Nomenclatura de Foreign Keys","text":"<p>Convenciones recomendadas:</p> <pre><code>// Formato: {modelo_singular}_id\ndeclare user_id: string;      // Referencia a User\ndeclare order_id: string;     // Referencia a Order\ndeclare product_id: string;   // Referencia a Product\ndeclare category_id: string;  // Referencia a Category\n\n// M\u00faltiples relaciones al mismo modelo\ndeclare author_id: string;    // User como autor\ndeclare reviewer_id: string;  // User como revisor\ndeclare assignee_id: string;  // User como asignado\n</code></pre>"},{"location":"guides/relationships/#cargando-relaciones","title":"Cargando Relaciones","text":""},{"location":"guides/relationships/#metodo-include","title":"M\u00e9todo include()","text":"<p>El m\u00e9todo <code>include()</code> carga relaciones junto con el modelo principal:</p> <pre><code>// Cargar una relaci\u00f3n simple\nconst users = await User.where({}, {\n  include: {\n    posts: {}\n  }\n});\n\n// Cargar m\u00faltiples relaciones\nconst users = await User.where({}, {\n  include: {\n    posts: {},\n    comments: {}\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#relaciones-anidadas","title":"Relaciones Anidadas","text":"<p>Puedes cargar relaciones dentro de relaciones:</p> <pre><code>// 3 niveles de profundidad\nconst users = await User.where({}, {\n  include: {\n    posts: {\n      include: {\n        comments: {\n          include: {\n            user: {\n              attributes: [\"id\", \"name\"]\n            }\n          }\n        }\n      }\n    }\n  }\n});\n\n// Acceso a datos anidados\nusers.forEach(user =&gt; {\n  console.log(`Usuario: ${user.name}`);\n\n  user.posts?.forEach(post =&gt; {\n    console.log(`  Post: ${post.title}`);\n\n    post.comments?.forEach(comment =&gt; {\n      console.log(`    Comentario de ${comment.user?.name}: ${comment.content}`);\n    });\n  });\n});\n</code></pre>"},{"location":"guides/relationships/#include-con-opciones","title":"Include con Opciones","text":"<p>Puedes filtrar, limitar y ordenar relaciones cargadas:</p> <pre><code>const users = await User.where({}, {\n  include: {\n    posts: {\n      // Solo posts publicados\n      where: { status: \"published\" },\n\n      // \u00daltimos 5 posts\n      limit: 5,\n\n      // Ordenar por m\u00e1s reciente\n      order: \"DESC\",\n\n      // Solo estos campos\n      attributes: [\"id\", \"title\", \"createdAt\"],\n\n      // Cargar comentarios de cada post\n      include: {\n        comments: {\n          limit: 3,\n          order: \"DESC\"\n        }\n      }\n    }\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#seleccion-de-atributos-en-relaciones","title":"Selecci\u00f3n de Atributos en Relaciones","text":"<p>Limita los campos devueltos para optimizar performance:</p> <pre><code>const orders = await Order.where({}, {\n  // Campos del modelo principal\n  attributes: [\"id\", \"total\", \"status\"],\n\n  include: {\n    user: {\n      // Solo estos campos del usuario\n      attributes: [\"id\", \"name\", \"email\"]\n    },\n    items: {\n      attributes: [\"id\", \"quantity\", \"price\"],\n      include: {\n        product: {\n          // Solo nombre y precio del producto\n          attributes: [\"name\", \"price\"]\n        }\n      }\n    }\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#consultas-con-relaciones","title":"Consultas con Relaciones","text":""},{"location":"guides/relationships/#filtrar-por-campos-relacionados","title":"Filtrar por Campos Relacionados","text":"<p>Puedes aplicar condiciones where a las relaciones:</p> <pre><code>// Usuarios con posts publicados recientemente\nconst users = await User.where({}, {\n  include: {\n    posts: {\n      where: {\n        status: \"published\",\n        createdAt: { $gte: \"2024-01-01\" }\n      },\n      limit: 10\n    }\n  }\n});\n\n// Pedidos con items de productos espec\u00edficos\nconst orders = await Order.where({}, {\n  include: {\n    items: {\n      where: {\n        product_id: \"product-123\"\n      }\n    }\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#operadores-en-relaciones","title":"Operadores en Relaciones","text":"<p>Usa operadores de query en las condiciones de relaciones:</p> <pre><code>const users = await User.where({}, {\n  include: {\n    posts: {\n      // Posts con m\u00e1s de 100 vistas\n      where: { views: { $gt: 100 } },\n      order: \"DESC\"\n    },\n    orders: {\n      // Pedidos caros\n      where: { total: { $gte: 1000 } }\n    }\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#contar-elementos-relacionados","title":"Contar Elementos Relacionados","text":"<p>Para obtener conteo sin cargar todos los datos:</p> <pre><code>// Cargar usuarios con conteo de posts\nconst users = await User.where({});\n\nfor (const user of users) {\n  const postCount = await Post.where({ user_id: user.id }).then(posts =&gt; posts.length);\n  console.log(`${user.name}: ${postCount} posts`);\n}\n\n// M\u00e1s eficiente: Cargar con limit: 0 para solo contar\nconst usersWithCounts = await User.where({}, {\n  include: {\n    posts: {\n      attributes: [\"id\"]  // Solo ID para minimizar datos\n    }\n  }\n});\n\nusersWithCounts.forEach(user =&gt; {\n  console.log(`${user.name}: ${user.posts?.length || 0} posts`);\n});\n</code></pre>"},{"location":"guides/relationships/#opciones-de-relaciones","title":"Opciones de Relaciones","text":""},{"location":"guides/relationships/#custom-foreign-keys","title":"Custom Foreign Keys","text":"<p>Por defecto, Dynamite usa <code>{modelo}_id</code> como foreign key, pero puedes personalizarlo:</p> <pre><code>class Post extends Table&lt;Post&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  // Foreign key personalizada\n  @NotNull()\n  declare author_id: string;\n\n  // Especificar la foreign key personalizada\n  @BelongsTo(() =&gt; User, \"author_id\")\n  declare author: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n\n// En el modelo User\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  // Usar la misma foreign key personalizada\n  @HasMany(() =&gt; Post, \"author_id\")\n  declare authored_posts: NonAttribute&lt;HasMany&lt;Post&gt;&gt;;\n}\n</code></pre>"},{"location":"guides/relationships/#multiples-relaciones-al-mismo-modelo","title":"M\u00faltiples Relaciones al Mismo Modelo","text":"<pre><code>class Task extends Table&lt;Task&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare creator_id: string;\n\n  declare assignee_id: string;\n\n  declare reviewer_id: string;\n\n  // Tres relaciones diferentes a User\n  @BelongsTo(() =&gt; User, \"creator_id\")\n  declare creator: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  @BelongsTo(() =&gt; User, \"assignee_id\")\n  declare assignee: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  @BelongsTo(() =&gt; User, \"reviewer_id\")\n  declare reviewer: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n\n// Uso\nconst tasks = await Task.where({}, {\n  include: {\n    creator: {},\n    assignee: {},\n    reviewer: {}\n  }\n});\n\ntasks.forEach(task =&gt; {\n  console.log(`Tarea creada por ${task.creator?.name}`);\n  console.log(`Asignada a ${task.assignee?.name}`);\n  console.log(`Revisada por ${task.reviewer?.name}`);\n});\n</code></pre>"},{"location":"guides/relationships/#dependencias-circulares","title":"Dependencias Circulares","text":"<p>Las dependencias circulares ocurren cuando dos modelos se referencian entre s\u00ed. Dynamite las maneja usando funciones en lugar de referencias directas.</p>"},{"location":"guides/relationships/#problema-de-dependencias-circulares","title":"Problema de Dependencias Circulares","text":"<pre><code>// INCORRECTO - Esto causar\u00e1 error\nclass User extends Table&lt;User&gt; {\n  @HasMany(Post, \"user_id\")  // Post no est\u00e1 definido a\u00fan\n  declare posts: NonAttribute&lt;HasMany&lt;Post&gt;&gt;;\n}\n\nclass Post extends Table&lt;Post&gt; {\n  @BelongsTo(User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n</code></pre>"},{"location":"guides/relationships/#solucion-usar-funciones","title":"Soluci\u00f3n: Usar Funciones","text":"<pre><code>// CORRECTO - Usar funciones arrow\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  // Usar () =&gt; Post en lugar de Post directamente\n  @HasMany(() =&gt; Post, \"user_id\")\n  declare posts: NonAttribute&lt;HasMany&lt;Post&gt;&gt;;\n}\n\nclass Post extends Table&lt;Post&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare user_id: string;\n\n  // Usar () =&gt; User\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n}\n</code></pre>"},{"location":"guides/relationships/#por-que-funciona","title":"Por Qu\u00e9 Funciona","text":"<p>Las funciones permiten lazy evaluation - el modelo no se resuelve hasta que se ejecuta la funci\u00f3n, cuando ambas clases ya est\u00e1n definidas:</p> <pre><code>// La funci\u00f3n se ejecuta DESPU\u00c9S de que ambas clases existen\n() =&gt; Post  // Devuelve la clase Post cuando se llama\n\n// Vs referencia directa que se eval\u00faa INMEDIATAMENTE\nPost  // Debe existir en el momento de evaluaci\u00f3n\n</code></pre>"},{"location":"guides/relationships/#consideraciones-de-rendimiento","title":"Consideraciones de Rendimiento","text":""},{"location":"guides/relationships/#n1-query-problem","title":"N+1 Query Problem","text":"<p>El problema N+1 ocurre cuando cargas registros y luego haces queries adicionales para cada uno:</p> <pre><code>// MALO - N+1 queries\nconst users = await User.where({});  // 1 query\n\nfor (const user of users) {\n  // N queries adicionales (uno por cada usuario)\n  const posts = await Post.where({ user_id: user.id });\n  console.log(`${user.name}: ${posts.length} posts`);\n}\n// Total: 1 + N queries\n</code></pre>"},{"location":"guides/relationships/#solucion-eager-loading","title":"Soluci\u00f3n: Eager Loading","text":"<p>Usa <code>include</code> para cargar todas las relaciones en una sola operaci\u00f3n:</p> <pre><code>// BUENO - Una sola operaci\u00f3n\nconst users = await User.where({}, {\n  include: {\n    posts: {}\n  }\n});\n\nusers.forEach(user =&gt; {\n  console.log(`${user.name}: ${user.posts?.length || 0} posts`);\n});\n// Total: Operaci\u00f3n eficiente con include\n</code></pre>"},{"location":"guides/relationships/#limitar-datos-cargados","title":"Limitar Datos Cargados","text":"<pre><code>// Solo cargar lo necesario\nconst users = await User.where({}, {\n  attributes: [\"id\", \"name\", \"email\"],  // Campos m\u00ednimos\n  include: {\n    posts: {\n      attributes: [\"id\", \"title\"],      // Solo campos necesarios\n      limit: 5,                         // Limitar cantidad\n      where: { status: \"published\" }    // Filtrar datos\n    }\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#paginacion-con-relaciones","title":"Paginaci\u00f3n con Relaciones","text":"<pre><code>// Paginar el modelo principal\nconst users = await User.where({}, {\n  limit: 20,\n  skip: 0,\n  include: {\n    posts: {\n      limit: 5,  // Limitar posts por usuario\n      order: \"DESC\"\n    }\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#campos-calculados-vs-queries","title":"Campos Calculados vs Queries","text":"<pre><code>class Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  @NotNull()\n  declare user_id: string;\n\n  @HasMany(() =&gt; OrderItem, \"order_id\")\n  declare items: NonAttribute&lt;HasMany&lt;OrderItem&gt;&gt;;\n\n  // Computed property - No requiere query adicional\n  declare totalItems: NonAttribute&lt;number&gt;;\n\n  constructor(data?: any) {\n    super(data);\n\n    Object.defineProperty(this, 'totalItems', {\n      get: () =&gt; this.items?.reduce((sum, item) =&gt; sum + item.quantity, 0) || 0,\n      enumerable: true\n    });\n  }\n}\n\n// Uso eficiente\nconst orders = await Order.where({}, {\n  include: {\n    items: {\n      attributes: [\"id\", \"quantity\"]  // Solo lo necesario\n    }\n  }\n});\n\norders.forEach(order =&gt; {\n  console.log(`Pedido ${order.id}: ${order.totalItems} items`);\n  // No se hace query adicional - usa computed property\n});\n</code></pre>"},{"location":"guides/relationships/#ejemplo-completo-e-commerce","title":"Ejemplo Completo E-commerce","text":"<p>Sistema completo de e-commerce con Users, Orders, OrderItems y Products:</p> <pre><code>import {\n  Table,\n  PrimaryKey,\n  Default,\n  CreatedAt,\n  UpdatedAt,\n  HasMany,\n  BelongsTo,\n  NotNull,\n  Validate,\n  Mutate,\n  CreationOptional,\n  NonAttribute\n} from \"@arcaelas/dynamite\";\n\n// 1. MODELO USER\nclass User extends Table&lt;User&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  @Validate((value) =&gt; (value as string).length &gt;= 2 || \"Nombre muy corto\")\n  declare name: string;\n\n  @NotNull()\n  @Mutate((value) =&gt; (value as string).toLowerCase().trim())\n  @Validate((value) =&gt; /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value as string) || \"Email inv\u00e1lido\")\n  declare email: string;\n\n  @Default(() =&gt; \"customer\")\n  declare role: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; true)\n  declare active: CreationOptional&lt;boolean&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n\n  // Relaciones\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n\n  // Computed properties\n  declare orderCount: NonAttribute&lt;number&gt;;\n  declare totalSpent: NonAttribute&lt;number&gt;;\n\n  constructor(data?: any) {\n    super(data);\n\n    Object.defineProperty(this, 'orderCount', {\n      get: () =&gt; this.orders?.length || 0,\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'totalSpent', {\n      get: () =&gt; this.orders?.reduce((sum, order) =&gt; sum + order.total, 0) || 0,\n      enumerable: true\n    });\n  }\n}\n\n// 2. MODELO PRODUCT\nclass Product extends Table&lt;Product&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  @Validate((value) =&gt; (value as string).length &gt;= 3 || \"Nombre muy corto\")\n  declare name: string;\n\n  @Default(() =&gt; \"\")\n  declare description: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  @Validate((value) =&gt; (value as number) &gt;= 0 || \"Precio debe ser positivo\")\n  declare price: number;\n\n  @NotNull()\n  @Default(() =&gt; 0)\n  @Validate((value) =&gt; (value as number) &gt;= 0 || \"Stock no puede ser negativo\")\n  declare stock: CreationOptional&lt;number&gt;;\n\n  @Default(() =&gt; true)\n  declare available: CreationOptional&lt;boolean&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n\n  // Computed property\n  declare inStock: NonAttribute&lt;boolean&gt;;\n\n  constructor(data?: any) {\n    super(data);\n\n    Object.defineProperty(this, 'inStock', {\n      get: () =&gt; this.stock &gt; 0 &amp;&amp; this.available,\n      enumerable: true\n    });\n  }\n}\n\n// 3. MODELO ORDER\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare user_id: string;\n\n  @NotNull()\n  @Default(() =&gt; 0)\n  @Validate((value) =&gt; (value as number) &gt;= 0 || \"Total debe ser positivo\")\n  declare total: CreationOptional&lt;number&gt;;\n\n  @Default(() =&gt; \"pending\")\n  @Validate((value) =&gt;\n    [\"pending\", \"processing\", \"completed\", \"cancelled\"].includes(value as string) ||\n    \"Estado inv\u00e1lido\"\n  )\n  declare status: CreationOptional&lt;string&gt;;\n\n  @Default(() =&gt; \"\")\n  declare shipping_address: CreationOptional&lt;string&gt;;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  @UpdatedAt()\n  declare updatedAt: CreationOptional&lt;string&gt;;\n\n  // Relaciones\n  @BelongsTo(() =&gt; User, \"user_id\")\n  declare user: NonAttribute&lt;BelongsTo&lt;User&gt;&gt;;\n\n  @HasMany(() =&gt; OrderItem, \"order_id\")\n  declare items: NonAttribute&lt;HasMany&lt;OrderItem&gt;&gt;;\n\n  // Computed properties\n  declare itemCount: NonAttribute&lt;number&gt;;\n  declare totalQuantity: NonAttribute&lt;number&gt;;\n\n  constructor(data?: any) {\n    super(data);\n\n    Object.defineProperty(this, 'itemCount', {\n      get: () =&gt; this.items?.length || 0,\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'totalQuantity', {\n      get: () =&gt; this.items?.reduce((sum, item) =&gt; sum + item.quantity, 0) || 0,\n      enumerable: true\n    });\n  }\n}\n\n// 4. MODELO ORDER ITEM\nclass OrderItem extends Table&lt;OrderItem&gt; {\n  @PrimaryKey()\n  @Default(() =&gt; crypto.randomUUID())\n  declare id: CreationOptional&lt;string&gt;;\n\n  @NotNull()\n  declare order_id: string;\n\n  @NotNull()\n  declare product_id: string;\n\n  @NotNull()\n  @Default(() =&gt; 1)\n  @Validate((value) =&gt; (value as number) &gt; 0 || \"Cantidad debe ser mayor a 0\")\n  declare quantity: CreationOptional&lt;number&gt;;\n\n  @NotNull()\n  @Validate((value) =&gt; (value as number) &gt;= 0 || \"Precio debe ser positivo\")\n  declare price: number;\n\n  @CreatedAt()\n  declare createdAt: CreationOptional&lt;string&gt;;\n\n  // Relaciones\n  @BelongsTo(() =&gt; Order, \"order_id\")\n  declare order: NonAttribute&lt;BelongsTo&lt;Order&gt;&gt;;\n\n  @BelongsTo(() =&gt; Product, \"product_id\")\n  declare product: NonAttribute&lt;BelongsTo&lt;Product&gt;&gt;;\n\n  // Computed property\n  declare subtotal: NonAttribute&lt;number&gt;;\n\n  constructor(data?: any) {\n    super(data);\n\n    Object.defineProperty(this, 'subtotal', {\n      get: () =&gt; this.quantity * this.price,\n      enumerable: true\n    });\n  }\n}\n\n// ===== EJEMPLOS DE USO =====\n\nasync function CreateSampleData() {\n  // Crear usuario\n  const user = await User.create({\n    name: \"Juan P\u00e9rez\",\n    email: \"juan@example.com\"\n  });\n\n  // Crear productos\n  const laptop = await Product.create({\n    name: \"Laptop Gaming\",\n    description: \"Laptop de alto rendimiento\",\n    price: 1500,\n    stock: 10\n  });\n\n  const mouse = await Product.create({\n    name: \"Mouse Inal\u00e1mbrico\",\n    description: \"Mouse ergon\u00f3mico\",\n    price: 25,\n    stock: 50\n  });\n\n  const keyboard = await Product.create({\n    name: \"Teclado Mec\u00e1nico\",\n    description: \"Teclado RGB\",\n    price: 80,\n    stock: 30\n  });\n\n  // Crear orden\n  const order = await Order.create({\n    user_id: user.id,\n    total: 0,  // Se calcular\u00e1 despu\u00e9s\n    status: \"pending\",\n    shipping_address: \"Calle Principal 123\"\n  });\n\n  // Crear items del pedido\n  const items = await Promise.all([\n    OrderItem.create({\n      order_id: order.id,\n      product_id: laptop.id,\n      quantity: 1,\n      price: laptop.price\n    }),\n    OrderItem.create({\n      order_id: order.id,\n      product_id: mouse.id,\n      quantity: 2,\n      price: mouse.price\n    }),\n    OrderItem.create({\n      order_id: order.id,\n      product_id: keyboard.id,\n      quantity: 1,\n      price: keyboard.price\n    })\n  ]);\n\n  // Calcular y actualizar total\n  const total = items.reduce((sum, item) =&gt; sum + item.subtotal, 0);\n  await Order.update(order.id, { total });\n\n  console.log(\"Datos de ejemplo creados exitosamente\");\n  return { user, order, products: [laptop, mouse, keyboard] };\n}\n\nasync function GetUserOrders(userId: string) {\n  const users = await User.where({ id: userId }, {\n    include: {\n      orders: {\n        include: {\n          items: {\n            include: {\n              product: {\n                attributes: [\"id\", \"name\", \"price\"]\n              }\n            }\n          }\n        },\n        order: \"DESC\"\n      }\n    }\n  });\n\n  const user = users[0];\n  if (!user) return null;\n\n  console.log(`\\nUsuario: ${user.name} (${user.email})`);\n  console.log(`Total de pedidos: ${user.orderCount}`);\n  console.log(`Total gastado: $${user.totalSpent.toFixed(2)}\\n`);\n\n  user.orders?.forEach(order =&gt; {\n    console.log(`Pedido #${order.id}`);\n    console.log(`Estado: ${order.status}`);\n    console.log(`Total: $${order.total.toFixed(2)}`);\n    console.log(`Items: ${order.itemCount}`);\n    console.log(`Cantidad total: ${order.totalQuantity}`);\n    console.log(`Direcci\u00f3n: ${order.shipping_address}`);\n    console.log(`Items:`);\n\n    order.items?.forEach(item =&gt; {\n      console.log(`  - ${item.product?.name} x${item.quantity} @ $${item.price} = $${item.subtotal}`);\n    });\n    console.log(\"\");\n  });\n\n  return user;\n}\n\nasync function GetOrderDetails(orderId: string) {\n  const orders = await Order.where({ id: orderId }, {\n    include: {\n      user: {\n        attributes: [\"id\", \"name\", \"email\"]\n      },\n      items: {\n        include: {\n          product: {}\n        }\n      }\n    }\n  });\n\n  const order = orders[0];\n  if (!order) return null;\n\n  console.log(`\\nPedido #${order.id}`);\n  console.log(`Cliente: ${order.user?.name} (${order.user?.email})`);\n  console.log(`Estado: ${order.status}`);\n  console.log(`Direcci\u00f3n: ${order.shipping_address}`);\n  console.log(`Fecha: ${order.createdAt}\\n`);\n\n  console.log(\"Items:\");\n  order.items?.forEach(item =&gt; {\n    const product = item.product;\n    console.log(`  ${product?.name}`);\n    console.log(`    Precio: $${item.price}`);\n    console.log(`    Cantidad: ${item.quantity}`);\n    console.log(`    Subtotal: $${item.subtotal}`);\n    console.log(`    Stock disponible: ${product?.stock}`);\n  });\n\n  console.log(`\\nTotal del pedido: $${order.total.toFixed(2)}`);\n  console.log(`Total de items: ${order.totalQuantity}`);\n\n  return order;\n}\n\nasync function UpdateOrderStatus(orderId: string, newStatus: string) {\n  const order = await Order.update(orderId, {\n    status: newStatus\n  });\n\n  console.log(`Pedido ${orderId} actualizado a ${newStatus}`);\n  return order;\n}\n\nasync function GetProductsSoldReport() {\n  const products = await Product.where({});\n\n  for (const product of products) {\n    const items = await OrderItem.where({ product_id: product.id }, {\n      include: {\n        order: {\n          where: { status: \"completed\" }\n        }\n      }\n    });\n\n    const totalSold = items.reduce((sum, item) =&gt; sum + item.quantity, 0);\n    const revenue = items.reduce((sum, item) =&gt; sum + item.subtotal, 0);\n\n    console.log(`\\nProducto: ${product.name}`);\n    console.log(`Precio: $${product.price}`);\n    console.log(`Stock actual: ${product.stock}`);\n    console.log(`Unidades vendidas: ${totalSold}`);\n    console.log(`Ingresos: $${revenue.toFixed(2)}`);\n  }\n}\n</code></pre>"},{"location":"guides/relationships/#mejores-practicas","title":"Mejores Pr\u00e1cticas","text":""},{"location":"guides/relationships/#1-siempre-usar-funciones-en-decoradores","title":"1. Siempre Usar Funciones en Decoradores","text":"<pre><code>// CORRECTO\n@HasMany(() =&gt; Order, \"user_id\")\n@BelongsTo(() =&gt; User, \"user_id\")\n\n// INCORRECTO\n@HasMany(Order, \"user_id\")\n@BelongsTo(User, \"user_id\")\n</code></pre>"},{"location":"guides/relationships/#2-validar-foreign-keys","title":"2. Validar Foreign Keys","text":"<pre><code>class Order extends Table&lt;Order&gt; {\n  // Siempre validar que la foreign key no sea null\n  @NotNull()\n  @Validate((value) =&gt; typeof value === \"string\" &amp;&amp; value.length &gt; 0 || \"user_id requerido\")\n  declare user_id: string;\n}\n</code></pre>"},{"location":"guides/relationships/#3-usar-nonattribute-para-relaciones","title":"3. Usar NonAttribute para Relaciones","text":"<pre><code>// CORRECTO - Excluir de operaciones de BD\n@HasMany(() =&gt; Post, \"user_id\")\ndeclare posts: NonAttribute&lt;HasMany&lt;Post&gt;&gt;;\n\n// INCORRECTO - Intentar\u00e1 guardar en BD\n@HasMany(() =&gt; Post, \"user_id\")\ndeclare posts: HasMany&lt;Post&gt;;\n</code></pre>"},{"location":"guides/relationships/#4-computed-properties-para-agregaciones","title":"4. Computed Properties para Agregaciones","text":"<pre><code>class User extends Table&lt;User&gt; {\n  @HasMany(() =&gt; Order, \"user_id\")\n  declare orders: NonAttribute&lt;HasMany&lt;Order&gt;&gt;;\n\n  // Usar computed en lugar de queries adicionales\n  declare totalOrders: NonAttribute&lt;number&gt;;\n  declare totalRevenue: NonAttribute&lt;number&gt;;\n\n  constructor(data?: any) {\n    super(data);\n\n    Object.defineProperty(this, 'totalOrders', {\n      get: () =&gt; this.orders?.length || 0,\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'totalRevenue', {\n      get: () =&gt; this.orders?.reduce((sum, o) =&gt; sum + o.total, 0) || 0,\n      enumerable: true\n    });\n  }\n}\n</code></pre>"},{"location":"guides/relationships/#5-limitar-profundidad-de-includes","title":"5. Limitar Profundidad de Includes","text":"<pre><code>// EVITAR - Demasiado profundo\nconst users = await User.where({}, {\n  include: {\n    orders: {\n      include: {\n        items: {\n          include: {\n            product: {\n              include: {\n                category: {\n                  include: {\n                    parent: {}  // 5 niveles\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n});\n\n// PREFERIR - M\u00e1ximo 2-3 niveles\nconst users = await User.where({}, {\n  include: {\n    orders: {\n      include: {\n        items: {}\n      }\n    }\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#6-seleccionar-solo-atributos-necesarios","title":"6. Seleccionar Solo Atributos Necesarios","text":"<pre><code>// Eficiente\nconst users = await User.where({}, {\n  attributes: [\"id\", \"name\"],\n  include: {\n    orders: {\n      attributes: [\"id\", \"total\", \"status\"],\n      where: { status: \"completed\" }\n    }\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#7-eager-loading-vs-lazy-loading","title":"7. Eager Loading vs Lazy Loading","text":"<pre><code>// Eager loading - Una sola operaci\u00f3n\nconst users = await User.where({}, {\n  include: { orders: {} }\n});\n\n// Lazy loading - M\u00faltiples queries (evitar cuando sea posible)\nconst users = await User.where({});\nfor (const user of users) {\n  user.orders = await Order.where({ user_id: user.id });\n}\n</code></pre>"},{"location":"guides/relationships/#8-paginacion-con-relaciones","title":"8. Paginaci\u00f3n con Relaciones","text":"<pre><code>// Paginar modelo principal y limitar relaciones\nconst users = await User.where({}, {\n  limit: 20,\n  skip: pageNum * 20,\n  include: {\n    orders: {\n      limit: 5,  // Solo \u00faltimos 5 pedidos por usuario\n      order: \"DESC\"\n    }\n  }\n});\n</code></pre>"},{"location":"guides/relationships/#9-indices-y-foreign-keys","title":"9. \u00cdndices y Foreign Keys","text":"<pre><code>// Asegurar que foreign keys est\u00e9n indexadas\nclass Order extends Table&lt;Order&gt; {\n  @PrimaryKey()\n  declare id: string;\n\n  // Foreign key - deber\u00eda tener \u00edndice en DynamoDB\n  @Index()  // Si es necesario\n  @NotNull()\n  declare user_id: string;\n}\n</code></pre>"},{"location":"guides/relationships/#10-manejo-de-errores","title":"10. Manejo de Errores","text":"<pre><code>async function GetUserWithOrders(userId: string) {\n  try {\n    const users = await User.where({ id: userId }, {\n      include: {\n        orders: {\n          include: {\n            items: {}\n          }\n        }\n      }\n    });\n\n    if (!users.length) {\n      throw new Error(\"Usuario no encontrado\");\n    }\n\n    const user = users[0];\n\n    if (!user.orders || user.orders.length === 0) {\n      console.log(\"Usuario sin pedidos\");\n    }\n\n    return user;\n  } catch (error) {\n    console.error(\"Error al cargar usuario:\", error);\n    throw error;\n  }\n}\n</code></pre>"},{"location":"guides/relationships/#resumen","title":"Resumen","text":"<p>Las relaciones en Dynamite permiten:</p> <ol> <li>Estructurar datos complejos con One-to-Many y Many-to-One</li> <li>Navegar entre entidades usando include anidados</li> <li>Optimizar queries con eager loading</li> <li>Filtrar y limitar datos relacionados</li> <li>Computed properties para agregaciones eficientes</li> </ol> <p>Puntos clave: - Usar <code>() =&gt;</code> en decoradores para evitar dependencias circulares - Aplicar <code>NonAttribute&lt;&gt;</code> a propiedades de relaciones - Preferir eager loading sobre m\u00faltiples queries - Limitar profundidad y cantidad de datos cargados - Validar foreign keys con <code>@NotNull()</code> y <code>@Validate()</code></p> <p>Para m\u00e1s informaci\u00f3n consulta la documentaci\u00f3n principal.</p>"},{"location":"es/","title":"Bienvenido a Arcaelas Dynamite","text":"<p>ORM moderno basado en decoradores para AWS DynamoDB con soporte TypeScript.</p>"},{"location":"es/#que-es-dynamite","title":"\u00bfQu\u00e9 es Dynamite?","text":"<p>Arcaelas Dynamite es una potente librer\u00eda de Mapeo Objeto-Relacional (ORM) basada en decoradores para AWS DynamoDB. Proporciona una API limpia e intuitiva que aprovecha los decoradores de TypeScript para definir tus modelos de datos con seguridad de tipos y m\u00ednimo c\u00f3digo repetitivo.</p>"},{"location":"es/#caracteristicas-principales","title":"Caracter\u00edsticas Principales","text":""},{"location":"es/#diseno-basado-en-decoradores","title":"Dise\u00f1o Basado en Decoradores","text":"<p>Define tus modelos usando decoradores familiares de TypeScript:</p> <pre><code>import { Table, PrimaryKey, CreatedAt, UpdatedAt } from '@arcaelas/dynamite';\n\nclass User extends Table {\n  @PrimaryKey()\n  id: string;\n\n  @Default(() =&gt; 'active')\n  status: string;\n\n  @CreatedAt()\n  created_at: Date;\n\n  @UpdatedAt()\n  updated_at: Date;\n}\n</code></pre>"},{"location":"es/#relaciones-con-seguridad-de-tipos","title":"Relaciones con Seguridad de Tipos","text":"<p>Soporte integrado para relaciones uno-a-muchos y muchos-a-uno:</p> <pre><code>import { HasMany, BelongsTo } from '@arcaelas/dynamite';\n\nclass User extends Table {\n  @HasMany(() =&gt; Post, 'user_id')\n  posts: HasMany&lt;Post&gt;;\n}\n\nclass Post extends Table {\n  @BelongsTo(() =&gt; User, 'user_id')\n  user: BelongsTo&lt;User&gt;;\n}\n</code></pre>"},{"location":"es/#constructor-de-consultas-potente","title":"Constructor de Consultas Potente","text":"<p>Interfaz de consultas intuitiva con soporte completo de TypeScript:</p> <pre><code>const active_users = await User.where('status', '=', 'active')\n  .where('created_at', '&gt;', new Date('2024-01-01'))\n  .include('posts')\n  .get();\n</code></pre>"},{"location":"es/#validacion-y-transformacion","title":"Validaci\u00f3n y Transformaci\u00f3n","text":"<p>Decoradores integrados para validaci\u00f3n y mutaci\u00f3n de datos:</p> <pre><code>class User extends Table {\n  @Validate(value =&gt; value.length &gt;= 8, 'La contrase\u00f1a debe tener al menos 8 caracteres')\n  password: string;\n\n  @Mutate(value =&gt; value.toLowerCase().trim())\n  email: string;\n}\n</code></pre>"},{"location":"es/#inicio-rapido","title":"Inicio R\u00e1pido","text":""},{"location":"es/#instalacion","title":"Instalaci\u00f3n","text":"<pre><code>npm install @arcaelas/dynamite\n# o\nyarn add @arcaelas/dynamite\n</code></pre>"},{"location":"es/#uso-basico","title":"Uso B\u00e1sico","text":"<pre><code>import { Dynamite, Table, PrimaryKey } from '@arcaelas/dynamite';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\n\n// Configurar cliente DynamoDB\nconst client = new DynamoDBClient({ region: 'us-east-1' });\nDynamite.configure({ client });\n\n// Define tu modelo\nclass User extends Table {\n  @PrimaryKey()\n  id: string;\n\n  name: string;\n  email: string;\n}\n\n// Crear un nuevo usuario\nconst user = await User.create({\n  id: '123',\n  name: 'Juan P\u00e9rez',\n  email: 'juan@ejemplo.com'\n});\n\n// Consultar usuarios\nconst users = await User.where('name', '=', 'Juan P\u00e9rez').get();\n\n// Actualizar\nuser.email = 'nuevoemail@ejemplo.com';\nawait user.save();\n\n// Eliminar\nawait user.destroy();\n</code></pre>"},{"location":"es/#resumen-de-arquitectura","title":"Resumen de Arquitectura","text":"<p>Dynamite est\u00e1 construido sobre tres conceptos fundamentales:</p> <ol> <li>Table - Clase base para todos los modelos con operaciones CRUD</li> <li>Decorators - Definen esquema, validaci\u00f3n y comportamiento</li> <li>Relationships - Conectan modelos con asociaciones seguras de tipos</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Tus Modelos                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  User extends Table              \u2502   \u2502\n\u2502  \u2502  - @PrimaryKey() id              \u2502   \u2502\n\u2502  \u2502  - @HasMany() posts              \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Dynamite ORM                    \u2502\n\u2502  - Constructor de Consultas              \u2502\n\u2502  - Resolutor de Relaciones               \u2502\n\u2502  - Procesamiento de Decoradores          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         AWS SDK v3                       \u2502\n\u2502  - DynamoDBClient                        \u2502\n\u2502  - DynamoDB Document Client              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"es/#por-que-dynamite","title":"\u00bfPor Qu\u00e9 Dynamite?","text":"<ul> <li>Seguridad de Tipos - Soporte completo de TypeScript con tipos avanzados</li> <li>Experiencia del Desarrollador - API limpia e intuitiva con m\u00ednimo c\u00f3digo repetitivo</li> <li>Moderno - Construido sobre AWS SDK v3 con soporte ESM</li> <li>Flexible - Soporta consultas complejas, relaciones y l\u00f3gica personalizada</li> <li>Ligero - Dependencias m\u00ednimas, enfocado en DynamoDB</li> </ul>"},{"location":"es/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Gu\u00eda de Instalaci\u00f3n - Configura Dynamite en tu proyecto</li> <li>Comenzando - Tu primer modelo Dynamite</li> <li>Conceptos B\u00e1sicos - Entendiendo los fundamentos</li> <li>Referencia API - Documentaci\u00f3n completa de la API</li> </ul>"},{"location":"es/#comunidad","title":"Comunidad","text":"<ul> <li>GitHub: github.com/arcaelas/dynamite</li> <li>Issues: Reportar bugs o solicitar caracter\u00edsticas</li> <li>NPM: @arcaelas/dynamite</li> </ul> <p>\u00bfListo para comenzar? Instala Dynamite y crea tu primer modelo en minutos.</p>"},{"location":"de/","title":"Willkommen bei Arcaelas Dynamite","text":"<p>Modernes Decorator-basiertes ORM f\u00fcr AWS DynamoDB mit TypeScript-Unterst\u00fctzung.</p>"},{"location":"de/#was-ist-dynamite","title":"Was ist Dynamite?","text":"<p>Arcaelas Dynamite ist eine leistungsstarke, Decorator-basierte Object-Relational Mapping (ORM) Bibliothek f\u00fcr AWS DynamoDB. Sie bietet eine saubere, intuitive API, die TypeScript-Decorators nutzt, um Ihre Datenmodelle mit Typsicherheit und minimalem Boilerplate zu definieren.</p>"},{"location":"de/#hauptmerkmale","title":"Hauptmerkmale","text":""},{"location":"de/#decorator-first-design","title":"Decorator-First Design","text":"<p>Definieren Sie Ihre Modelle mit vertrauten TypeScript-Decorators:</p> <pre><code>import { Table, PrimaryKey, CreatedAt, UpdatedAt } from '@arcaelas/dynamite';\n\nclass User extends Table {\n  @PrimaryKey()\n  id: string;\n\n  @Default(() =&gt; 'active')\n  status: string;\n\n  @CreatedAt()\n  created_at: Date;\n\n  @UpdatedAt()\n  updated_at: Date;\n}\n</code></pre>"},{"location":"de/#typsichere-beziehungen","title":"Typsichere Beziehungen","text":"<p>Integrierte Unterst\u00fctzung f\u00fcr Eins-zu-Viele und Viele-zu-Eins Beziehungen:</p> <pre><code>import { HasMany, BelongsTo } from '@arcaelas/dynamite';\n\nclass User extends Table {\n  @HasMany(() =&gt; Post, 'user_id')\n  posts: HasMany&lt;Post&gt;;\n}\n\nclass Post extends Table {\n  @BelongsTo(() =&gt; User, 'user_id')\n  user: BelongsTo&lt;User&gt;;\n}\n</code></pre>"},{"location":"de/#leistungsstarker-query-builder","title":"Leistungsstarker Query Builder","text":"<p>Intuitive Query-Schnittstelle mit vollst\u00e4ndiger TypeScript-Unterst\u00fctzung:</p> <pre><code>const active_users = await User.where('status', '=', 'active')\n  .where('created_at', '&gt;', new Date('2024-01-01'))\n  .include('posts')\n  .get();\n</code></pre>"},{"location":"de/#validierung-transformation","title":"Validierung &amp; Transformation","text":"<p>Integrierte Decorators f\u00fcr Datenvalidierung und Mutation:</p> <pre><code>class User extends Table {\n  @Validate(value =&gt; value.length &gt;= 8, 'Passwort muss mindestens 8 Zeichen haben')\n  password: string;\n\n  @Mutate(value =&gt; value.toLowerCase().trim())\n  email: string;\n}\n</code></pre>"},{"location":"de/#schnellstart","title":"Schnellstart","text":""},{"location":"de/#installation","title":"Installation","text":"<pre><code>npm install @arcaelas/dynamite\n# oder\nyarn add @arcaelas/dynamite\n</code></pre>"},{"location":"de/#grundlegende-verwendung","title":"Grundlegende Verwendung","text":"<pre><code>import { Dynamite, Table, PrimaryKey } from '@arcaelas/dynamite';\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\n\n// DynamoDB-Client konfigurieren\nconst client = new DynamoDBClient({ region: 'us-east-1' });\nDynamite.configure({ client });\n\n// Definieren Sie Ihr Modell\nclass User extends Table {\n  @PrimaryKey()\n  id: string;\n\n  name: string;\n  email: string;\n}\n\n// Neuen Benutzer erstellen\nconst user = await User.create({\n  id: '123',\n  name: 'Max Mustermann',\n  email: 'max@beispiel.de'\n});\n\n// Benutzer abfragen\nconst users = await User.where('name', '=', 'Max Mustermann').get();\n\n// Aktualisieren\nuser.email = 'neueemail@beispiel.de';\nawait user.save();\n\n// L\u00f6schen\nawait user.destroy();\n</code></pre>"},{"location":"de/#architekturubersicht","title":"Architektur\u00fcbersicht","text":"<p>Dynamite basiert auf drei Kernkonzepten:</p> <ol> <li>Table - Basisklasse f\u00fcr alle Modelle mit CRUD-Operationen</li> <li>Decorators - Definieren Schema, Validierung und Verhalten</li> <li>Relationships - Verbinden Modelle mit typsicheren Assoziationen</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Ihre Modelle                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  User extends Table              \u2502   \u2502\n\u2502  \u2502  - @PrimaryKey() id              \u2502   \u2502\n\u2502  \u2502  - @HasMany() posts              \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Dynamite ORM                    \u2502\n\u2502  - Query Builder                         \u2502\n\u2502  - Relationship Resolver                 \u2502\n\u2502  - Decorator-Verarbeitung                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         AWS SDK v3                       \u2502\n\u2502  - DynamoDBClient                        \u2502\n\u2502  - DynamoDB Document Client              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"de/#warum-dynamite","title":"Warum Dynamite?","text":"<ul> <li>Typsicherheit - Vollst\u00e4ndige TypeScript-Unterst\u00fctzung mit erweiterten Typen</li> <li>Entwicklererfahrung - Saubere, intuitive API mit minimalem Boilerplate</li> <li>Modern - Basierend auf AWS SDK v3 mit ESM-Unterst\u00fctzung</li> <li>Flexibel - Unterst\u00fctzt komplexe Abfragen, Beziehungen und benutzerdefinierte Logik</li> <li>Leichtgewichtig - Minimale Abh\u00e4ngigkeiten, fokussiert auf DynamoDB</li> </ul>"},{"location":"de/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Installationsanleitung - Richten Sie Dynamite in Ihrem Projekt ein</li> <li>Erste Schritte - Ihr erstes Dynamite-Modell</li> <li>Kernkonzepte - Die Grundlagen verstehen</li> <li>API-Referenz - Vollst\u00e4ndige API-Dokumentation</li> </ul>"},{"location":"de/#community","title":"Community","text":"<ul> <li>GitHub: github.com/arcaelas/dynamite</li> <li>Issues: Fehler melden oder Funktionen anfordern</li> <li>NPM: @arcaelas/dynamite</li> </ul> <p>Bereit anzufangen? Installieren Sie Dynamite und erstellen Sie Ihr erstes Modell in Minuten.</p>"}]}